/*
** GB BASIC
**
** Copyright (C) 2023-2025 Tony Wang, all rights reserved
**
** For the latest info, see https://paladin-t.github.io/kits/gbb/
*/

#include "codepoint.h"
#include "compiler.h"
#include "../utils/encoding.h"
#include "../utils/file_handle.h"
#include "../utils/filesystem.h"
#include "../utils/platform.h"
#include "../utils/plus.h"
#include "../utils/rom_inspector.h"
#include "../utils/text.h"
#include "../../lib/jpath/jpath.hpp"
#include "../../lib/rapidfuzz_cpp/rapidfuzz/fuzz.hpp"
#include <stack>

/*
** Notes
**
** Search for the following tag in this file for specific information:
**   -  "DOC: RAM SCHEMA"       for RAM schema
**   -  "DOC: ROM SCHEMA"       for ROM schema
**   -  "DOC: CARTRIDGE SCHEMA" for cartridge schema
**   -  "DOC: GLYPHS"           for glyphs' schema
**   - "FEAT: TEXT FORMAT"      for text-format-based instructions
**   - "FEAT: OPTIMIZATION"     for code optimization
**   - "FEAT: MACRO"            for macro function and stack reference
**   - "FEAT: OBSOLETE"         for obsolate features
**   - "FEAT: GBB EXTENSION"    for extension features
*/

/*
** {===========================================================================
** Macros and constants
*/

namespace GBBASIC {

/**< Common. */

#ifndef FALSE
#	define FALSE 0
#endif /* FALSE */
#ifndef TRUE
#	define TRUE 1
#endif /* TRUE */
#ifndef BOOLEAN
#	define BOOLEAN(V) ((bool)(V) ? TRUE : FALSE)
#endif /* BOOLEAN */
#ifndef RGB8
#	define RGB8(R, G, B) (((UInt16)((((B) >> 3) & 0x1f) << 10)) | ((UInt16)((((G) >> 3) & 0x1f) << 5)) | (((R) >> 3) & 0x1f))
#endif /* RGB8 */
#ifndef PAGE
#	define PAGE(P, Q) (((P) >= 0) ? (P) : (Q))
#endif /* PAGE */
#ifndef CHECK
#	define CHECK(E) do { if ((E) != 0) return; } while (false)
#endif /* CHECK */

#ifndef EVER
#	define EVER ; ;
#endif /* EVER */
#ifndef ANYTHING
#	define ANYTHING "?"
#endif /* ANYTHING */

#ifndef NEGATIVE
	// The negative operator is defined as following for internal processing,
	// to avoid conflicting with other tokens.
#	define NEGATIVE "\\"
#endif /* NEGATIVE */

#ifndef GLYPH_TERMINATION
#	define GLYPH_TERMINATION 0
#endif /* GLYPH_TERMINATION */
#ifndef GLYPH_SPACE
#	define GLYPH_SPACE 1
#endif /* GLYPH_SPACE */
#ifndef GLYPH_ESCAPE_RETURN
#	define GLYPH_ESCAPE_RETURN '\r'
#endif /* GLYPH_ESCAPE_RETURN */
#ifndef GLYPH_ESCAPE_NEW_LINE
#	define GLYPH_ESCAPE_NEW_LINE '\n'
#endif /* GLYPH_ESCAPE_NEW_LINE */
#ifndef GLYPH_ESCAPE_NEW_PAGE
#	define GLYPH_ESCAPE_NEW_PAGE '\f'
#endif /* GLYPH_ESCAPE_NEW_PAGE */
#ifndef GLYPH_ESCAPE_PLACEHOLDER
#	define GLYPH_ESCAPE_PLACEHOLDER '%'
#endif /* GLYPH_ESCAPE_PLACEHOLDER */
#ifndef GLYPH_ESCAPE_INT
#	define GLYPH_ESCAPE_INT 'd'
#endif /* GLYPH_ESCAPE_INT */
#ifndef GLYPH_ESCAPE_HEX
#	define GLYPH_ESCAPE_HEX 'x'
#endif /* GLYPH_ESCAPE_HEX */
#ifndef GLYPH_ESCAPE_CHAR
#	define GLYPH_ESCAPE_CHAR 'c'
#endif /* GLYPH_ESCAPE_CHAR */
#ifndef GLYPH_ESCAPE_PERCENT
#	define GLYPH_ESCAPE_PERCENT '%'
#endif /* GLYPH_ESCAPE_PERCENT */
#ifndef GLYPH_ESCAPE_SPECIAL
#	define GLYPH_ESCAPE_SPECIAL '\\'
#endif /* GLYPH_ESCAPE_SPECIAL */
#ifndef GLYPH_ESCAPE_UNICODE
#	define GLYPH_ESCAPE_UNICODE 'u'
#endif /* GLYPH_ESCAPE_UNICODE */
#ifndef GLYPH_ESCAPE_STACK
#	define GLYPH_ESCAPE_STACK '#'
#endif /* GLYPH_ESCAPE_STACK */
#ifndef GLYPH_ESCAPE_BACKSLASH
#	define GLYPH_ESCAPE_BACKSLASH '\\'
#endif /* GLYPH_ESCAPE_BACKSLASH */

/**< Syntax. */

#ifndef DIMENSION_MAX_COUNT
#	define DIMENSION_MAX_COUNT 4
#endif /* DIMENSION_MAX_COUNT */

#ifndef DECLARE_WITH_LET_AND_ACCEPT_ELSEWHERE_ENABLED
#	define DECLARE_WITH_LET_AND_ACCEPT_ELSEWHERE_ENABLED 1
#endif /* DECLARE_WITH_LET_AND_ACCEPT_ELSEWHERE_ENABLED */
#ifndef DECLARE_WITH_READ_ENABLED
#	define DECLARE_WITH_READ_ENABLED 0
#endif /* DECLARE_WITH_READ_ENABLED */
#ifndef DECLARE_WITH_TOUCH_ENABLED
#	define DECLARE_WITH_TOUCH_ENABLED 0
#endif /* DECLARE_WITH_TOUCH_ENABLED */
#ifndef DECLARE_WITH_VIEWPORT_ENABLED
#	define DECLARE_WITH_VIEWPORT_ENABLED 0
#endif /* DECLARE_WITH_VIEWPORT_ENABLED */

#ifndef DATA_SEQUENCE_WITH_CONSTANT_ONLY
#	define DATA_SEQUENCE_WITH_CONSTANT_ONLY 0
#endif /* DATA_SEQUENCE_WITH_CONSTANT_ONLY */

#ifndef THREAD_PARAMETER_MAX_COUNT
#	define THREAD_PARAMETER_MAX_COUNT 3
#endif /* THREAD_PARAMETER_MAX_COUNT */

#ifndef NESTED_STRUCTURE_MAX_COUNT
#	define NESTED_STRUCTURE_MAX_COUNT 16
#endif /* NESTED_STRUCTURE_MAX_COUNT */

#ifndef REPORT_MISUSING_COLORED_FEATURE_ENABLED
#	define REPORT_MISUSING_COLORED_FEATURE_ENABLED 1
#endif /* REPORT_MISUSING_COLORED_FEATURE_ENABLED */
#ifndef REPORT_MISUSING_EXTENSION_FEATURE_ENABLED
#	define REPORT_MISUSING_EXTENSION_FEATURE_ENABLED 1
#endif /* REPORT_MISUSING_EXTENSION_FEATURE_ENABLED */

/**< Emitter. */

#ifndef HALT_AT_PAGE_END_ENABLED
#	define HALT_AT_PAGE_END_ENABLED 1
#endif /* HALT_AT_PAGE_END_ENABLED */

#ifndef MAP_ON_WITH_IMAGE_ENABLED 
#	define MAP_ON_WITH_IMAGE_ENABLED  1
#endif /* MAP_ON_WITH_IMAGE_ENABLED  */

/**< Parser. */

#ifndef RESERVED
#	define RESERVED nullptr
#endif /* RESERVED */
#ifndef NODE
#	define NODE nullptr
#endif /* NODE */
#ifndef ENUM
#	define ENUM GBBASIC_UNIQUE_NAME(__ENUM__)
#endif /* ENUM */

/**< Compiler. */

#ifndef ASSET_SOURCE_IGNORED
#	define ASSET_SOURCE_IGNORED -1
#endif /* ASSET_SOURCE_IGNORED */
#ifndef ASSET_SOURCE_STACK
#	define ASSET_SOURCE_STACK 0
#endif /* ASSET_SOURCE_STACK */
#ifndef ASSET_SOURCE_READ
#	define ASSET_SOURCE_READ 1
#endif /* ASSET_SOURCE_READ */
#ifndef ASSET_SOURCE_DATA
#	define ASSET_SOURCE_DATA 2
#endif /* ASSET_SOURCE_DATA */
#ifndef ASSET_SOURCE_FAR
#	define ASSET_SOURCE_FAR 3
#endif /* ASSET_SOURCE_FAR */

#ifndef FUZZY_MATCHING_SCORE_THRESHOLD
#	define FUZZY_MATCHING_SCORE_THRESHOLD 0.75
#endif /* FUZZY_MATCHING_SCORE_THRESHOLD */

#ifndef NODE_TYPE
#	define NODE_TYPE(Y) \
	virtual Types type(void) const override { return (Y); }
#endif /* NODE_TYPE */

/**< Conventions. */

#ifndef ROM_MAX_SIZE
#	define ROM_MAX_SIZE (4 * 1024 * 1024) // DOC: CARTRIDGE SCHEMA.
#endif /* ROM_MAX_SIZE */
#ifndef BANK_SIZE
#	define BANK_SIZE 0x4000 // DOC: CARTRIDGE SCHEMA.
#endif /* BANK_SIZE */

#ifndef ICON_ENTRY_NAME
#	define ICON_ENTRY_NAME "Icon" // DOC: ROM SCHEMA.
#endif /* ICON_ENTRY_NAME */

#ifndef EXTENSION_MODE_ENTRY_NAME
#	define EXTENSION_MODE_ENTRY_NAME "ExtensionMode" // DOC: ROM SCHEMA.
#endif /* EXTENSION_MODE_ENTRY_NAME */

#ifndef BACKGROUND_PALETTES_ENTRY_NAME
#	define BACKGROUND_PALETTES_ENTRY_NAME "BackgroundPalettes" // DOC: ROM SCHEMA.
#endif /* BACKGROUND_PALETTES_ENTRY_NAME */
#ifndef SPRITE_PALETTES_ENTRY_NAME
#	define SPRITE_PALETTES_ENTRY_NAME "SpritePalettes" // DOC: ROM SCHEMA.
#endif /* SPRITE_PALETTES_ENTRY_NAME */

#ifndef BEEP_ENTRY_NAME
#	define BEEP_ENTRY_NAME "Beep" // DOC: ROM SCHEMA.
#endif /* BEEP_ENTRY_NAME */

#ifndef PERSISTENCE_SIGNATURE_ENTRY_NAME
#	define PERSISTENCE_SIGNATURE_ENTRY_NAME "PERSISTENCE_SIGNATURE" // DOC: ROM SCHEMA.
#endif /* PERSISTENCE_SIGNATURE_ENTRY_NAME */

#ifndef BOOTSTRAP_ENTRY_NAME
#	define BOOTSTRAP_ENTRY_NAME "BOOTSTRAP" // DOC: ROM SCHEMA.
#endif /* BOOTSTRAP_ENTRY_NAME */
#ifndef BOOTSTRAP_ENTRY_ADDRESS // Will use this address when failed to lookup with entry name.
#	define BOOTSTRAP_ENTRY_ADDRESS 0x4000 // DOC: ROM SCHEMA.
#endif /* BOOTSTRAP_ENTRY_ADDRESS */

#ifndef SCRIPT_MEMORY_ENTRY_NAME
#	define SCRIPT_MEMORY_ENTRY_NAME "script_memory" // DOC: RAM SCHEMA.
#endif /* SCRIPT_MEMORY_ENTRY_NAME */

/**< Shared between the VM and the compiler. */

// Directions.

#ifndef DIRECTIONS
#	define DIRECTIONS
#	define DIRECTION_NONE                                           8
#	define DIRECTION_DOWN                                           0
#	define DIRECTION_RIGHT                                          1
#	define DIRECTION_UP                                             2
#	define DIRECTION_LEFT                                           3
#endif /* DIRECTIONS */

// Properties.

#ifndef PROPERTIES
#	define PROPERTIES

	// Basic properties.
#	define PROPERTY_PALETTE                                         1
#	define PROPERTY_HFLIP                                           2
#	define PROPERTY_VFLIP                                           3
#	define PROPERTY_PRIORITY                                        4
#	define PROPERTY_HIDDEN                                          5

	// Advanced properties.
#	define PROPERTY_ACTIVE                                          6
#	define PROPERTY_ENABLED                                         7
#	define PROPERTY_PINNED                                          8
#	define PROPERTY_PERSISTENT                                      9
#	define PROPERTY_FOLLOWING                                       10
#	define PROPERTY_ANIMATION_LOOP                                  11
#	define PROPERTY_ANIMATION_PAUSED                                12
#	define PROPERTY_MOVEMENT_INTERRUPT                              13
#	define PROPERTY_POSITION                                        14
#		define PROPERTY_POSITION_X                                  15
#		define PROPERTY_POSITION_Y                                  16
#	define PROPERTY_DIRECTION                                       17
#	define PROPERTY_ANGLE                                           18
#	define PROPERTY_BOUNDS                                          19
#		define PROPERTY_BOUNDS_LEFT                                 20
#		define PROPERTY_BOUNDS_RIGHT                                21
#		define PROPERTY_BOUNDS_TOP                                  22
#		define PROPERTY_BOUNDS_BOTTOM                               23
#	define PROPERTY_BASE_TILE                                       24
#	define PROPERTY_FRAMES                                          25
#		define PROPERTY_FRAME_INDEX                                 26
#	define PROPERTY_ANIMATION_INTERVAL                              27
#	define PROPERTY_ANIMATIONS                                      28
#		define PROPERTY_ANIMATION                                   29
#		define PROPERTY_ANIMATION_INDEX                             30
#	define PROPERTY_MOVE_SPEED                                      31
#	define PROPERTY_BEHAVIOUR                                       32
#	define PROPERTY_COLLISION_GROUP                                 33

#	define PROPERTY_STRONG                                          34
#	define PROPERTY_LIFE_TIME                                       35
#	define PROPERTY_INITIAL_OFFSET                                  36

#	define PROPERTY_IS_16x16_GRID                                   37
#	define PROPERTY_IS_16x16_PLAYER                                 38
#	define PROPERTY_CLAMP_CAMERA                                    39
#	define PROPERTY_GRAVITY                                         40
#	define PROPERTY_JUMP_GRAVITY                                    41
#	define PROPERTY_JUMP_MAX_COUNT                                  42
#	define PROPERTY_JUMP_MAX_TICKS                                  43
#	define PROPERTY_CLIMB_VELOCITY                                  44
#	define PROPERTY_SIZE                                            45
#		define PROPERTY_SIZE_WIDTH                                  46
#		define PROPERTY_SIZE_HEIGHT                                 47
#	define PROPERTY_CAMERA_DEADZONE                                 48
#		define PROPERTY_CAMERA_DEADZONE_X                           49
#		define PROPERTY_CAMERA_DEADZONE_Y                           50
#	define PROPERTY_BLOCKING                                        51
#		define PROPERTY_BLOCKING_X                                  52
#			define PROPERTY_BLOCKING_LEFT                           53
#			define PROPERTY_BLOCKING_RIGHT                          54
#		define PROPERTY_BLOCKING_Y                                  55
#			define PROPERTY_BLOCKING_UP                             56
#			define PROPERTY_BLOCKING_DOWN                           57
#endif /* PROPERTIES */

// Types.

#ifndef TYPES
#	define TYPES
#	define OBJECT_TYPE_ACTOR                                        0x01
#	define OBJECT_TYPE_PROJECTILE                                   0x02
#endif /* TYPES */

// Events.

#ifndef EVENTS
#	define EVENTS
#	define EVENT_HANDLER_GOTO                                       0x00
#	define EVENT_HANDLER_GOSUB                                      0x40
#	define EVENT_HANDLER_START                                      0x80
#endif /* EVENTS */

#ifndef EVENTS_ENTER_LEAVE_CHANGE_CONFIRM
#	define EVENTS_ENTER_LEAVE_CHANGE_CONFIRM
#	define EVENT_ENTER                                              0x01
#	define EVENT_LEAVE                                              0x02
#	define EVENT_CHANGE                                             0x04
#	define EVENT_CONFIRM                                            0x08
#endif /* EVENTS_ENTER_LEAVE_CHANGE_CONFIRM */

// Exceptions.

#ifndef EXCEPTIONS
#	define EXCEPTIONS
#	define EXCEPTION_UNKNOWN_PARAMETER                              1
#	define EXCEPTION_DEVICE_ERROR                                   0x01
#endif /* EXCEPTIONS */

// Graphics.

#ifndef GRAPHICS_MODES
#	define GRAPHICS_MODES
#	define GRAPHICS_MODE_SOLID                                      0x00
#	define GRAPHICS_MODE_OR                                         0x01
#	define GRAPHICS_MODE_XOR                                        0x02
#	define GRAPHICS_MODE_AND                                        0x03
#endif /* GRAPHICS_MODES */

#ifndef GRAPHICS_PALETTES
#	define GRAPHICS_PALETTES
#	define GRAPHICS_PALETTE_WHITE                                   0x00
#	define GRAPHICS_PALETTE_SILVER                                  0x01
#	define GRAPHICS_PALETTE_GRAY                                    0x02
#	define GRAPHICS_PALETTE_BLACK                                   0x03
#endif /* GRAPHICS_PALETTES */

#ifndef GRAPHICS_LAYERS
#	define GRAPHICS_LAYERS
#	define GRAPHICS_LAYER_MAP                                       0
#	define GRAPHICS_LAYER_WINDOW                                    1
#	define GRAPHICS_LAYER_SPRITE                                    2
#endif /* GRAPHICS_LAYERS */

#ifndef GRAPHICS_VALUES
#	define GRAPHICS_VALUES
#	define GRAPHICS_AUTO_OFFSET                                     0x7fff // Max value of 16-bit signed, 32767.
#endif /* GRAPHICS_VALUES */

// Audio.

#ifndef AUDIO_PRIORITIES
#	define AUDIO_PRIORITIES
#	define AUDIO_SFX_PRIORITY_MINIMAL                               1
#	define AUDIO_SFX_PRIORITY_NORMAL                                4
#	define AUDIO_SFX_PRIORITY_HIGH                                  8
#endif /* AUDIO_PRIORITIES */

// Input.

#ifndef INPUT_BUTTONS
#	define INPUT_BUTTONS
#	define INPUT_BUTTON_UP                                          0x04
#	define INPUT_BUTTON_DOWN                                        0x08
#	define INPUT_BUTTON_LEFT                                        0x02
#	define INPUT_BUTTON_RIGHT                                       0x01
#	define INPUT_BUTTON_A                                           0x10
#	define INPUT_BUTTON_B                                           0x20
#	define INPUT_BUTTON_SELECT                                      0x40
#	define INPUT_BUTTON_START                                       0x80
#	define INPUT_MOUSE_BUTTON_0                                     0x01
#	define INPUT_MOUSE_BUTTON_1                                     0x02
#	define INPUT_MOUSE_BUTTON_ANY                                   (INPUT_MOUSE_BUTTON_0 || INPUT_MOUSE_BUTTON_1)
#endif /* INPUT_BUTTONS */

#ifndef INPUT_HANDLERS
#	define INPUT_HANDLERS
#	define INPUT_HANDLER_BTN_UP                                     0
#	define INPUT_HANDLER_BTN_DOWN                                   1
#	define INPUT_HANDLER_BTN_LEFT                                   2
#	define INPUT_HANDLER_BTN_RIGHT                                  3
#	define INPUT_HANDLER_BTN_A                                      4
#	define INPUT_HANDLER_BTN_B                                      5
#	define INPUT_HANDLER_BTN_SELECT                                 6
#	define INPUT_HANDLER_BTN_START                                  7
#	define INPUT_HANDLER_BTN_ANY                                    8
#	define INPUT_HANDLER_BTND_UP                                    9
#	define INPUT_HANDLER_BTND_DOWN                                  10
#	define INPUT_HANDLER_BTND_LEFT                                  11
#	define INPUT_HANDLER_BTND_RIGHT                                 12
#	define INPUT_HANDLER_BTND_A                                     13
#	define INPUT_HANDLER_BTND_B                                     14
#	define INPUT_HANDLER_BTND_SELECT                                15
#	define INPUT_HANDLER_BTND_START                                 16
#	define INPUT_HANDLER_BTND_ANY                                   17
#	define INPUT_HANDLER_BTNU_UP                                    18
#	define INPUT_HANDLER_BTNU_DOWN                                  19
#	define INPUT_HANDLER_BTNU_LEFT                                  20
#	define INPUT_HANDLER_BTNU_RIGHT                                 21
#	define INPUT_HANDLER_BTNU_A                                     22
#	define INPUT_HANDLER_BTNU_B                                     23
#	define INPUT_HANDLER_BTNU_SELECT                                24
#	define INPUT_HANDLER_BTNU_START                                 25
#	define INPUT_HANDLER_BTNU_ANY                                   26
#	define INPUT_HANDLER_TOUCH                                      27
#	define INPUT_HANDLER_TOUCHD                                     28
#	define INPUT_HANDLER_TOUCHU                                     29
#	define INPUT_HANDLER_COUNT                                      30
#	define INPUT_HANDLER_INVALID                                    0xff
#endif /* INPUT_HANDLERS */

// Persistence.

#ifndef SRAM_ADDRESSES
#	define SRAM_ADDRESSES
#	define SRAM_FSIGNATURE_SIZE                                     sizeof(UInt16)
#	define SRAM_ADDRESS                                             0xa000
#	define SRAM_OFFSET                                              (SRAM_ADDRESS + SRAM_FSIGNATURE_SIZE)
#endif /* SRAM_ADDRESSES */

// Serial port.

#ifndef SERIAL_STATUSES
#	define SERIAL_STATUSES
#	define SERIAL_ERROR                                             -1
#	define SERIAL_BUSY                                              -2
#	define SERIAL_IDLE                                              -3
#endif /* SERIAL_STATUSES */

// Scene.

#ifndef SCENE_MASKS
#	define SCENE_MASKS
#	define SCENE_MASK_BLOCKING                                      0x0f
#	define SCENE_MASK_BLOCKING_X                                    0x03
#		define SCENE_MASK_BLOCKING_LEFT                             0x01
#		define SCENE_MASK_BLOCKING_RIGHT                            0x02
#	define SCENE_MASK_BLOCKING_Y                                    0x0c
#		define SCENE_MASK_BLOCKING_UP                               0x04
#		define SCENE_MASK_BLOCKING_DOWN                             0x08
#endif /* SCENE_MASKS */

#ifndef SCENE_LAYERS
#	define SCENE_LAYERS
#	define SCENE_LAYER_MAP                                          0x00
#	define SCENE_LAYER_ATTR                                         0x01
#	define SCENE_LAYER_PROP                                         0x02
#	define SCENE_LAYER_ACTOR                                        0x04
#	define SCENE_LAYER_TRIGGER                                      0x08
#	define SCENE_LAYER_DEF                                          0x10
#	define SCENE_LAYER_ALL                                          (SCENE_LAYER_MAP | SCENE_LAYER_ATTR | SCENE_LAYER_PROP | SCENE_LAYER_ACTOR | SCENE_LAYER_TRIGGER | SCENE_LAYER_DEF)
#endif /* SCENE_LAYERS */

#ifndef SCENE_CAMERA_SHAKE_DIRECTIONS
#	define SCENE_CAMERA_SHAKE_DIRECTIONS
#	define SCENE_CAMERA_SHAKE_X                                     1
#	define SCENE_CAMERA_SHAKE_Y                                     2
#endif /* SCENE_CAMERA_SHAKE_DIRECTIONS */

#ifndef SCENE_HANDLERS
#	define SCENE_HANDLERS
#	define SCENE_HANDLER_MOVE                                       1
#endif /* SCENE_HANDLERS */

// Actor.

#ifndef ACTOR_RESOURCES
#	define ACTOR_RESOURCES
#	define ACTOR_TEMPLATE_NONE                                      0xff
#	define ACTOR_TEMPLATE_ANY                                       ACTOR_TEMPLATE_NONE
#endif /* ACTOR_RESOURCES */

#ifndef ACTOR_THREADING
#	define ACTOR_THREADING
#	define ACTOR_THREADING_BEGIN                                    1
#	define ACTOR_THREADING_JOIN                                     2
#	define ACTOR_THREADING_TERMINATE                                3
#	define ACTOR_THREADING_WAIT                                     4
#endif /* ACTOR_THREADING */

#ifndef ACTOR_MOTIONS
#	define ACTOR_MOTIONS
#	define ACTOR_MOTION_IN_DIRECTION                                1
#	define ACTOR_MOTION_TO_POINT                                    2
#	define ACTOR_MOTION_STOP                                        3
#endif /* ACTOR_MOTIONS */

#ifndef ACTOR_FILTERS
#	define ACTOR_FILTERS
#	define ACTOR_FILTER_BY_TEMPLATE                                 1
#	define ACTOR_FILTER_BY_BEHAVIOUR                                2
#endif /* ACTOR_FILTERS */

#ifndef ACTOR_HANDLERS
#	define ACTOR_HANDLERS
#	define ACTOR_HANDLER_HITS                                       1
#endif /* ACTOR_HANDLERS */

// Controller.

#ifndef CONTROLLER_BEHAVIOURS
#	define CONTROLLER_BEHAVIOURS
#	define CONTROLLER_ALWAYS_BEHAVE                                 0x80
#	define CONTROLLER_BEHAVIOUR_NONE                                0x00
#	define CONTROLLER_BEHAVIOUR_PLATFORMER_PLAYER                   0x01
#	define CONTROLLER_BEHAVIOUR_PLATFORMER_MOVE                     0x02
#	define CONTROLLER_BEHAVIOUR_PLATFORMER_IDLE                     0x03
#	define CONTROLLER_BEHAVIOUR_TOPDOWN_PLAYER                      0x04
#		define CONTROLLER_BEHAVIOUR_TOPDOWN_PLAYER_ARBITRARY        0x05
#	define CONTROLLER_BEHAVIOUR_TOPDOWN_MOVE                        0x06
#		define CONTROLLER_BEHAVIOUR_TOPDOWN_MOVE_ARBITRARY          0x07
#	define CONTROLLER_BEHAVIOUR_TOPDOWN_IDLE                        0x08
#	define CONTROLLER_BEHAVIOUR_POINTNCLICK_PLAYER                  0x09
#	define CONTROLLER_BEHAVIOUR_POINTNCLICK_PLAYER_WITH_MOUSE      (0x0a | CONTROLLER_ALWAYS_BEHAVE)
#	define CONTROLLER_BEHAVIOUR_POINTNCLICK_PLAYER_WITH_TOUCH      (0x0b | CONTROLLER_ALWAYS_BEHAVE)
#	define CONTROLLER_MOVABLE_FLAG_NONE                             0x00
#	define CONTROLLER_MOVABLE_FLAG_COLLISIONS                       0x01
#	define CONTROLLER_MOVABLE_FLAG_FULL                             0x02
#endif /* CONTROLLER_BEHAVIOURS */

// Projectile.

#ifndef PROJECTILE_START_METHODS
#	define PROJECTILE_START_METHODS
#	define PROJECTILE_START_INDEPENDENTLY                           0x01
#	define PROJECTILE_START_WITH_ACTOR                              0x02
#endif /* PROJECTILE_START_METHODS */

#ifndef PROJECTILE_FLAGS
#	define PROJECTILE_FLAGS
#	define PROJECTILE_FLAG_NONE                                     0x00
#	define PROJECTILE_FLAG_ANIMATION_NO_LOOP                        0x01
#	define PROJECTILE_FLAG_STRONG                                   0x02
#endif /* PROJECTILE_FLAGS */

// GUI.

#ifndef GUI_WIDGET_TYPES
#	define GUI_WIDGET_TYPES
#	define GUI_WIDGET_TYPE_NONE                                     0
#	define GUI_WIDGET_TYPE_LABEL                                    1
#	define GUI_WIDGET_TYPE_PROGRESSBAR                              2
#	define GUI_WIDGET_TYPE_MENU                                     3
#endif /* GUI_WIDGET_TYPES */

#ifndef GUI_CONVENTIONS
#	define GUI_CONVENTIONS
#	define GUI_BLIT_INTERVAL                                        10
#endif /* GUI_CONVENTIONS */

// Game.

#ifndef GAME_SHAPES
#	define GAME_SHAPES
#	define GAME_SHAPES_BOX_BOX                                      1
#	define GAME_SHAPES_BOX_POINT                                    2
#endif /* GAME_SHAPES */

// Effects.

#ifndef EFFECTS_TYPES
#	define EFFECTS_TYPES
#	define EFFECTS_PULSE                                            1
#	define EFFECTS_PARALLAX                                         2
#	define EFFECTS_WOBBLE                                           3
#endif /* EFFECTS_TYPES */

// Device.

#ifndef DEVICE_SCREEN_MODES
#	define DEVICE_SCREEN_MODES
#	define DEVICE_SCREEN_TEXT                                       1
#	define DEVICE_SCREEN_GRAPHICS                                   2
#	define DEVICE_SCREEN_OBJECTS                                    3
#endif /* DEVICE_SCREEN_MODES */

#ifndef DEVICE_VRAM_USAGES
#	define DEVICE_VRAM_USAGES
#	define DEVICE_VRAM_USAGE_BANK_0                                 0
#	define DEVICE_VRAM_USAGE_TILES                                  0
#	define DEVICE_VRAM_USAGE_BANK_1                                 1
#	define DEVICE_VRAM_USAGE_ATTRIBUTES                             1
#endif /* DEVICE_VRAM_USAGES */

#ifndef DEVICE_TRIGGER
#	define DEVICE_TRIGGER
#	define DEVICE_TRIGGER_ACTIVE_TRIGGERS                           0x3d
#endif /* DEVICE_RTC */

#ifndef DEVICE_RTC
#	define DEVICE_RTC
#	define DEVICE_RTC_SEC                                           0x61
#	define DEVICE_RTC_MIN                                           0x62
#	define DEVICE_RTC_HOUR                                          0x63
#	define DEVICE_RTC_DAY                                           0x64
#endif /* DEVICE_RTC */

#ifndef DEVICE_OPTIONS
#	define DEVICE_OPTIONS
#	define DEVICE_OPTION_FAST_CPU_ENABLED                           0x01
#	define DEVICE_OPTION_AUTO_UPDATE_ENABLED                        0x02
#	define DEVICE_OPTION_ACTOR_HIT_WITH_DETAILS_ENABLED             0x03
#	define DEVICE_OPTION_OBJECT_SPRITE_BASE                         0x04
#	define DEVICE_OPTION_SRAM_BANK                                  0x11
#	define DEVICE_OPTION_SRAM_ENABLED                               0x12
#	define DEVICE_OPTION_VRAM_BANK                                  0x21
#	define DEVICE_OPTION_VRAM_USAGE                                 0x22
#	define DEVICE_OPTION_SCREEN_ENABLED                             0x31
#	define DEVICE_OPTION_SCREEN_MODE                                0x32
#	define DEVICE_OPTION_MAP_ENABLED                                0x33
#	define DEVICE_OPTION_WINDOW_ENABLED                             0x34
#	define DEVICE_OPTION_SPRITE_ENABLED                             0x35
#	define DEVICE_OPTION_SPRITE8x16_ENABLED                         0x36
#	define DEVICE_OPTION_ACTIVE_TRIGGERS                         /* 0x3d */ DEVICE_TRIGGER_ACTIVE_TRIGGERS
#	define DEVICE_OPTION_SOUND_ENABLED                              0x41
#	define DEVICE_OPTION_MUSIC_POSITION                             0x42
#	define DEVICE_OPTION_SERIAL_ENABLED                             0x51
#	define DEVICE_OPTION_RTC_ENABLED                                0x65
#	define DEVICE_OPTION_RTC_START                                  0x66
#	define DEVICE_OPTION_RTC_LATCH                                  0x67
#endif /* DEVICE_OPTIONS */
#ifndef DEVICE_QUERIES
#	define DEVICE_QUERIES
#	define DEVICE_QUERY_IS_CGB                                      0x01
#	define DEVICE_QUERY_IS_SGB                                      0x02
#	define DEVICE_QUERY_IS_AGB                                      0x03
#	define DEVICE_QUERY_IS_GBB                                      0x04
#	define DEVICE_QUERY_MAX_THREADS                                 0x05
#	define DEVICE_QUERY_ACTIVE_THREADS                              0x06
#	define DEVICE_QUERY_FREE_THREADS                                0x07
#	define DEVICE_QUERY_CURRENT_THREAD_ID                           0x08
#	define DEVICE_QUERY_SRAM_BANKS                                  0x11
#	define DEVICE_QUERY_SRAM_LENGTH                                 0x12
#	define DEVICE_QUERY_VRAM_BANKS                                  0x21
#	define DEVICE_QUERY_MAP_X                                       0x31
#	define DEVICE_QUERY_MAP_Y                                       0x32
#	define DEVICE_QUERY_CAMERA_X                                    0x33
#	define DEVICE_QUERY_CAMERA_Y                                    0x34
#	define DEVICE_QUERY_MAX_ACTORS                                  0x35
#	define DEVICE_QUERY_INSTANTIATED_ACTORS                         0x36
#	define DEVICE_QUERY_FREE_ACTORS                                 0x37
#	define DEVICE_QUERY_ACTIVE_ACTORS                               0x38
#	define DEVICE_QUERY_MAX_PROJECTILES                             0x39
#	define DEVICE_QUERY_ACTIVE_PROJECTILES                          0x3a
#	define DEVICE_QUERY_FREE_PROJECTILES                            0x3b
#	define DEVICE_QUERY_MAX_TRIGGERS                                0x3c
#	define DEVICE_QUERY_ACTIVE_TRIGGERS                          /* 0x3d */ DEVICE_TRIGGER_ACTIVE_TRIGGERS
#	define DEVICE_QUERY_FREE_TRIGGERS                               0x3e
#	define DEVICE_QUERY_SERIAL_STATUS                               0x51
#	define DEVICE_QUERY_SYS_TIME                                    0x71
#	define DEVICE_QUERY_DIV_REG                                     0x72
#	define DEVICE_QUERY_PLATFORM_FLAGS                              0x81
#endif /* DEVICE_QUERIES */

// Streaming.
#ifndef STREAMING_STATUSES
#	define STREAMING_STATUSES
#	define STREAMING_STATUS_READY                                   0x00
#	define STREAMING_STATUS_BUSY                                    0x01
#	define STREAMING_STATUS_FILLED                                  0x02
#	define STREAMING_STATUS_EOS                                     0x80
#endif /* STREAMING_STATUSES */

/**< Guards. */

#ifndef VAR_GUARD
#	define VAR_GUARD(VAR, VAL) \
		VariableGuard<decltype(VAR)> GBBASIC_UNIQUE_NAME(__VARGUARD__)(&(VAR), (VAR), (VAL))
#endif /* VAR_GUARD */
#ifndef COND_VAR_GUARD
#	define COND_VAR_GUARD(COND, VAR, VAL) \
		ConditionalVariableGuard<decltype(VAR)> GBBASIC_UNIQUE_NAME(__VARGUARD__)(COND, &(VAR), (VAR), (VAL))
#endif /* COND_VAR_GUARD */
#ifndef PROC_GUARD
#	define PROC_GUARD(PREV, POST) \
		ProcedureGuard<int> GBBASIC_UNIQUE_NAME(__PROCGUARD__)( \
			[&] (void) -> int* { \
				(PREV)(); \
				return nullptr; \
			}, \
			[&] (int*) -> void { \
				(POST)(); \
			} \
		)
#endif /* PROC_GUARD */

/**< Type declarations. */

typedef Int16 Word;
static constexpr const int WORD_SIZE = sizeof(Word);
static_assert(WORD_SIZE == 2, "Wrong type.");
typedef UInt16 UWord;
static constexpr const int UWORD_SIZE = sizeof(UWord);
static_assert(UWORD_SIZE == 2, "Wrong type.");

static constexpr const int RAM_SIZE = 8 * 1024;

}

/* ===========================================================================} */

/*
** {===========================================================================
** Utilities
*/

namespace GBBASIC {

enum class Endians {
	LITTLE,
	BIG
};

static bool isDifferentEndian(Endians endian) {
	return
		(!Platform::isLittleEndian() && endian == Endians::LITTLE) ||
		(Platform::isLittleEndian() && endian == Endians::BIG);
}

static bool isEscape(Font::Codepoint cp) {
	return
		cp == GLYPH_ESCAPE_RETURN ||
		cp == GLYPH_ESCAPE_NEW_LINE ||
		cp == GLYPH_ESCAPE_NEW_PAGE;
}

static bool isPrintable(const std::string &str) {
	if (str.empty())
		return false;

	if (str.length() == 1 /* && str.front() >= 0 && str.front() <= 255 */)
		return true;

	if (Unicode::isPrintable(str.c_str(), str.length()))
		return true;

	return false;
}

static bool escapeUnicode(const wchar_t* &wptr, unsigned &cp) {
	// Prepare.
	cp = 0;

	// Extract the code.
	std::string buf;
	for (int i = 0; i < 4; ++i) {
		if (!*wptr)
			break;

		buf.push_back((std::string::value_type)*wptr++);
	}
	if (buf.empty())
		buf.push_back('0');
	buf = "0x" + buf;

	// Convert the code to string.
	if (!Text::fromString(buf, cp))
		return false;

	// Validate the string.
	if (cp > 255)
		return false;

	// Finish.
	return true;
}

static const wchar_t* escapeUnicode(const wchar_t* &wptr, std::wstring &wstr) {
	// Prepare.
	wstr.clear();

	// Extract the code.
	std::string buf;
	for (int i = 0; i < 4; ++i) {
		if (!*wptr)
			break;

		buf.push_back((std::string::value_type)*wptr++);
	}
	if (buf.empty())
		buf.push_back('0');
	buf = "0x" + buf;

	// Convert the code to string.
	unsigned cp = 0;
	std::string str_;
	if (Text::fromString(buf, cp)) {
		wstr.push_back((wchar_t)cp);
		str_ = Unicode::fromWide(wstr);
	}

	// Validate the string.
	if (!isPrintable(str_)) {
		str_ = "\\u????"; // Notify invalid code.
		wstr = Unicode::toWide(str_);
	}

	// Finish.
	return wptr;
}

/**
 * @param[out] codepoints
 * @param[out] uniqueCodepoints
 * @param[out] invalid
 */
static bool analyzeString(std::string str, Font::Codepoints &codepoints, Font::Codepoints &uniqueCodepoints, bool* invalid /* nullable */) {
	bool hasEsc = false;
	str = Text::replace(str, "\\r", "\r");
	str = Text::replace(str, "\\n", "\n");
	str = Text::replace(str, "\\f", "\f");
	const std::wstring wstr = Unicode::toWide(str);
	const wchar_t* wptr = wstr.c_str();
	while (*wptr) {
		wchar_t cp = *wptr++;
		if (!cp) {
			if (invalid)
				*invalid = true;
			codepoints.clear();

			break;
		}
		if (cp == GLYPH_ESCAPE_PLACEHOLDER) {
			const wchar_t cp_ = *wptr++;
			if (!cp_) {
				if (invalid)
					*invalid = true;
				codepoints.clear();

				break;
			}
			switch (cp_) {
			case GLYPH_ESCAPE_INT: // Fall through.
			case GLYPH_ESCAPE_HEX: // Fall through.
			case GLYPH_ESCAPE_CHAR:
				codepoints.add(cp);
				codepoints.add(cp_);

				hasEsc = true;

				continue;
			case GLYPH_ESCAPE_PERCENT:
				codepoints.add(cp);
				cp = cp_;

				hasEsc = true;

				break;
			}
		} else if (cp == GLYPH_ESCAPE_SPECIAL) {
			const wchar_t cp_ = *wptr++;
			if (!cp_) {
				if (invalid)
					*invalid = true;
				codepoints.clear();

				break;
			}
			switch (cp_) {
			case GLYPH_ESCAPE_UNICODE: {
					std::wstring wstr;
					wptr = escapeUnicode(wptr, wstr);

					for (wchar_t ecp : wstr) {
						if (std::find(uniqueCodepoints.begin(), uniqueCodepoints.end(), (Font::Codepoint)ecp) == uniqueCodepoints.end())
							uniqueCodepoints.add(ecp);

						codepoints.add(ecp);
					}

					continue;
				}
			case GLYPH_ESCAPE_STACK: // Fall through.
			case GLYPH_ESCAPE_BACKSLASH:
				codepoints.add(cp);
				cp = cp_;

				hasEsc = true;

				break;
			}
		}

		if (std::find(uniqueCodepoints.begin(), uniqueCodepoints.end(), (Font::Codepoint)cp) == uniqueCodepoints.end())
			uniqueCodepoints.add(cp);

		codepoints.add(cp);
	}

	return hasEsc;
}

struct Counter {
	typedef std::shared_ptr<Counter> Ptr;

	int value = 0;
	int max = 0;

	Counter() {
	}
	Counter(int val) : value(val), max(val) {
	}
	Counter(const Counter &other) : value(other.value), max(other.max) {
	}

	Counter &operator = (const Counter &other) {
		value = other.value;
		max = other.max;

		return *this;
	}

	bool operator == (const Counter &other) const {
		return
			value == other.value &&
			max == other.max;
	}
	bool operator != (const Counter &other) const {
		return
			value != other.value ||
			max != other.max;
	}

	Counter operator + (const Counter &other) const {
		return Counter(value + other.value);
	}
	Counter operator + (int other) const {
		return Counter(value + other);
	}
	Counter operator - (const Counter &other) const {
		return Counter(value - other.value);
	}
	Counter operator - (int other) const {
		return Counter(value - other);
	}
	Counter &operator += (const Counter &other) {
		value += other.value;
		if (value > max)
			max = value;

		return *this;
	}
	Counter &operator += (int other) {
		value += other;
		if (value > max)
			max = value;

		return *this;
	}
	Counter &operator -= (const Counter &other) {
		value -= other.value;

		return *this;
	}
	Counter &operator -= (int other) {
		value -= other;

		return *this;
	}

	operator int (void) const {
		return value;
	}
};
static Counter &operator ++ (Counter &val) {
	val += 1;

	return val;
}
static Counter &operator -- (Counter &val) {
	val -= 1;

	return val;
}
static Counter operator ++ (Counter &val, int) {
	const Counter old(val);
	val += 1;

	return old;
}
static Counter operator -- (Counter &val, int) {
	const Counter old(val);
	val -= 1;

	return old;
}

#ifndef COUNTER_GUARD
#	define COUNTER_GUARD(CTX, VAR) Counter GBBASIC_UNIQUE_NAME(__COUNTERGUARD__); Counter &(VAR) = ((CTX).stackFootprint ? *(CTX).stackFootprint : GBBASIC_UNIQUE_NAME(__COUNTERGUARD__))
#endif /* COUNTER_GUARD */
#ifndef CHECK_COUNTER
#	define CHECK_COUNTER(CTX, ON_ERROR) \
		do { \
			if ((CTX).stackFootprint->max > (CTX).stackSize) { \
				THROW_STACK_OVERFLOW(ON_ERROR); \
			} \
		} while (false)
#endif /* CHECK_COUNTER */
#ifndef INC_COUNTER
#	define INC_COUNTER(COUNTER, AMOUNT) do { if ((AMOUNT) > 0) { (COUNTER) += (AMOUNT); } } while (false);
#endif /* INC_COUNTER */
#ifndef DEC_COUNTER
#	define DEC_COUNTER(COUNTER, AMOUNT) do { if ((AMOUNT) > 0) { GBBASIC_ASSERT((COUNTER) - (AMOUNT) >= 0 && "Wrong data."); (COUNTER) -= (AMOUNT); } } while (false);
#endif /* DEC_COUNTER */

TextLocation::TextLocation() {
}

TextLocation::TextLocation(int p) : page(p) {
}

TextLocation::TextLocation(int p, int r, int c) : page(p), row(r), column(c) {
}

bool TextLocation::operator == (const TextLocation &other) const {
	return compare(other) == 0;
}

bool TextLocation::operator != (const TextLocation &other) const {
	return compare(other) != 0;
}

bool TextLocation::operator < (const TextLocation &other) const {
	return compare(other) < 0;
}

bool TextLocation::operator <= (const TextLocation &other) const {
	return compare(other) <= 0;
}

bool TextLocation::operator > (const TextLocation &other) const {
	return compare(other) > 0;
}

bool TextLocation::operator >= (const TextLocation &other) const {
	return compare(other) >= 0;
}

int TextLocation::compare(const TextLocation &other) const {
	if (page < other.page)
		return -1;
	else if (page > other.page)
		return 1;

	if (row < other.row)
		return -1;
	else if (row > other.row)
		return 1;

	if (column < other.column)
		return -1;
	else if (column > other.column)
		return 1;

	return 0;
}

bool TextLocation::invalid(void) const {
	return page == -1 && row == -1 && column == -1;
}

TextLocation TextLocation::INVALID(void) {
	return TextLocation(-1, -1, -1);
}

struct Error {
	typedef std::function<void(const Error &, const std::string &, const TextLocation &)> Handler;

	typedef std::initializer_list<std::string> Arguments;

	std::string message;
	bool isWarning = false;

	Error() {
	}
	Error(const std::string &msg, bool isWarning) :
		message(msg),
		isWarning(isWarning)
	{
	}

	std::string format(void) const {
		return message;
	}
	std::string format(const Arguments &args) const {
		Text::Array args_ = args;
		for (std::string &arg : args_) {
			if (arg == "\n")
				arg = "<EOL>";
		}
		const std::string result = Text::format(message, args_);

		return result;
	}
};

struct SourceLocation {
	int page = 0;
	int sub = 0;
	std::string label;

	SourceLocation() {
	}
	SourceLocation(int p) : page(p) {
	}
	SourceLocation(int p, int s) : page(p), sub(s) {
	}
	SourceLocation(int p, const std::string &l) : page(p), label(l) {
	}

	bool operator < (const SourceLocation &other) const {
		return compare(other) < 0;
	}

	int compare(const SourceLocation &other) const {
		if (page < other.page)
			return -1;
		else if (page > other.page)
			return 1;

		if (sub < other.sub)
			return -1;
		else if (sub > other.sub)
			return 1;

		if (label < other.label)
			return -1;
		else if (label > other.label)
			return 1;

		return 0;
	}

	std::string toString(void) const {
		std::string result;
		if (page >= 0)
			result += "#" + Text::toString(page);

		if (label.empty()) {
			if (sub >= 0) {
				if (!result.empty())
					result += ":";
				result += Text::toString(sub);
			}
		} else {
			if (!result.empty())
				result += ":";
			result += label;
		}

		return result;
	}
};

struct RomLocation {
	int bank = 0;
	int address = 0;
	int size = 0;

	RomLocation() {
	}
	RomLocation(int b, int a) : bank(b), address(a) {
	}
	RomLocation(int b, int a, int s) : bank(b), address(a), size(s) {
	}
};

RamLocation::RamLocation() {
}

RamLocation::RamLocation(Types y, int a, int s, Usages u, const TextLocation &txtLoc) :
	type(y), address(a), size(s),
	usage(u), textLocation(txtLoc)
{
}

Macro::Macro() {
	scopeLocationRange.first = TextLocation::INVALID();
	scopeLocationRange.second = TextLocation::INVALID();
}

Macro::Macro(const std::string &name_, Types y, const Variant &d) :
	name(name_),
	type(y),
	data(d)
{
	scopeLocationRange.first = TextLocation::INVALID();
	scopeLocationRange.second = TextLocation::INVALID();
}

Macro::Macro(const std::string &name_, Types y, const Variant &d, const TextLocation &begin) :
	name(name_),
	type(y),
	data(d)
{
	scopeLocationRange.first = begin;
	scopeLocationRange.second = TextLocation::INVALID();
}

bool Macro::operator == (const Macro &other) const {
	return compare(other) == 0;
}

bool Macro::operator != (const Macro &other) const {
	return compare(other) != 0;
}

bool Macro::operator < (const Macro &other) const {
	return compare(other) < 0;
}

bool Macro::operator <= (const Macro &other) const {
	return compare(other) <= 0;
}

bool Macro::operator > (const Macro &other) const {
	return compare(other) > 0;
}

bool Macro::operator >= (const Macro &other) const {
	return compare(other) >= 0;
}

int Macro::compare(const Macro &other) const {
	if (name < other.name)
		return -1;
	else if (name > other.name)
		return 1;

	if (type < other.type)
		return -1;
	else if (type > other.type)
		return 1;

	const int cd = data.compare(other.data);
	if (cd != 0)
		return cd;

	if (scopeLocationRange < other.scopeLocationRange)
		return -1;
	else if (scopeLocationRange > other.scopeLocationRange)
		return 1;

	return 0;
}

struct SymbolTable {
private:
	typedef std::map<std::string, RomLocation> Dictionary;

private:
	Dictionary _dictionary;

public:
	SymbolTable() {
	}

	bool parseSymbols(const std::string &symbols) {
		// Prepare.
		std::string symbols_ = symbols;

		// Uniform new line characters to '\n'.
		symbols_ = Text::replace(symbols_, "\r\n", "\n");
		symbols_ = Text::replace(symbols_, "\r", "\n");

		// Split the symbol data into lines.
		Text::Array lines;
		const Text::Array lines_ = Text::split(symbols_, "\n");
		for (std::string ln : lines_) {
			const size_t idx = Text::indexOf(ln, ";");
			if (idx != std::string::npos)
				ln = ln.substr(0, idx);

			ln = Text::trim(ln);

			if (ln.empty())
				continue;

			lines.push_back(ln);
		}

		// Parse the symbol lines.
		for (const std::string &ln : lines) {
			const Text::Array parts = Text::split(ln, " ");
			if (parts.size() != 2)
				continue;

			const std::string &address_ = parts.front();
			std::string name = parts.back();
			const Text::Array addressParts = Text::split(address_, ":");
			if (addressParts.size() != 2)
				continue;

			const std::string &bank = addressParts.front();
			const std::string &address = addressParts.back();

			if (Text::startsWith(name, "_", true))
				name = name.substr(1 /* after "_" */);
			const int nbank = std::stoi(bank, 0, 16);
			const int naddress = std::stoi(address, 0, 16);
			const RomLocation romLocation(nbank, naddress);
			_dictionary.insert(std::make_pair(name, romLocation));
		}

		// Finish.
		return true;
	}
	bool parseAliases(const std::string &aliases) {
		rapidjson::Document doc;
		if (!Json::fromString(doc, aliases.c_str()))
			return false;
		if (!doc.IsObject())
			return false;

		for (rapidjson::Value::ConstMemberIterator it = doc.MemberBegin(); it != doc.MemberEnd(); ++it) {
			const rapidjson::Value &jkey = it->name;
			const rapidjson::Value &jval = it->value;

			const std::string name = jkey.GetString();
			if (!jval.IsObject()) {
				fprintf(stderr, "Object expected for the alias of the \"%s\" symbol.\n", name.c_str());

				continue;
			}

			std::string ref;
			int offset = 0;
			if (!Jpath::get(jval, ref, "ref")) {
				fprintf(stderr, "Cannot read the \"ref\" field of the alias of the \"%s\" symbol.\n", name.c_str());

				continue;
			}
			if (!Jpath::get(jval, offset, "offset")) {
				fprintf(stderr, "Cannot read the \"offset\" field of the alias of the \"%s\" symbol.\n", name.c_str());

				continue;
			}

			const RomLocation* refLocation = find(ref);
			if (!refLocation) {
				fprintf(stderr, "Cannot find the \"%s\" ref alias of the \"%s\" symbol.\n", ref.c_str(), name.c_str());

				continue;
			}

			const int nbank = refLocation->bank;
			const int naddress = refLocation->address + offset;
			const RomLocation romLocation(nbank, naddress);
			_dictionary.insert(std::make_pair(name, romLocation));
		}

		return true;
	}
	const RomLocation* find(const std::string &key) const {
		Dictionary::const_iterator it = _dictionary.find(key);
		if (it == _dictionary.end())
			return nullptr;

		return &it->second;
	}
	const RomLocation* fuzzy(const std::string &key, std::string &gotKey) const {
		gotKey.clear();

		if (_dictionary.empty())
			return nullptr;

		double fuzzyScore = 0.0;
		Dictionary::const_iterator fuzzyIt = _dictionary.end();
		for (Dictionary::const_iterator it = _dictionary.begin(); it != _dictionary.end(); ++it) {
			const std::string &name = it->first;
			if (name == key) {
				gotKey = name;

				return &it->second;
			}

			if (name.empty())
				continue;

			const double score = rapidfuzz::fuzz::ratio(name, key);
			if (score < FUZZY_MATCHING_SCORE_THRESHOLD)
				continue;
			if (score > fuzzyScore) {
				fuzzyScore = score;
				fuzzyIt = it;
			}
		}

		if (fuzzyIt != _dictionary.end()) {
			gotKey = fuzzyIt->first;

			return &fuzzyIt->second;
		}

		return nullptr;
	}
};

struct Asm {
	enum class Types : Byte {
		/**< Basic instructions. */

		// Halt and nop.
		HALT,
		NOP,

		// Stack manipulation.
		RESERVE,
		PUSH,
		PUSH_VALUE,
		POP,
		POP_1,

		// Invoking.
		CALL, // Unused by compiler.
		RET, // Unused by compiler.
		CALL_FAR,
		RET_FAR,

		// Jump, conditional and loop.
		JUMP,
		JUMP_FAR,
		NEXT_BANK,
		SWITCH,
		IF, // Unused by compiler.
		IF_CONST,
		IIF,
		LOOP,
		FOR,

		// Data and value.
		SET,
		SET_CONST,
		SET_INDIRECT,
		GET_INDIRECT,
		ACC,
		ACC_CONST,
		RPN,
		GET_TLOCAL,
		SET_TLOCAL,
		PACK,
		UNPACK,
		SWAP,
		READ,
		RESTORE,

		// Thread manipulation.
		BEGIN_THREAD,
		JOIN,
		TERMINATE,
		WAIT,
		WAIT_N,
		LOCK,
		UNLOCK,

		// Functions.
		INVOKE_FN,
		LOCATE,
		PRINT,
		SRAND,
		RAND,
		PEEK,
		POKE,
		FILL,

		/**< Memory instructions. */

		// Memory.
		MEMCPY,
		MEMSET,
		MEMADD,

		/**< System instructions. */

		// System.
		SYS_TIME,
		SLEEP,
		RAISE,
		RESET,
		DBGINFO,

		/**< Graphics instructions. */

		// Primitives.
		COLOR,
		PALETTE,
		RGB,
		PLOT,
		POINT,
		LINE,
		RECT,
		GOTOXY,
		TEXT,

		// Image manipulation.
		IMAGE,

		// Tile manipulation.
		FILL_TILE,

		// Map manipulation.
		DEF_MAP,
		MAP,
		MGET,
		MSET,

		// Window manipulation.
		DEF_WINDOW,
		WINDOW,
		WGET,
		WSET,

		// Sprite manipulation.
		DEF_SPRITE,
		SPRITE,
		SGET,
		SSET,
		GET_SPRITE_PROP,
		SET_SPRITE_PROP,

		/**< Audio instructions. */

		// Music.
		PLAY,
		STOP,

		// SFX.
		SOUND,

		/**< Input instructions. */

		// Gamepad.
		BTN,
		BTND,
		BTNU,

		// Touch.
		TOUCH, // FEAT: GBB EXTENSION.
		TOUCHD, // FEAT: GBB EXTENSION.
		TOUCHU, // FEAT: GBB EXTENSION.

		// Callback.
		ON_INPUT,

		/**< Persistence instructions. */

		// File.
		FOPEN,
		FCLOSE,
		FREAD,
		FWRITE,

		/**< Serial port instructions. */

		// Serial port.
		SREAD,
		SWRITE,

		/**< Scene instructions. */

		// Camera and viewport.
		CAMERA,
		VIEWPORT,

		// Scene initialization.
		DEF_SCENE,
		LOAD_SCENE,

		// Scene property.
		GET_SCENE_PROP,
		SET_SCENE_PROP,

		/**< Actor instructions. */

		// Actor constructor/destructor.
		NEW_ACTOR,
		DEL_ACTOR,

		// Actor initialization.
		DEF_ACTOR,

		// Actor property.
		GET_ACTOR_PROP,
		SET_ACTOR_PROP,

		// Actor animation.
		PLAY_ACTOR,

		// Actor threading.
		THREAD_ACTOR,

		// Actor motion.
		MOVE_ACTOR,

		// Actor lookup.
		FIND_ACTOR,

		// Actor callback.
		ON_ACTOR,

		/**< Emote instructions. */

		// Emote.
		EMOTE,

		/**< Projectile instructions. */

		// Projectile initialization.
		DEF_PROJECTILE,
		START_PROJECTILE,

		// Projectile property.
		GET_PROJECTILE_PROP,
		SET_PROJECTILE_PROP,

		/**< Trigger instructions. */

		// Trigger initialization.
		DEF_TRIGGER,

		// Trigger callback.
		ON_TRIGGER,

		/**< Object instructions. */

		// Object typing.
		OBJECT_IS,

		/**< GUI instructions. */

		// GUI widget initialization.
		DEF_WIDGET,

		// Widgets.
		LABEL,
		PROGRESSBAR,
		MENU,

		// GUI callback.
		ON_WIDGET,

		/**< Scroll instructions. */

		// Scroll.
		SCROLL,

		/**< Effects instructions. */

		// Effects.
		FX,

		/**< Physics instructions. */

		// Collision detection.
		HITS,

		/**< Game instructions. */

		// Game loop.
		UPDATE,

		/**< Hardware features instructions. */

		// Feature switch and query.
		OPTION,
		QUERY,

		// Streaming.
		STREAM, // FEAT: GBB EXTENSION.

		// Shell.
		SHELL, // FEAT: GBB EXTENSION.

		/**< The following 32 instruction slots are reserved. */

		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		ENUM,
		NONE,

		COUNT
	};
	typedef std::array<Asm, (size_t)Types::COUNT> Instructions;

	static const Instructions INSTRUCTIONS;

	Byte opcode = 0x00;
	int size = 0; // Size of the parameter list in bytes.

	Asm(Byte oc, int s) : opcode(oc), size(s) {
	}
	Asm(Types oc, int s) : Asm((Byte)oc, s) {
	}

	int totalSize(void) const {
		return 1 /* instruction size */ + size /* parameters size */;
	}
};
const Asm::Instructions Asm::INSTRUCTIONS = array(
	/**< Basic instructions. */

	// Halt and nop.
	Asm(Asm::Types::HALT,                  0),
	Asm(Asm::Types::NOP,                   0),

	// Stack manipulation.
	Asm(Asm::Types::RESERVE,               1),
	Asm(Asm::Types::PUSH,                  2),
	Asm(Asm::Types::PUSH_VALUE,            2),
	Asm(Asm::Types::POP,                   1),
	Asm(Asm::Types::POP_1,                 1),

	// Invoking.
	Asm(Asm::Types::CALL,                  2), // Unused by compiler.
	Asm(Asm::Types::RET,                   1), // Unused by compiler.
	Asm(Asm::Types::CALL_FAR,              3),
	Asm(Asm::Types::RET_FAR,               1),

	// Jump, conditional and loop.
	Asm(Asm::Types::JUMP,                  2),
	Asm(Asm::Types::JUMP_FAR,              3),
	Asm(Asm::Types::NEXT_BANK,             0),
	Asm(Asm::Types::SWITCH,                5),
	Asm(Asm::Types::IF,                    8), // Unused by compiler.
	Asm(Asm::Types::IF_CONST,              8),
	Asm(Asm::Types::IIF,                   8),
	Asm(Asm::Types::LOOP,                  9),
	Asm(Asm::Types::FOR,                   9),

	// Data and value.
	Asm(Asm::Types::SET,                   4),
	Asm(Asm::Types::SET_CONST,             4),
	Asm(Asm::Types::SET_INDIRECT,          4),
	Asm(Asm::Types::GET_INDIRECT,          4),
	Asm(Asm::Types::ACC,                   5),
	Asm(Asm::Types::ACC_CONST,             4),
	Asm(Asm::Types::RPN,                   0),
	Asm(Asm::Types::GET_TLOCAL,            4),
	Asm(Asm::Types::SET_TLOCAL,            4),
	Asm(Asm::Types::PACK,                 11),
	Asm(Asm::Types::UNPACK,               11),
	Asm(Asm::Types::SWAP,                  4),
	Asm(Asm::Types::READ,                  5),
	Asm(Asm::Types::RESTORE,               3),

	// Thread manipulation.
	Asm(Asm::Types::BEGIN_THREAD,          7),
	Asm(Asm::Types::JOIN,                  2),
	Asm(Asm::Types::TERMINATE,             3),
	Asm(Asm::Types::WAIT,                  0),
	Asm(Asm::Types::WAIT_N,                2),
	Asm(Asm::Types::LOCK,                  0),
	Asm(Asm::Types::UNLOCK,                0),

	// Functions.
	Asm(Asm::Types::INVOKE_FN,             6),
	Asm(Asm::Types::LOCATE,                4),
	Asm(Asm::Types::PRINT,                 2),
	Asm(Asm::Types::SRAND,                 2),
	Asm(Asm::Types::RAND,                  6),
	Asm(Asm::Types::PEEK,                  5),
	Asm(Asm::Types::POKE,                  5),
	Asm(Asm::Types::FILL,                  6),

	/**< Memory instructions. */

	// Memory.
	Asm(Asm::Types::MEMCPY,                1),
	Asm(Asm::Types::MEMSET,                0),
	Asm(Asm::Types::MEMADD,                0),

	/**< System instructions. */

	// System.
	Asm(Asm::Types::SYS_TIME,              2),
	Asm(Asm::Types::SLEEP,                 2),
	Asm(Asm::Types::RAISE,                 2),
	Asm(Asm::Types::RESET,                 0),
	Asm(Asm::Types::DBGINFO,               0),

	/**< Graphics instructions. */

	// Primitives.
	Asm(Asm::Types::COLOR,                 0),
	Asm(Asm::Types::PALETTE,               1),
	Asm(Asm::Types::RGB,                   0),
	Asm(Asm::Types::PLOT,                  0),
	Asm(Asm::Types::POINT,                 0),
	Asm(Asm::Types::LINE,                  0),
	Asm(Asm::Types::RECT,                  1),
	Asm(Asm::Types::GOTOXY,                0),
	Asm(Asm::Types::TEXT,                  2),

	// Image manipulation.
	Asm(Asm::Types::IMAGE,                 1),

	// Tile manipulation.
	Asm(Asm::Types::FILL_TILE,             2),

	// Map manipulation.
	Asm(Asm::Types::DEF_MAP,               1),
	Asm(Asm::Types::MAP,                   0),
	Asm(Asm::Types::MGET,                  0),
	Asm(Asm::Types::MSET,                  0),

	// Window manipulation.
	Asm(Asm::Types::DEF_WINDOW,            1),
	Asm(Asm::Types::WINDOW,                0),
	Asm(Asm::Types::WGET,                  0),
	Asm(Asm::Types::WSET,                  0),

	// Sprite manipulation.
	Asm(Asm::Types::DEF_SPRITE,            1),
	Asm(Asm::Types::SPRITE,                0),
	Asm(Asm::Types::SGET,                  0),
	Asm(Asm::Types::SSET,                  0),
	Asm(Asm::Types::GET_SPRITE_PROP,       0),
	Asm(Asm::Types::SET_SPRITE_PROP,       0),

	/**< Audio instructions. */

	// Music.
	Asm(Asm::Types::PLAY,                  3),
	Asm(Asm::Types::STOP,                  0),

	// SFX.
	Asm(Asm::Types::SOUND,                 5),

	/**< Input instructions. */

	// Gamepad.
	Asm(Asm::Types::BTN,                   0),
	Asm(Asm::Types::BTND,                  0),
	Asm(Asm::Types::BTNU,                  0),

	// Touch.
	Asm(Asm::Types::TOUCH,                 5),
	Asm(Asm::Types::TOUCHD,                5),
	Asm(Asm::Types::TOUCHU,                5),

	// Callback.
	Asm(Asm::Types::ON_INPUT,              4),

	/**< Persistence instructions. */

	// File.
	Asm(Asm::Types::FOPEN,                 0),
	Asm(Asm::Types::FCLOSE,                0),
	Asm(Asm::Types::FREAD,                 0),
	Asm(Asm::Types::FWRITE,                0),

	/**< Serial port instructions. */

	// Serial port.
	Asm(Asm::Types::SREAD,                 0),
	Asm(Asm::Types::SWRITE,                0),

	/**< Scene instructions. */

	// Camera and viewport.
	Asm(Asm::Types::CAMERA,                0),
	Asm(Asm::Types::VIEWPORT,              4),

	// Scene initialization.
	Asm(Asm::Types::DEF_SCENE,             1),
	Asm(Asm::Types::LOAD_SCENE,            0),

	// Scene property.
	Asm(Asm::Types::GET_SCENE_PROP,        0),
	Asm(Asm::Types::SET_SCENE_PROP,        0),

	/**< Actor instructions. */

	// Actor constructor/destructor.
	Asm(Asm::Types::NEW_ACTOR,             0),
	Asm(Asm::Types::DEL_ACTOR,             0),

	// Actor initialization.
	Asm(Asm::Types::DEF_ACTOR,             1),

	// Actor property.
	Asm(Asm::Types::GET_ACTOR_PROP,        0),
	Asm(Asm::Types::SET_ACTOR_PROP,        1),

	// Actor animation.
	Asm(Asm::Types::PLAY_ACTOR,            0),

	// Actor threading.
	Asm(Asm::Types::THREAD_ACTOR,          1),

	// Actor motion.
	Asm(Asm::Types::MOVE_ACTOR,            1),

	// Actor lookup.
	Asm(Asm::Types::FIND_ACTOR,            1),

	// Actor callback.
	Asm(Asm::Types::ON_ACTOR,              4),

	/**< Emote instructions. */

	// Emote.
	Asm(Asm::Types::EMOTE,                 1),

	/**< Projectile instructions. */

	// Projectile initialization.
	Asm(Asm::Types::DEF_PROJECTILE,        1),
	Asm(Asm::Types::START_PROJECTILE,      1),

	// Projectile property.
	Asm(Asm::Types::GET_PROJECTILE_PROP,   0),
	Asm(Asm::Types::SET_PROJECTILE_PROP,   1),

	/**< Trigger instructions. */

	// Trigger initialization.
	Asm(Asm::Types::DEF_TRIGGER,           1),

	// Trigger callback.
	Asm(Asm::Types::ON_TRIGGER,            3),

	/**< Object instructions. */

	// Object typing.
	Asm(Asm::Types::OBJECT_IS,             1),

	/**< GUI instructions. */

	// GUI widget initialization.
	Asm(Asm::Types::DEF_WIDGET,            1),

	// Widgets.
	Asm(Asm::Types::LABEL,                 5),
	Asm(Asm::Types::PROGRESSBAR,           1),
	Asm(Asm::Types::MENU,                  5),

	// GUI callback.
	Asm(Asm::Types::ON_WIDGET,             3),

	/**< Scroll instructions. */

	// Scroll.
	Asm(Asm::Types::SCROLL,                0),

	/**< Effects instructions. */

	// Effects.
	Asm(Asm::Types::FX,                    0),

	/**< Physics instructions. */

	// Collision detection.
	Asm(Asm::Types::HITS,                  1),

	/**< Game instructions. */

	// Game loop.
	Asm(Asm::Types::UPDATE,                0),

	/**< Hardware features instructions. */

	// Feature switch and query.
	Asm(Asm::Types::OPTION,                0),
	Asm(Asm::Types::QUERY,                 0),

	// Streaming.
	Asm(Asm::Types::STREAM,                1),

	// Shell.
	Asm(Asm::Types::SHELL,                 1),

	/**< The following 32 instruction slots are reserved. */

	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0),
	Asm(0xff,                              0)   // `Asm::Types::NONE`.
);

struct Op {
	enum class Types : Byte {
		STOP,
		INT8,
		INT16,
		REF,
		ADD,
		SUB,
		MUL,
		DIV,
		MOD,
		EQ,
		LT,
		LE,
		GT,
		GE,
		NE,
		AND,
		OR,
		NOT,
		BITWISE_AND,
		BITWISE_OR,
		BITWISE_XOR,
		BITWISE_NOT,
		BITWISE_LSHIFT,
		BITWISE_RSHIFT,
		NEG,
		SGN,
		ABS,
		SQR,
		SQRT,
		SIN,
		COS,
		ATAN2,
		POWI,
		MIN,
		MAX,

		COUNT
	};
	typedef std::array<Op, (size_t)Types::COUNT> Operators;

	static Operators OPERATORS;

	Int8 opcode = 0x00;
	int size = 0;          // Size of the parameter list in bytes.
	int associativity = 0; // -1 for left, 1 for right.
	int precedence = 0;    // The greater, the higher.

	Op(Int8 oc, int s, int a, int p) : opcode(oc), size(s), associativity(a), precedence(p) {
	}
};
Op::Operators Op::OPERATORS = array(
	Op( 0,    0,    0,    0), // STOP.
	Op(-1,    1,    0,    0), // INT8.
	Op(-2,    2,    0,    0), // INT16.
	Op(-3,    2,    0,    0), // REF.
	Op('+',   0,   -1,    5), // ADD.
	Op('-',   0,   -1,    5), // SUB.
	Op('*',   0,   -1,    6), // MUL.
	Op('/',   0,   -1,    6), // DIV.
	Op('%',   0,   -1,    6), // MOD.
	Op( 1,    0,   -1,    4), // EQ.
	Op( 2,    0,   -1,    4), // LT.
	Op( 3,    0,   -1,    4), // LE.
	Op( 4,    0,   -1,    4), // GT.
	Op( 5,    0,   -1,    4), // GE.
	Op( 6,    0,   -1,    4), // NE.
	Op( 7,    0,   -1,    3), // AND.
	Op( 8,    0,   -1,    3), // OR.
	Op( 9,    0,   -1,    8), // NOT.
	Op('&',   0,   -1,    7), // BITWISE_AND.
	Op('|',   0,   -1,    7), // BITWISE_OR.
	Op('^',   0,   -1,    7), // BITWISE_XOR.
	Op('~',   0,   -1,    7), // BITWISE_NOT.
	Op('<',   0,   -1,    7), // BITWISE_LSHIFT.
	Op('>',   0,   -1,    7), // BITWISE_RSHIFT.
	Op('_',   0,   -1,    8), // NEG.
	Op('s',   0,   -1,    1), // SGN.
	Op('@',   0,   -1,    1), // ABS.
	Op('q',   0,   -1,    1), // SQR.
	Op('Q',   0,   -1,    1), // SQRT.
	Op('S',   0,   -1,    1), // SIN.
	Op('C',   0,   -1,    1), // COS.
	Op('T',   0,   -1,    1), // ATAN2.
	Op('P',   0,   -1,    1), // POWI.
	Op('m',   0,   -1,    2), // MIN.
	Op('M',   0,   -1,    2)  // MAX.
);

enum class EventTypes {
	NONE              =  0,
	CONDITIONAL       =  1 << 0,
	BUTTON_INPUT      = (1 << 1) | (1 << 2) | (1 << 3),
		BUTTON        =  1 << 1,
		BUTTON_DOWN   =  1 << 2,
		BUTTON_UP     =  1 << 3,
	TOUCH_INPUT       = (1 << 4) | (1 << 5) | (1 << 6),
		TOUCH         =  1 << 4,
		TOUCH_DOWN    =  1 << 5,
		TOUCH_UP      =  1 << 6,
	HITS              =  1 << 7,
	MOVE              =  1 << 8
};

enum class EventTargets {
	GOTO,
	GOSUB,
	START
};

enum class ResourceManipulations : unsigned {
	// None.
	NONE,
	// Define dimension.
	DIM,
	// Filling, defining and loading.
	FILL,
	DEF,
	LOAD,
	// Constructing and deconstructing.
	NEW,
	DEL,
	// Getting and setting.
	GET,
	SET,
	LEN,
	GET_WIDTH,
	GET_HEIGHT,
	// Controlling.
	FIND,
	PUT,
	STOP,
	CONTROL,
	// Playing.
	PLAY,
	// Threading.
	START,
	JOIN,
	KILL,
	WAIT,
	// Toggling.
	ON,
	OFF
};
static bool expectAssign(ResourceManipulations y) {
	return
		y == ResourceManipulations::FILL ||
		y == ResourceManipulations::DEF  ||
		y == ResourceManipulations::LOAD ||
		y == ResourceManipulations::SET;
}
static bool expectAssign(const std::string &y) {
	return
		y == "fill" ||
		y == "def"  ||
		y == "load" ||
		y == "set";
}
static bool expectBrackets(ResourceManipulations y) {
	switch (y) {
	case ResourceManipulations::FILL:       // Fall through.
	case ResourceManipulations::DEF:        // Fall through.
	case ResourceManipulations::LOAD:       // Fall through.
	case ResourceManipulations::GET:        // Fall through.
	case ResourceManipulations::SET:        // Fall through.
	case ResourceManipulations::LEN:        // Fall through.
	case ResourceManipulations::GET_WIDTH:  // Fall through.
	case ResourceManipulations::GET_HEIGHT:
		return true;
	default:
		return false;
	}
}

enum class SerialManipulations : unsigned {
	NONE,
	ASYNC,
	SYNC
};

struct DefaultTable {
public:
	struct Entry {
		typedef std::vector<int> Defaults;
		typedef std::initializer_list<int> Values;

		int parameters = 0;
		Defaults defaults;

		static constexpr const int PLACEHOLDER = -1;

		Entry() {
		}
		Entry(int params, const Values &defaults_) : parameters(params) {
			for (int d : defaults_)
				defaults.push_back(d);
		}
	};

private:
	typedef std::vector<Entry> Array;

private:
	Array _array;

public:
	DefaultTable() {
	}

	void add(int params, const Entry::Values &defaults_) {
		_array.push_back(Entry(params, defaults_));
	}
	const Entry* find(int params) const {
		for (const Entry &entry : _array) {
			if (entry.parameters == params)
				return &entry;
		}

		return nullptr;
	}
};

struct BuiltinTable {
public:
	struct Entry {
		enum class Types {
			NONE,
			INSTRUCTION,
			VALUE,
			USER_DEFINED
		};

		Types type = Types::NONE;
		union {
			Asm::Types instruction = Asm::Types::NOP;
			int value;
		};

		Entry() {
		}
		Entry(Asm::Types y) : type(Types::INSTRUCTION), instruction(y) {
		}
		Entry(int val) : type(Types::VALUE), value(val) {
		}

		static Entry define(int val) {
			Entry result;
			result.type = Types::USER_DEFINED;
			result.value = val;

			return result;
		}
	};

	typedef std::function<void(const std::string &, const Entry &)> Enumerator;
	typedef std::function<bool(const std::string &, const Entry &)> Filter;

private:
	typedef std::map<std::string, Entry> Dictionary;

private:
	Dictionary _dictionary;

public:
	BuiltinTable() {
	}

	bool add(const std::string &key, const Entry &entry, bool caseInsensitive) {
		// Add the key literally.
		const std::pair<Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, entry));
		GBBASIC_ASSERT(ret.second && "Failed to add builtin.");

		// Add a duplicate key in lower case for case-insensitive parsing.
		if (caseInsensitive) {
			std::string lkey = key;
			Text::toLowerCase(lkey);
			if (lkey != key) {
				const std::pair<Dictionary::iterator, bool> lret = _dictionary.insert(std::make_pair(lkey, entry));
				(void)lret;
				GBBASIC_ASSERT(lret.second && "Failed to add builtin.");
			}
		}

		// Finish.
		return ret.second;
	}
	const Entry* find(const std::string &key) const {
		Dictionary::const_iterator it = _dictionary.find(key);
		if (it == _dictionary.end())
			return nullptr;

		return &it->second;
	}
	void foreach(Enumerator enumerator) const {
		for (Dictionary::const_iterator it = _dictionary.begin(); it != _dictionary.end(); ++it)
			enumerator(it->first, it->second);
	}
	void filter(Filter filter_) {
		for (Dictionary::iterator it = _dictionary.begin(); it != _dictionary.end(); ) {
			if (!filter_(it->first, it->second))
				it = _dictionary.erase(it);
			else
				++it;
		}
	}
};

struct FunctionTable {
public:
	struct Entry {
		Asm::Types type = Asm::Types::NOP;
		int parameters = 0;
		int returns = 0;

		Entry() {
		}
		Entry(std::nullptr_t) {
		}
		Entry(Asm::Types y, int params, int ret) : type(y), parameters(params), returns(ret) {
		}
	};

	typedef std::function<void(const std::string &, const Entry &)> Enumerator;

private:
	typedef std::map<std::string, Entry> Dictionary;

private:
	Dictionary _dictionary;

public:
	FunctionTable() {
	}

	bool add(const std::string &key, const Entry &entry) {
		const std::pair<Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, entry));
		GBBASIC_ASSERT(ret.second && "Failed to add function.");

		return ret.second;
	}
	void foreach(Enumerator enumerator) const {
		for (Dictionary::const_iterator it = _dictionary.begin(); it != _dictionary.end(); ++it)
			enumerator(it->first, it->second);
	}
	const Entry* find(const std::string &key) const {
		Dictionary::const_iterator it = _dictionary.find(key);
		if (it == _dictionary.end())
			return nullptr;

		return &it->second;
	}
};

struct OperatorTable {
public:
	struct Entry {
		Op::Types type = Op::Types::STOP;
		int parameters = 0;
		bool isFunctionLike = false;

		Entry() {
		}
		Entry(Op::Types y, int params, bool funcLike) : type(y), parameters(params), isFunctionLike(funcLike) {
		}
	};

	typedef std::function<void(const std::string &, const Entry &)> Enumerator;

private:
	typedef std::map<std::string, Entry> Dictionary;

private:
	Dictionary _dictionary;

public:
	OperatorTable() {
	}

	bool add(const std::string &key, const Entry &entry) {
		const std::pair<Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, entry));
		GBBASIC_ASSERT(ret.second && "Failed to add operator.");

		return ret.second;
	}
	void foreach(Enumerator enumerator) const {
		for (Dictionary::const_iterator it = _dictionary.begin(); it != _dictionary.end(); ++it)
			enumerator(it->first, it->second);
	}
	const Entry* find(const std::string &key) const {
		Dictionary::const_iterator it = _dictionary.find(key);
		if (it == _dictionary.end())
			return nullptr;

		return &it->second;
	}
};

struct IdentifierTable {
public:
	struct Entry {
		enum class Types {
			NONE,
			CONST,
			LET,
			LOCAL,
			DIM
		};

		Types type = Types::NONE;

		Entry() {
		}
		Entry(Types y) : type(y) {
		}
	};

	typedef std::function<void(const std::string &, const Entry &)> Enumerator;

private:
	typedef std::map<std::string, Entry> Dictionary;

private:
	Dictionary _dictionary;

public:
	IdentifierTable() {
	}

	bool add(const std::string &key, const Entry &entry) {
		const std::pair<Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, entry));
		GBBASIC_ASSERT(ret.second && "Failed to add identifier.");

		return ret.second;
	}
	const Entry* find(const std::string &key) const {
		Dictionary::const_iterator it = _dictionary.find(key);
		if (it == _dictionary.end())
			return nullptr;

		return &it->second;
	}
};

}

/* ===========================================================================} */

/*
** {===========================================================================
** Token
*/

namespace GBBASIC {

class Token {
public:
	typedef std::shared_ptr<Token> Ptr;
	typedef std::vector<Ptr> Array;
	typedef std::vector<Array> Matrix;

	enum class Types : unsigned {
		NONE             =  0,
		PAGE             =  1 << 0,
		SPACE            =  1 << 1,
		END_OF_LINE      =  1 << 2,
		LINE_CONNECTOR   =  1 << 3,
		OPERATOR         =  1 << 4,
		SYMBOL           = (1 << 5) | (1 << 6),
			KEYWORD      =  1 << 5,
			IDENTIFIER   =  1 << 6,
		LABEL            =  1 << 7,
		NOTHING          =  1 << 8,
		BOOLEAN          =  1 << 9,
		NUMBER           = (1 << 10) | (1 << 11),
			INTEGER      =  1 << 10,
			REAL         =  1 << 11,
		STRING           =  1 << 12,
		COMMENT          =  1 << 13,
		INTERMEDIA       = (1 << 14) | (1 << 15) | (1 << 16) | (1 << 17),
			MATH         =  1 << 14,
			STATEMENT    =  1 << 15,
			ARRAY        =  1 << 16,
			MACRO        =  1 << 17,
		ANY              =  0xffffffff
	};

	enum class IntegerTypes {
		UNSPECIFIED,   // 8-bit signed integer or 8-bit unsigned integer.
		INT            // 16-bit signed integer.
	};

private:
	Types _type = Types::NONE;
	Variant _data = nullptr;
	std::string _caseSensitiveText;
	std::string _text;
	TextLocation _begin;
	TextLocation _end;
	struct Details {
		IntegerTypes integerType = IntegerTypes::UNSPECIFIED;
	} _details;

public:
	Token() {
	}
	Token(const Token &other) {
		_type = other._type;
		_data = other._data;
		_text = other._text;
		_begin = other._begin;
		_end = other._end;
		_details = other._details;
	}
	~Token() {
	}

	Token &operator = (const Token &other) {
		_type = other._type;
		_data = other._data;
		_text = other._text;
		_begin = other._begin;
		_end = other._end;
		_details = other._details;

		return *this;
	}

	Types type(void) const {
		return _type;
	}
	Token* type(Types y) {
		_type = y;

		return this;
	}
	const Variant &data(void) const {
		return _data;
	}
	Token* data(const Variant &data_) {
		_data = data_;

		return this;
	}
	const std::string &text(void) const {
		return _text;
	}
	Token* text(const std::string &txt) {
		_text = txt;

		return this;
	}
	const std::string &caseSensitiveText(void) const {
		return _caseSensitiveText;
	}

	const TextLocation &begin(void) const {
		return _begin;
	}
	TextLocation &begin(void) {
		return _begin;
	}
	Token* begin(const TextLocation &loc) {
		_begin = loc;

		return this;
	}
	const TextLocation &end(void) const {
		return _end;
	}
	TextLocation &end(void) {
		return _end;
	}
	Token* end(const TextLocation &loc) {
		_end = loc;

		return this;
	}

	const Details &details(void) const {
		return _details;
	}
	Details &details(void) {
		return _details;
	}

	Token* add(const std::string &str) {
		_text += str;

		return this;
	}
	char back(void) const {
		if (_text.empty())
			return '\0';

		return _text.back();
	}
	Token* parse(bool caseInsensitive) {
		switch (_type) {
		case Types::SPACE:
			// Ignore spaces.
			_caseSensitiveText = " ";

			break;
		case Types::NUMBER: {
				_caseSensitiveText = _text;
				int val = 0;
				if (Text::fromString(_text, val))
					_data = val;
				_type = Types::INTEGER;
			}

			break;
		case Types::STRING:
			_caseSensitiveText = _text;
			if (Text::indexOf(_text, '"') == 0)
				_data = _text.substr(1, _text.length() - 2);

			break;
		case Types::SYMBOL:
			_caseSensitiveText = _text;
			if (caseInsensitive)
				Text::toLowerCase(_text);
			_data = _text;

			break;
		default:
			_caseSensitiveText = _text;
			_data = _text;

			break;
		}

		return this;
	}

	bool is(Types y) const {
		return (_type & y) != Types::NONE;
	}
	bool isNot(Types y) const {
		return (_type & y) == Types::NONE;
	}

	std::string dump(void) const {
		typedef std::function<std::string(const Variant &)> StringGetter;

		auto dumpString = [] (const Variant &data, StringGetter getString, const char* forBlank, const char* quote, bool escapeNewlines, bool escapeQuotes, bool escapePercent) -> std::string {
			std::string result;

			GBBASIC_ASSERT(data.type() == Variant::STRING);

			std::string txt = getString != nullptr ? getString(data) : (std::string)data;
			if (txt.empty() && forBlank) {
				result = forBlank;
			} else {
				if (escapeNewlines) {
					txt = Text::replace(txt, "\r", "\\r");
					txt = Text::replace(txt, "\n", "\\n");
				}
				if (escapeQuotes) {
					txt = Text::replace(txt, "\"", "\\\"");
				}
				if (escapePercent) {
					txt = Text::replace(txt, "%", "%%");
				}
				if (quote) {
					result += quote + txt + quote;
				} else {
					result += txt;
				}
			}

			return result;
		};

		std::string result;
		switch (_type) {
		case Types::INTERMEDIA: case Types::MATH: case Types::STATEMENT: case Types::ARRAY: case Types::MACRO:
			result += "<";
			result += Text::toString((Variant::Int)_data);
			result += ">";

			break;
		case Types::SPACE:
			result = dumpString(_data, nullptr, nullptr, "'", false, false, false);

			break;
		case Types::STRING:
			result = dumpString(_data, nullptr, "\"\"", "\"", true, true, false);

			break;
		case Types::COMMENT:
			result = dumpString(
				_data,
				[] (const Variant &data) -> std::string {
					std::string txt = (std::string)data;
					if (txt.length() >= 1 && txt.front() == ' ')
						txt.erase(txt.begin());

					return txt;
				},
				nullptr,
				"'",
				true, false, false
			);

			break;
		case Types::NONE:                                                // Fall through.
		case Types::END_OF_LINE:                                         // Fall through.
		case Types::OPERATOR:                                            // Fall through.
		case Types::SYMBOL: case Types::KEYWORD: case Types::IDENTIFIER: // Fall through.
		case Types::NOTHING:                                             // Fall through.
		case Types::BOOLEAN:                                             // Fall through.
		case Types::NUMBER: case Types::INTEGER: case Types::REAL:       // Fall through.
		default:
			switch (_data.type()) {
			case Variant::NIL:
				result += "nothing";

				break;
			case Variant::BOOLEAN:
				if ((bool)_data)
					result += "true";
				else
					result += "false";

				break;
			case Variant::INTEGER:
				result += Text::toString((Variant::Int)_data);

				break;
			case Variant::LONG:
				result += Text::toString((Variant::Long)_data);

				break;
			case Variant::REAL:
				result += Text::toString((Double)_data);

				break;
			case Variant::STRING:
				result = dumpString(_data, nullptr, "\"\"", nullptr, true, false, true);

				break;
			case Variant::POINTER:
				result += "*";

				break;
			case Variant::OBJECT:
				result += "{ }";

				break;
			}

			break;
		}

		return result;
	}

	static size_t sizeOfIntegers(const Array &values) { // In bytes.
		size_t result = 0;
		for (int i = 0; i < (int)values.size(); ++i) {
			const Ptr &tk = values[i];
			if (tk->is(Types::INTEGER)) {
				switch (tk->details().integerType) {
				case IntegerTypes::UNSPECIFIED:
					result += 1;

					break;
				case IntegerTypes::INT:
					result += 2;

					break;
				default:
					GBBASIC_ASSERT(false && "Impossible.");

					break;
				}
			} else {
				GBBASIC_ASSERT(false && "Impossible.");
			}
		}

		return result;
	}
};

IMPLEMENT_ENUM_OPERATORS(Token::Types)

static bool is(Token::Types val, Token::Types y) {
	return (val & y) != Token::Types::NONE;
}
static bool isNot(Token::Types val, Token::Types y) {
	return (val & y) == Token::Types::NONE;
}

}

/* ===========================================================================} */

/*
** {===========================================================================
** Node interface
*/

namespace GBBASIC {

INode::~INode() {
}

Where::Where() {
}

Where::Where(INode::Types y, bool failIfNotAllMatch, bool recursive, bool ignoreMeaningless) :
	_type(y),
	_failIfNotAllMatch(failIfNotAllMatch),
	_recursive(recursive),
	_ignoreMeaningless(ignoreMeaningless)
{
}

Where::Where(const std::initializer_list<INode::Types> &y, bool failIfNotAllMatch, bool recursive, bool ignoreMeaningless) :
	_types(y),
	_failIfNotAllMatch(failIfNotAllMatch),
	_recursive(recursive),
	_ignoreMeaningless(ignoreMeaningless)
{
}

Where &Where::isType(INode::Types y) {
	_type = y;

	return *this;
}

Where &Where::isTypeIn(const std::initializer_list<INode::Types> &y) {
	_types = y;

	return *this;
}

Where &Where::doFailIfNotAllMatch(bool val) {
	_failIfNotAllMatch = val;

	return *this;
}

Where &Where::doRecursive(bool val) {
	_recursive = val;

	return *this;
}

Where &Where::doIgnoreMeaningless(bool val) {
	_ignoreMeaningless = val;

	return *this;
}

typedef std::function<bool(INode::Array &, const INode::Array &, const Where &)> SelectCollector;

static bool in(INode::Types y, Where::Types types) {
	for (INode::Types t : types) {
		if (t == INode::Types::ANY)
			return true;

		if (y == t)
			return true;
	}

	return false;
}

Select::Select() {
}

Select::Select(INode::Ptr node) {
	if (!node) {
		_ok = false;

		return;
	}

	_collection.push_back(node);
}

INode::Ptr Select::operator [] (int idx) const {
	if (!_ok)
		return nullptr;

	if (idx < 0 || idx >= (int)_collection.size())
		return nullptr;

	return _collection[idx];
}

INode::Ptr Select::operator -> (void) const {
	if (!_ok)
		return nullptr;

	if (_collection.size() != 1)
		return nullptr;

	return _collection.front();
}

Select Select::only(void) const {
	if (!_ok)
		return Select().fail();

	if (_collection.size() != 1)
		return Select().fail();

	return Select(_collection.front());
}

Select Select::children(void) const {
	if (!_ok)
		return Select().fail();

	return children(Where());
}

Select Select::children(const Where &where) const {
	if (!_ok)
		return Select().fail();

	SelectCollector collect = nullptr;
	collect = [&collect] (INode::Array &out, const INode::Array &collection, const Where &where) -> bool {
		if (collection.empty())
			return false;

		for (const INode::Ptr &elem : collection) {
			INode::Ptr iptr = elem;

			if (where._ignoreMeaningless) {
				if (iptr->type() == INode::Types::BLANK)
					continue;
				if (iptr->type() == INode::Types::REM)
					continue;
			}

			const bool typeMatch = (where._types.empty() && (where._type == INode::Types::ANY || iptr->type() == where._type)) ||
				(!where._types.empty() && in(iptr->type(), where._types));
			if (typeMatch) {
				out.push_back(iptr);
			} else {
				if (where._failIfNotAllMatch)
					return false;
			}

			if (where._recursive) {
				if (!collect(out, iptr->children(), where)) {
					if (where._failIfNotAllMatch)
						return false;
				}
			}
		}

		return true;
	};

	Select result;
	for (const INode::Ptr &elem : _collection) {
		if (!collect(result._collection, elem->children(), where)) {
			if (where._failIfNotAllMatch)
				return Select().fail();
		}
	}

	return result;
}

Select Select::firstChild(void) const {
	return firstChild(Where());
}

Select Select::firstChild(const Where &where) const {
	if (!_ok)
		return Select().fail();

	SelectCollector collect = nullptr;
	collect = [&collect] (INode::Array &out, const INode::Array &collection, const Where &where) -> bool {
		if (collection.empty())
			return false;

		for (const INode::Ptr &elem : collection) {
			INode::Ptr iptr = elem;

			if (where._ignoreMeaningless) {
				if (iptr->type() == INode::Types::BLANK)
					continue;
				if (iptr->type() == INode::Types::REM)
					continue;
			}

			const bool typeMatch = (where._types.empty() && (where._type == INode::Types::ANY || iptr->type() == where._type)) ||
				(!where._types.empty() && in(iptr->type(), where._types));
			if (typeMatch) {
				out.push_back(iptr);
			} else {
				if (where._failIfNotAllMatch)
					return false;

				if (where._recursive) {
					if (collect(out, iptr->children(), where))
						return true;
				}
			}

			return true;
		}

		return false;
	};

	Select result;
	for (const INode::Ptr &elem : _collection) {
		if (collect(result._collection, elem->children(), where)) {
			return result;
		} else {
			if (where._failIfNotAllMatch)
				return Select().fail();
		}
	}

	return result;
}

bool Select::ok(void) const {
	return _ok;
}

int Select::count(void) const {
	if (!_ok)
		return -1;

	return (int)_collection.size();
}

int Select::count(FilterHandler filter) const {
	if (!_ok)
		return -1;

	if (!filter)
		return 0;

	int result = 0;
	for (int i = 0; i < (int)_collection.size(); ++i) {
		const INode::Ptr &elem = _collection[i];
		if (filter(*this, elem, i))
			++result;
	}

	return result;
}

Select Select::filter(FilterHandler filter) const {
	if (!_ok)
		return Select().fail();

	if (!filter)
		return Select().fail();

	Select result;
	for (int i = 0; i < (int)_collection.size(); ++i) {
		const INode::Ptr &elem = _collection[i];
		if (filter(*this, elem, i))
			result._collection.push_back(elem);
	}

	return result;
}

void Select::foreach(ConstEnumerator enumerator) const {
	if (!_ok)
		return;

	if (!enumerator)
		return;

	for (int i = 0; i < (int)_collection.size(); ++i) {
		const INode::Ptr &elem = _collection[i];
		enumerator(*this, elem, i);
	}
}

void Select::foreach(Enumerator enumerator) {
	if (!_ok)
		return;

	if (!enumerator)
		return;

	for (int i = 0; i < (int)_collection.size(); ++i) {
		INode::Ptr &elem = _collection[i];
		enumerator(*this, elem, i);
	}
}

Select &Select::fail(void) {
	_ok = false;
	_collection.clear();

	return *this;
}

}

/* ===========================================================================} */

/*
** {===========================================================================
** AST
*/

namespace GBBASIC {

#if true
#ifndef THROW_AMBIGUOUS_PROGRAM_POINT
#	define THROW_AMBIGUOUS_PROGRAM_POINT(ON_ERROR, OPTIONS) \
		do { \
			throwAmbiguousProgramPoint((ON_ERROR), (OPTIONS)); \
			return; \
		} while (false)
#endif /* THROW_AMBIGUOUS_PROGRAM_POINT */
#ifndef THROW_ARGUMENT_COUNT_DOES_NOT_MATCH
#	define THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(ON_ERROR) \
		do { \
			throwArgumentCountDoesNotMatch(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_ARGUMENT_COUNT_DOES_NOT_MATCH */
#ifndef THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE
#	define THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(ON_ERROR) \
		do { \
			throwAssetIsDefinedAsAnActorButUsedAsAProjectile(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE */
#ifndef THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR
#	define THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(ON_ERROR) \
		do { \
			throwAssetIsDefinedAsAProjectileButUsedAsAnActor(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR */
#ifndef THROW_ASSET_PAGE_OUT_OF_BOUNDS
#	define THROW_ASSET_PAGE_OUT_OF_BOUNDS(ON_ERROR) \
		do { \
			throwAssetPageOutOfBounds(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_ASSET_PAGE_OUT_OF_BOUNDS */
#ifndef THROW_BANK_OVERFLOW
#	define THROW_BANK_OVERFLOW(ON_ERROR) \
		do { \
			throwBankOverflow(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_BANK_OVERFLOW */
#ifndef THROW_DATA_SECTION_OVERFLOW
#	define THROW_DATA_SECTION_OVERFLOW(ON_ERROR) \
		do { \
			throwDataSectionOverflow(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_DATA_SECTION_OVERFLOW */
#ifndef THROW_DUPLICATE_DESTINATION
#	define THROW_DUPLICATE_DESTINATION(ON_ERROR, TK) \
		do { \
			throwDuplicateDestination((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_DUPLICATE_DESTINATION */
#ifndef THROW_HEAP_OVERFLOW
	// As warning or error.
#	define THROW_HEAP_OVERFLOW(ON_ERROR, IS_WARNING) \
		do { \
			throwHeapOverflow((ON_ERROR), nullptr, (IS_WARNING)); \
			if (!(IS_WARNING)) \
				return; \
		} while (false)
#endif /* THROW_HEAP_OVERFLOW */
#ifndef THROW_ID_HAS_BEEN_ALREADY_DECLARED
#	define THROW_ID_HAS_BEEN_ALREADY_DECLARED(ON_ERROR, TK) \
		do { \
			throwIdHasBeenAlreadyDeclared((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_ID_HAS_BEEN_ALREADY_DECLARED */
#ifndef THROW_ID_HAS_NOT_BEEN_DECLARED
#	define THROW_ID_HAS_NOT_BEEN_DECLARED(ON_ERROR, TK) \
		do { \
			throwIdHasNotBeenDeclared((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_ID_HAS_NOT_BEEN_DECLARED */
#ifndef THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN
#	define THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(ON_ERROR, TK, FUZZY) \
		do { \
			throwIdHasNotBeenDeclaredDidYouMean((ON_ERROR), (TK), (FUZZY)); \
			return; \
		} while (false)
#endif /* THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN */
#ifndef THROW_INVALID_ASSET_POINT
#	define THROW_INVALID_ASSET_POINT(ON_ERROR) \
		do { \
			throwInvalidAssetPoint(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_ASSET_POINT */
#ifndef THROW_INVALID_ASSET_POINT_DID_YOU_MEAN
#	define THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(ON_ERROR, FUZZY) \
		do { \
			throwInvalidAssetPointDidYouMean((ON_ERROR), nullptr, (FUZZY)); \
			return; \
		} while (false)
#endif /* THROW_INVALID_ASSET_POINT_DID_YOU_MEAN */
#ifndef THROW_INVALID_COLOR
#	define THROW_INVALID_COLOR(ON_ERROR, TK) \
		do { \
			throwInvalidColor((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_INVALID_COLOR */
#ifndef THROW_INVALID_DATA_POINT
#	define THROW_INVALID_DATA_POINT(ON_ERROR) \
		do { \
			throwInvalidDataPoint(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_DATA_POINT */
#ifndef THROW_INVALID_DESTINATION
#	define THROW_INVALID_DESTINATION(ON_ERROR) \
		do { \
			throwInvalidDestination(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_DESTINATION */
#ifndef THROW_INVALID_EXPRESSION
#	define THROW_INVALID_EXPRESSION(ON_ERROR, TK) \
		do { \
			throwInvalidExpression((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_INVALID_EXPRESSION */
#ifndef THROW_INVALID_GLYPH
#	define THROW_INVALID_GLYPH(ON_ERROR) \
		do { \
			throwInvalidGlyph(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_GLYPH */
#ifndef THROW_INVALID_NATIVE_SYMBOL
#	define THROW_INVALID_NATIVE_SYMBOL(ON_ERROR) \
		do { \
			throwInvalidNativeSymbol(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_NATIVE_SYMBOL */
#ifndef THROW_INVALID_NATIVE_SYMBOL_DID_YOU_MEAN
#	define THROW_INVALID_NATIVE_SYMBOL_DID_YOU_MEAN(ON_ERROR, FUZZY) \
		do { \
			throwInvalidNativeSymbolDidYouMean((ON_ERROR), nullptr, (FUZZY)); \
			return; \
		} while (false)
#endif /* THROW_INVALID_NATIVE_SYMBOL_DID_YOU_MEAN */
#ifndef THROW_INVALID_OPERATION
#	define THROW_INVALID_OPERATION(ON_ERROR, TK) \
		do { \
			throwInvalidOperation((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_INVALID_OPERATION */
#ifndef THROW_INVALID_PROGRAM_POINT
#	define THROW_INVALID_PROGRAM_POINT(ON_ERROR) \
		do { \
			throwInvalidProgramPoint(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_PROGRAM_POINT */
#ifndef THROW_INVALID_SYNTAX
#	define THROW_INVALID_SYNTAX(ON_ERROR) \
		do { \
			throwInvalidSyntax(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_INVALID_SYNTAX */
#ifndef THROW_MEMORY_LEAK
	// As warning.
#	define THROW_MEMORY_LEAK(ON_ERROR) \
		do { \
			throwMemoryLeak(ON_ERROR); \
		} while (false)
#endif /* THROW_MEMORY_LEAK */
#ifndef THROW_NO_DATA
#	define THROW_NO_DATA(ON_ERROR) \
		do { \
			throwNoData(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_NO_DATA */
#ifndef THROW_NOT_IMPLEMENTED
#	define THROW_NOT_IMPLEMENTED(ON_ERROR, TK) \
		do { \
			throwNotImplemented((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_NOT_IMPLEMENTED */
#ifndef THROW_NOT_SUPPORTED
#	define THROW_NOT_SUPPORTED(ON_ERROR, TK) \
		do { \
			throwNotSupported((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_NOT_SUPPORTED */
#ifndef THROW_OBSOLETE_SYNTAX
	// As warning.
#	define THROW_OBSOLETE_SYNTAX(ON_ERROR) \
		do { \
			throwObsoleteSyntax(ON_ERROR); \
		} while (false)
#endif /* THROW_OBSOLETE_SYNTAX */
#ifndef THROW_OUT_OF_BOUNDS
#	define THROW_OUT_OF_BOUNDS(ON_ERROR) \
		do { \
			throwOutOfBounds(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_OUT_OF_BOUNDS */
#ifndef THROW_STACK_OVERFLOW
	// As warning.
#	define THROW_STACK_OVERFLOW(ON_ERROR) \
		do { \
			throwStackOverflow(ON_ERROR); \
		} while (false)
#endif /* THROW_STACK_OVERFLOW */
#ifndef THROW_TABLE_IS_NOT_INITIALIZED
#	define THROW_TABLE_IS_NOT_INITIALIZED(ON_ERROR) \
		do { \
			throwTableIsNotInitialized(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_TABLE_IS_NOT_INITIALIZED */
#ifndef THROW_TOO_FEW_ARGUMENTS
#	define THROW_TOO_FEW_ARGUMENTS(ON_ERROR) \
		do { \
			throwTooFewArguments(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_TOO_FEW_ARGUMENTS */
#ifndef THROW_TOO_MANY_ARGUMENTS
#	define THROW_TOO_MANY_ARGUMENTS(ON_ERROR) \
		do { \
			throwTooManyArguments(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_TOO_MANY_ARGUMENTS */
#ifndef THROW_TYPE_EXPECTED
#	define THROW_TYPE_EXPECTED(ON_ERROR, Y, TK) \
		do { \
			throwTypeExpected((ON_ERROR), (Y), (TK)); \
			return; \
		} while (false)
#endif /* THROW_TYPE_EXPECTED */
#ifndef THROW_UNKNOWN_GLYPH
#	define THROW_UNKNOWN_GLYPH(ON_ERROR) \
		do { \
			throwUnknownGlyph(ON_ERROR); \
			return; \
		} while (false)
#endif /* THROW_UNKNOWN_GLYPH */
#ifndef THROW_UNKNOWN_GLYPHS_IN_FONT_ASSET
	// As warning.
#	define THROW_UNKNOWN_GLYPHS_IN_FONT_ASSET(ON_ERROR, GLYPHS) \
		do { \
			throwUnknownGlyphsInFontAsset((ON_ERROR), (GLYPHS)); \
		} while (false)
#endif /* THROW_UNKNOWN_GLYPHS_IN_FONT_ASSET */
#ifndef THROW_UNKNOWN_TYPE
#	define THROW_UNKNOWN_TYPE(ON_ERROR, TK) \
		do { \
			throwUnknownType((ON_ERROR), (TK)); \
			return; \
		} while (false)
#endif /* THROW_UNKNOWN_TYPE */
#ifndef THROW_USING_COLORED_FEATURE_WITH_CLASSIC_CARTRIDGE_ENABLE_COLORED_FEATURE_IN_PROJECT_PROPERTY
	// As warning.
#	define THROW_USING_COLORED_FEATURE_WITH_CLASSIC_CARTRIDGE_ENABLE_COLORED_FEATURE_IN_PROJECT_PROPERTY(ON_ERROR, TK) \
		do { \
			throwUsingColoredFeatureWithClassicCartridgeEnableColoredFeatureInProjectProperty((ON_ERROR), (TK)); \
		} while (false)
#endif /* THROW_USING_COLORED_FEATURE_WITH_CLASSIC_CARTRIDGE_ENABLE_COLORED_FEATURE_IN_PROJECT_PROPERTY */
#ifndef THROW_USING_EXTENSION_FEATURE_WITH_REGULAR_CARTRIDGE_ENABLE_EXTENSION_FEATURE_IN_PROJECT_PROPERTY
	// As warning.
#	define THROW_USING_EXTENSION_FEATURE_WITH_REGULAR_CARTRIDGE_ENABLE_EXTENSION_FEATURE_IN_PROJECT_PROPERTY(ON_ERROR, TK) \
		do { \
			throwUsingExtensionFeatureWithRegularCartridgeEnableExtensionFeatureInProjectProperty((ON_ERROR), (TK)); \
		} while (false)
#endif /* THROW_USING_EXTENSION_FEATURE_WITH_REGULAR_CARTRIDGE_ENABLE_EXTENSION_FEATURE_IN_PROJECT_PROPERTY */
#ifndef THROW_USING_FILE_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED
	// As warning.
#	define THROW_USING_FILE_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED(ON_ERROR) \
		do { \
			throwUsingFileFeatureButCartridgeDoesNotHaveThisFunctionEnabled(ON_ERROR); \
		} while (false)
#endif /* THROW_USING_FILE_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED */
#ifndef THROW_USING_RTC_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED
	// As warning.
#	define THROW_USING_RTC_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED(ON_ERROR) \
		do { \
			throwUsingRtcFeatureButCartridgeDoesNotHaveThisFunctionEnabled(ON_ERROR); \
		} while (false)
#endif /* THROW_USING_RTC_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED */

#ifndef CHECK_FOR_INTEGER_OR_IDENTIFIER
#	define CHECK_FOR_INTEGER_OR_IDENTIFIER(ON_ERROR, TK) \
		do { \
			if (!(TK) || ((TK)->isNot(Token::Types::INTEGER) && (TK)->isNot(Token::Types::IDENTIFIER))) { \
				THROW_TYPE_EXPECTED((ON_ERROR), "Integer or label", (TK)); \
			} \
		} while (false)
#endif /* CHECK_FOR_INTEGER_OR_IDENTIFIER */
#ifndef CHECK_FOR_STRING
#	define CHECK_FOR_STRING(ON_ERROR, TK) \
		do { \
			if (!(TK) || ((TK)->isNot(Token::Types::STRING))) { \
				THROW_TYPE_EXPECTED((ON_ERROR), "String", (TK)); \
			} \
		} while (false)
#endif /* CHECK_FOR_STRING */

#endif

/*
** {===========================================================================
** Base node
*/

/**
 * @brief Base class for all AST nodes.
 */
class Node : public INode {
public:
	/**< Type declarations. */

	typedef std::shared_ptr<Node> Ptr;
	typedef std::vector<Ptr> Array;

	template<typename T> struct ScopeStack { // FEAT: MACRO.
	private:
		typedef T ValueType;
		typedef typename ValueType::Entry Entry;
		typedef std::vector<ValueType> Stack;

	private:
		Stack _stack;

	public:
		ScopeStack() {
			_stack.push_back(ValueType());
		}

		int count(void) const {
			return (int)_stack.size();
		}
		ValueType &push(const ValueType &val) {
			_stack.push_back(val);

			return _stack.back();
		}
		ValueType &push(void) {
			_stack.push_back(ValueType());

			return _stack.back();
		}
		ValueType pop(void) {
			ValueType top = _stack.back();
			_stack.pop_back();

			return top;
		}
		ValueType &&top(void) {
			ValueType &top = _stack.back();

			return std::move(top);
		}

		bool add(const std::string &key, const typename ValueType::Entry &entry) {
			ValueType &frame = _stack.back();

			return frame.add(key, entry);
		}
		const typename ValueType::Entry* find(const std::string &key) const {
			return find(key, -1);
		}
		const typename ValueType::Entry* find(const std::string &key, int depth) const {
			if (depth == 0)
				return nullptr;

			for (typename Stack::const_reverse_iterator rit = _stack.rbegin(); rit != _stack.rend(); ++rit) {
				const ValueType &frame = *rit;
				const typename ValueType::Entry* ret = frame.find(key);
				if (ret)
					return ret;

				if (depth > 0) {
					if (--depth == 0)
						break;
				}
			}

			return nullptr;
		}
		void clear(void) {
			_stack.clear();

			_stack.push_back(ValueType());
		}
	};
	template<typename T> struct MacroTable { // FEAT: MACRO.
	public:
		typedef ScopeStack<MacroTable> Stack;

		typedef T Entry;

	private:
		typedef std::map<std::string, Entry> Dictionary;

	private:
		Dictionary _dictionary;

	public:
		MacroTable() {
		}

		bool add(const std::string &key, const Entry &entry) {
			const std::pair<typename Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, entry));

			return ret.second;
		}
		const Entry* find(const std::string &key) const {
			typename Dictionary::const_iterator it = _dictionary.find(key);
			if (it == _dictionary.end())
				return nullptr;

			return &it->second;
		}
		void clear(void) {
			_dictionary.clear();
		}
	};
	struct MacroAliasEntry {
		Token::Ptr alias = nullptr;
		std::string name;

		MacroAliasEntry() {
		}
		MacroAliasEntry(const Token::Ptr &alias_, const std::string &n) : alias(alias_), name(n) {
		}
	};
	typedef MacroTable<MacroAliasEntry> MacroAliasTable; // FEAT: MACRO.
	struct MacroFunctionEntry {
		Token::Array parameters;
		Ptr expression = nullptr;

		MacroFunctionEntry() {
		}
		MacroFunctionEntry(const Token::Array &params, const Ptr &expr) : parameters(params), expression(expr) {
		}

		int count(void) const {
			return (int)parameters.size();
		}
		int indexOf(const std::string &id) const {
			for (int i = 0; i < (int)parameters.size(); ++i) {
				const Token::Ptr &tk = parameters[i];
				if (tk->text() == id)
					return i;
			}

			return -1;
		}
	};
	typedef MacroTable<MacroFunctionEntry> MacroFunctionTable; // FEAT: MACRO.
	struct MacroConstantEntry {
		Token::Ptr constant = nullptr;
		int value = std::numeric_limits<int>::min();

		MacroConstantEntry() {
		}
		MacroConstantEntry(const Token::Ptr &const_, int val) : constant(const_), value(val) {
		}
	};
	typedef MacroTable<MacroConstantEntry> MacroConstantTable; // FEAT: MACRO.
	struct MacroIdentifierAliasEntry {
		Token::Ptr alias = nullptr;
		std::string name;

		MacroIdentifierAliasEntry() {
		}
		MacroIdentifierAliasEntry(const Token::Ptr &alias_, const std::string &n) : alias(alias_), name(n) {
		}
	};
	typedef MacroTable<MacroIdentifierAliasEntry> MacroIdentifierAliasTable; // FEAT: MACRO.
	struct MacroStackReferenceEntry {
		Token::Ptr alias = nullptr;
		int index = -1;

		MacroStackReferenceEntry() {
		}
		MacroStackReferenceEntry(const Token::Ptr &alias_, int idx) : alias(alias_), index(idx) {
		}
	};
	typedef MacroTable<MacroStackReferenceEntry> MacroStackReferenceTable; // FEAT: MACRO.

	struct RomAllocator {
	private:
		typedef std::map<SourceLocation, RomLocation> Dictionary;

	public:
		typedef std::vector<std::pair<SourceLocation, RomLocation> > Array;

	private:
		// Stores "line number" to "ROM address" mapping.
		Dictionary _dictionary;

	public:
		RomAllocator() {
		}

		Array findAll(const std::string &key) const {
			Array result;
			if (key.empty())
				return result;

			for (const Dictionary::value_type &kv : _dictionary) {
				const SourceLocation &srcLoc = kv.first;
				const RomLocation &dstLoc = kv.second;
				if (srcLoc.label == key)
					result.push_back(std::make_pair(srcLoc, dstLoc));
			}

			return result;
		}
		const RomLocation* find(const SourceLocation &key) const {
			Dictionary::const_iterator it = _dictionary.find(key);
			if (it == _dictionary.end())
				return nullptr;

			return &it->second;
		}
		bool put(const SourceLocation &key, const RomLocation &val) {
			const std::pair<Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, val));

			return ret.second;
		}
	};
	struct RamAllocator {
	private:
		typedef RamLocation::Dictionary Dictionary;

	private:
		mutable Byte RAM[RAM_SIZE]; // Up to 8KB.

		// Stores "ID" to "RAM address" mapping.
		Dictionary _dictionary;

	public:
		RamAllocator() {
		}

		const RamLocation::Dictionary &allocations(void) const {
			return _dictionary;
		}
		const RamLocation* find(const std::string &key) const {
			Dictionary::const_iterator it = _dictionary.find(key);
			if (it == _dictionary.end())
				return nullptr;

			return &it->second;
		}
		const RamLocation* fuzzy(const std::string &key, std::string &gotKey, double* score_ /* nullable */) const {
			gotKey.clear();
			if (score_)
				*score_ = 0;

			double fuzzyScore = 0.0;
			Dictionary::const_iterator fuzzyIt = _dictionary.end();
			for (Dictionary::const_iterator it = _dictionary.begin(); it != _dictionary.end(); ++it) {
				const std::string &name = it->first;
				if (name == key) {
					gotKey = name;

					return &it->second;
				}

				if (name.empty())
					continue;

				const double score = rapidfuzz::fuzz::ratio(name, key);
				if (score < FUZZY_MATCHING_SCORE_THRESHOLD)
					continue;
				if (score > fuzzyScore) {
					fuzzyScore = score;
					fuzzyIt = it;
				}
			}

			if (fuzzyIt != _dictionary.end()) {
				gotKey = fuzzyIt->first;
				if (score_)
					*score_ = fuzzyScore;

				return &fuzzyIt->second;
			}

			return nullptr;
		}
		bool put(const std::string &key, const RamLocation &val) {
			const std::pair<Dictionary::iterator, bool> ret = _dictionary.insert(std::make_pair(key, val));

			return ret.second;
		}
		int allocate(int heapSize, int wordSize, int expSize) const {
			memset(RAM, 0, heapSize);
			for (const Dictionary::value_type &kv : _dictionary) {
				const RamLocation &ramLocation = kv.second;
				for (int i = 0; i < ramLocation.size; ++i) {
					const int address = ramLocation.address * wordSize + i;
					RAM[address] = COMPILER_INVALID_INSTRUCTION;
				}
			}

			int result = -1;
			for (int i = 0; i < heapSize; i += wordSize) {
				if (i + expSize > heapSize)
					break;

				bool occupied = false;
				for (int j = 0; j < expSize; ++j) {
					if (RAM[i + j] != 0) {
						occupied = true;

						break;
					}
				}
				if (!occupied) {
					result = i / wordSize; // The VM addresses in RAM as `int16_t*`.

					break;
				}
			}

			return result;
		}
	};

	struct Context : public RomAllocator, public RamAllocator {
		/**< Type declarations. */

		typedef std::stack<Context> Stack;

		struct Page : public RamAllocator {
			typedef std::vector<Page> Array;

			Page() {
			}

			using RamAllocator::find;
			using RamAllocator::put;
			using RamAllocator::allocate;
		};

		struct Expect {
			bool lnno = true;

			Expect() {
			}
		};

		struct Declaration {
			bool declarationRequired = true; // Whether declaration is required before using a variable.
			int declaring = -1;

			static const int ARGUMENT; // As argument of a function.

			Declaration() {
			}
		};

		struct Expression {
			enum class Categories : unsigned {
				NONE         = 0,
				CONST        = 1 << 0,      // Const value.
				VARIABLE     = 1 << 1,      // Variable.
				EVALUATION   = 1 << 2,      // Evaluation (expression).
				SLOT         = 1 << 3,      // (Evaluated) slot.
				ALL          = (unsigned)~0
			};

			typedef std::shared_ptr<std::vector<int> > Slots;

			typedef std::map<std::string, int> Temporaries;

			Categories category = Categories::ALL;                       // Filters acceptable evaluations.
			bool alwaysEvaluate = false;                                 // `true` for always evaluating (even for integer, single variable expression, etc).
			Endians endian = Endians::BIG;                               // Indicates how to encode the data.
			int index = 0;                                               // Marks the current evaluation slot for later indexing.
			Slots slots = nullptr;                                       // Stores the expression slots.
			bool optimize = true;                                        // Whether to optimize expression.
			const MacroFunctionTable::Entry* macroFunctions = nullptr;   // FEAT: MACRO. Stores the current macro function information if there's any.
			const Temporaries* temporaries = nullptr;                    // Stores the current temporary information if there's any.

			Expression() {
			}

			bool allow(Categories cat) const {
				return (category & cat) != Categories::NONE;
			}

			int slotCount(void) const {
				if (!slots)
					return 0;

				return (int)slots->size();
			}
			void putSlot(int index_) {
				if (!slots)
					return;

				slots->push_back(index_);
			}
			int getSlot(void) const {
				if (!slots)
					return 0;

				Context::Expression::Slots::element_type::const_iterator it = std::find(slots->begin(), slots->end(), index);
				if (it == slots->end())
					return 0;

				const int result = (int)(-(slots->end() - it));

				return result;
			}
		};

		struct Loop {
			typedef std::list<Loop> Stack;

			typedef std::vector<intptr_t> Offsets;
			typedef std::map<std::string, Offsets> Nexts;
			typedef Offsets Breaks;

			enum class Types {
				NONE,
				FOR,
					LOOP, // Optimized `FOR` loop.
				WHILE,
				REPEAT
			};

			Types type = Types::NONE;
			std::string current;
			Nexts toNext;
			Breaks toBreak;

			Loop() {
			}
			Loop(Types y) : type(y) {
			}
			Loop(Types y, const std::string &c) : type(y), current(c) {
			}

			const Offsets* getNext(const std::string &id) const {
				Nexts::const_iterator it = toNext.find(id);
				if (it == toNext.end())
					return nullptr;

				return &it->second;
			}
			void addNext(const std::string &id, intptr_t offset) {
				Nexts::iterator it = toNext.find(id);
				if (it == toNext.end()) {
					const std::pair<Nexts::iterator, bool> it_ = toNext.insert(std::make_pair(id, Offsets()));
					it = it_.first;
				}
				Offsets &offsets = it->second;
				offsets.push_back(offset);
			}
			void removeNext(const std::string &id) {
				Nexts::iterator it = toNext.find(id);
				if (it == toNext.end())
					return;

				toNext.erase(it);
			}

			void addBreak(intptr_t offset) {
				toBreak.push_back(offset);
			}
			void clearBreaks(void) {
				toBreak.clear();
			}
		};

		struct Array {
			struct Dimensions {
				typedef std::map<std::string, Dimensions> Dictionary;

				typedef std::vector<int> Bounds;

				Bounds bounds;

				Dimensions() {
				}

				int size(void) const {
					int result = 1;
					for (int b : bounds)
						result *= b;
					GBBASIC_ASSERT(result > 0 && "Impossible.");

					return Math::max(result, 1);
				}
			};

			Dimensions::Dictionary named;
			int base = 0;

			Array() {
			}

			const Dimensions* find(const std::string &name) const {
				Dimensions::Dictionary::const_iterator it = named.find(name);
				if (it == named.end())
					return nullptr;

				return &it->second;
			}
		};

		struct Data {
			struct Value {
				typedef std::vector<Value> Array;

				int value = 0;                                               // The data value.
				int page = 0;                                                // The page index where the data value is declared.
				int line = 0;                                                // The line index where the data value is declared.
				Token::IntegerTypes type = Token::IntegerTypes::UNSPECIFIED; // The data type.

				Value() {
				}
				Value(int pg, int ln, int val, Token::IntegerTypes y) : page(pg), line(ln), value(val), type(y) {
				}
			};
			struct Labeled {
				typedef std::map<Labeled, int> Dictionary;

				int page = 0;     // The page index of the label.
				std::string name; // The name of the label.

				Labeled() {
				}
				Labeled(int pg, const std::string &n) : page(pg), name(n) {
				}

				bool operator < (const Labeled &other) const {
					return compare(other) < 0;
				}

				int compare(const Labeled &other) const {
					if (page < other.page)
						return -1;
					else if (page > other.page)
						return 1;

					if (name < other.name)
						return -1;
					else if (name > other.name)
						return 1;

					return 0;
				}
			};

			Value::Array values;         // The data sequence.
			Labeled::Dictionary labeled; // The label to index of data mapping.

			Data() {
			}

			size_t size(void) const { // Gets the size in bytes of the data sequence.
				size_t result = 0;
				for (int i = 0; i < (int)values.size(); ++i) {
					const Data::Value &data_ = values.at(i);
					switch (data_.type) {
					case Token::IntegerTypes::UNSPECIFIED:
						result += 1;

						break;
					case Token::IntegerTypes::INT:
						result += 2;

						break;
					default:
						GBBASIC_ASSERT(false && "Not implemented.");

						break;
					}
				}

				return result;
			}
			bool empty(void) const {
				return values.empty();
			}
			int find(int page, int lnno) const { // Gets the data index by line number.
				for (int i = 0; i < (int)values.size(); ++i) {
					const Data::Value &data_ = values.at(i);
					if (data_.page == page && data_.line == lnno)
						return i;
				}

				return -1;
			}
			int find(int page, const std::string &name) const { // Gets the data index by label name.
				Labeled::Dictionary::const_iterator it = labeled.find(Labeled(page, name));
				if (it == labeled.end())
					return -1;

				return it->second;
			}
		};

		/**< ROM constants and variables. */

		// Const. Type cartridge type.
		GBBASIC::Options::Strategies::Compatibilities compatibility = GBBASIC::Options::Strategies::Compatibilities::CLASSIC | GBBASIC::Options::Strategies::Compatibilities::COLORED;
		// Const. The SRAM type.
		int sramType = 0x03;
		// Const. Whether the cartridge has RTC feature.
		bool cartridgeHasRtc = true;
		// Const. The index of the start ROM bank.
		int startBank = 0;
		// Const. The size of a ROM bank.
		int bankSize = 0;
		// Const. The start address of a ROM bank.
		int startAddress = 0;
		// Non-const. The index of the ROM bank.
		int bank = 0;
		// Non-const. The address cursor in the ROM bank.
		int addressCursor = 0;

		/**< RAM variables. */

		// The usable heap size in bytes.
		int heapSize = RAM_SIZE;
		// The usable stack size in bytes.
		int stackSize = RAM_SIZE;
		// The stack footprint in bytes.
		Counter::Ptr stackFootprint = nullptr;
		// The index of the RAM page.
		int currentPage = 0;
		// The RAM pages.
		Page::Array pages;

		/**< Compiling variables. */

		const Asm::Instructions* instructions = nullptr;       // Stores the VM instructions.

		bool caseInsensitive = true;                           // Stores whether is running as case insensitive.
		Expect expect;                                         // Stores the syntax expectations.
		Declaration declaration;                               // Stores the declaration context.
		Expression expression;                                 // Stores the expression context.
		Loop::Stack loop;                                      // Stores the loop context.

		const Array* array = nullptr;                          // Stores the array configuration, and user defined arrays.
		const Data* data = nullptr;                            // Stores the data sequence information.
		const SymbolTable* symbols = nullptr;                  // Stores the symbols of the input VM ROM.
		const BuiltinTable* builtins = nullptr;                // Stores the system defined, and user defined builtin variables, constants and registers.
		const FunctionTable* functions = nullptr;              // Stores the generic function information for `NodeRoutine` and `NodeFunction`.
		const OperatorTable* operators = nullptr;              // Stores the regular and function-like math operators.
		MacroFunctionTable::Stack* macroFunctions = nullptr;   // FEAT: MACRO. Stores the user defined macro functions.

		AssetsBundle::Ptr assets = nullptr;                    // Stores the assets.
		Pipeline::Ptr pipeline = nullptr;                      // Stores the resources.

		/**< Constructors. */

		Context() {
		}

		/**< ROM methods. */

		using RomAllocator::find;
		using RomAllocator::put;

		/**< Global RAM methods. */

		using RamAllocator::find;
		using RamAllocator::put;
		using RamAllocator::allocate;

		/**< Page methods. */

		Page &page(int index) {
			if ((int)pages.size() <= index)
				pages.resize(index + 1, Page());

			return pages[index];
		}
		Page &page(void) {
			return page(currentPage);
		}

		/**< Page and global RAM methods. */

		const RamLocation* findPageAndGlobal(const std::string &key) {
			const RamLocation* ramLocation = page().find(key);
			if (!ramLocation)
				ramLocation = find(key);

			return ramLocation;
		}
		const RamLocation* findPageAndGlobal(const std::string &key, std::string &gotKey) {
			gotKey.clear();

			const RamLocation* ramLocation = page().find(key);
			if (!ramLocation)
				ramLocation = find(key);

			if (ramLocation)
				return ramLocation;

			std::string gotKeyInPage;
			double pageScore = 0;
			const RamLocation* ramLocationInPage = page().fuzzy(key, gotKeyInPage, &pageScore);

			std::string gotKeyInGlobal;
			double globalScore = 0;
			const RamLocation* ramLocationInGlobal = fuzzy(key, gotKeyInGlobal, &pageScore);

			if ((ramLocationInPage && !ramLocationInGlobal) || (ramLocationInPage && ramLocationInGlobal && pageScore >= globalScore))
				gotKey = gotKeyInPage;
			else if ((!ramLocationInPage && ramLocationInGlobal) || (ramLocationInPage && ramLocationInGlobal && pageScore < globalScore))
				gotKey = gotKeyInGlobal;

			return nullptr;
		}
	};

	struct Range {
		int first = 0;
		int second = 0;

		Range() {
		}
		Range(int v) : first(v), second(v) {
		}
		Range(int f, int s) : first(f), second(s) {
		}
	};

	typedef Either<int, std::string> Destination;

protected:
	/**< Type declarations. */

	struct Scheduled {
	public:
		typedef std::vector<Scheduled> Array;

	public:
		SourceLocation target;
		int argsOffset = 0;
		bool overflow = false;

	private:
		bool _pending = false;

	public:
		Scheduled() {
		}
		Scheduled(const SourceLocation &t, const Byte* begin, const Byte* end, bool overflow_) : target(t), overflow(overflow_) {
			argsOffset = (int)((intptr_t)end - (intptr_t)begin);
			_pending = true;
		}
		Scheduled(const SourceLocation &t, int offset, bool overflow_) : target(t), overflow(overflow_) {
			argsOffset = offset;
			_pending = true;
		}
		Scheduled(int offset) {
			argsOffset = offset;
			_pending = true;
		}

		bool pending(void) {
			if (!_pending)
				return false;

			_pending = false;

			return true;
		}

		Byte* args(const Byte* begin) const {
			return (Byte*)((intptr_t)begin + argsOffset);
		}
	};

	struct State {
		typedef std::stack<State> Stack;

		int tokenCursor = 0;
		SourceLocation inCode;
		RomLocation inRom;
		RamLocation inRam;

		State() {
		}
	};

	typedef std::list<intptr_t> Addresses;

	typedef std::function<void(bool)> Generator_Void_Bool;
	typedef std::function<void(void)> Generator_Void_Void;
	typedef std::function<void(Byte* &)> Generator_Void_Byteptr;
	typedef std::function<void(Counter &)> Generator_Void_Counter;
	typedef std::function<int(Counter &)> Generator_Int_Counter;

	typedef std::function<void(Token::Ptr)> Consumer;

protected:
	/**< Variables. */

	Token::Array _tokens;
	Array _children;
	State::Stack _state;

	/**< Constants. */

	static constexpr const int ARG0 = -1;
	static constexpr const int ARG1 = -2;
	static constexpr const int ARG2 = -3;
	static constexpr const int ARG3 = -4;
	static constexpr const int ARG4 = -5;
	// ...

public:
	/**
	 * Major interfaces.
	 */

	/**< Constructor and destructor. */

	Node() {
		_state.push(State());
	}
	virtual ~Node() override {
	}

	/**< Implementation for base interface `INode`. */

	virtual TextLocation::Range location(void) const override {
		TextLocation::Range result = std::make_pair(TextLocation::INVALID(), TextLocation::INVALID());

		for (const Ptr &child : _children) {
			TextLocation::Range childLoc = child->location();
			if (result.first.invalid())
				result.first = childLoc.first;
			else if (childLoc.first < result.first)
				result.first = childLoc.first;
			if (result.second.invalid())
				result.second = childLoc.second;
			else if (childLoc.second > result.second)
				result.second = childLoc.second;
		}

		for (const Token::Ptr &tk : _tokens) {
			const TextLocation &tkBegin = tk->begin();
			const TextLocation &tkEnd = tk->end();
			if (result.first.invalid())
				result.first = tkBegin;
			else if (tkBegin < result.first)
				result.first = tkBegin;
			if (result.second.invalid())
				result.second = tkEnd;
			else if (tkEnd > result.second)
				result.second = tkEnd;
		}

		return result;
	}

	virtual INode::Array children(void) const override {
		INode::Array result;

		for (const Ptr &child : _children) {
			INode::Ptr iptr = child;
			result.push_back(iptr);
		}

		return result;
	}

	Abstract abstract(const char* head0) const {
		const Token::Array allTokens_ = allTokens(false);
		Abstract result;
		if (head0)
			result.push_back(head0);
		for (int i = 0; i < (int)allTokens_.size(); ++i) {
			const Token::Ptr &tk = allTokens_[i];
			const std::string &txt = tk->caseSensitiveText();
			result.push_back(txt);
		}

		return result;
	}
	Abstract abstract(const char* head0, const char* head1) const {
		const Token::Array allTokens_ = allTokens(false);
		Abstract result;
		if (head0)
			result.push_back(head0);
		if (head1)
			result.push_back(head1);
		for (int i = 0; i < (int)allTokens_.size(); ++i) {
			const Token::Ptr &tk = allTokens_[i];
			const std::string &txt = tk->caseSensitiveText();
			result.push_back(txt);
		}

		return result;
	}

	/**< Options. */

	virtual Variant options(const std::string &key) const {
		(void)key;

		// Do nothing.

		return nullptr;
	}
	virtual void options(const IDictionary::Ptr &options) {
		(void)options;

		// Do nothing.
	}

	/**< Construction functions. */

	bool insert(const Token::Ptr &token, int offset = 0) {
		if (offset < 0 || offset > (int)_tokens.size())
			return false;

		if (offset == (int)_tokens.size())
			_tokens.push_back(token);
		else
			_tokens.insert(_tokens.begin() + offset, token);

		return true;
	}
	void concat(const Token::Ptr &token) {
		_tokens.push_back(token);
	}
	void concat(const Token::Array &tokens) {
		for (const Token::Ptr &tk : tokens)
			concat(tk);
	}

	void add(const Ptr &child) {
		_children.push_back(child);
	}
	void add(const Array &nodes) {
		for (const Ptr &node : nodes)
			add(node);
	}

	/**< Generating functions. */

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, const Range &range, Error::Handler onError) {
		// Prepare.
		auto generate_ = [&] (int index) -> void {
			if (index < 0 || index >= (int)_children.size())
				return;

			Context &ctx = context.top();
			ctx.expression.index = index;

			const Ptr &child = _children[index];
			child->generate(bytes, context, onError);
		};

		// Generate a range of children.
		if (range.first == range.second) {
			generate_(range.first);
		} else if (range.first < range.second) {
			for (int i = range.first; i <= range.second; ++i)
				generate_(i);
		} else /* if (range.first > range.second) */ {
			for (int i = range.first; i >= range.second; --i)
				generate_(i);
		}
	}
	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) {
		// Generate all children.
		for (const Ptr &child : _children)
			child->generate(bytes, context, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) {
		// Post all children.
		for (const Ptr &child : _children)
			child->post(bytes, context, onError);
	}

	/**
	 * State manipulation interfaces.
	 */

	/**< Traversing functions that save and restore states. */

	int count(void) const {
		return (int)_state.size();
	}
	State &top(void) {
		return _state.top();
	}
	int push(void) {
		_state.push(State());

		for (Ptr &child : _children)
			child->push();

		return (int)_state.size();
	}
	int pop(void) {
		_state.pop();

		for (Ptr &child : _children)
			child->pop();

		return (int)_state.size();
	}
	int set(void) {
		const State top = _state.top();
		_state.pop();
		_state.top() = top;

		for (Ptr &child : _children)
			child->set();

		return (int)_state.size();
	}

	/**< Memory bus functions. */

	bool allocateHeap(Context &ctx, int heapSize, int expSize, const std::string &id, RamLocation::Usages usage, const TextLocation &txtLoc) {
		const int address = ctx.allocate(heapSize, WORD_SIZE, expSize);
		if (address >= 0) {
			const RamLocation inRam(RamLocation::Types::HEAP, address, expSize, usage, txtLoc);
			top().inRam = inRam;
			ctx.put(id, top().inRam);

			return true;
		}

		return false;
	}

	/**< Lookup functions. */

	void findDestination(Context &ctx, const SourceLocation &target, const RomLocation** out, Error::Handler onError) const {
		GBBASIC_ASSERT(out && "Wrong data.");

		*out = nullptr;

		const RomLocation* romLocation = ctx.find(target);
		if (romLocation) { // In the same page.
			*out = romLocation;

			return;
		}

		if (target.label.empty()) { // By line number.
			THROW_INVALID_PROGRAM_POINT(onError);
		}

		RomAllocator::Array romLocations = ctx.findAll(target.label);
		if (romLocations.empty()) { // No label matched.
			THROW_INVALID_PROGRAM_POINT(onError);
		}
		if (romLocations.size() > 1) { // Ambiguous.
			Text::Array options;
			for (const RomAllocator::Array::value_type &romLoc : romLocations) {
				const std::string opt = romLoc.first.toString();
				options.push_back(opt);
			}
			THROW_AMBIGUOUS_PROGRAM_POINT(onError, options);
		}

		romLocation = ctx.find(romLocations.front().first); // Unique.
		GBBASIC_ASSERT(romLocation && "Impossible.");

		*out = romLocation;
	}

	/**
	 * Input interfaces.
	 */

	/**< Match and consume tokens. */

	// The `current(...)` functions check whether the current token matches the specific pattern.
	static Token::Ptr current(const Token::Array &tokens, int index, Token::Types y, Variant d = nullptr) {
		if (index >= (int)tokens.size())
			return nullptr;

		const Token::Ptr &tk = tokens[index];
		if (tk->isNot(y))
			return nullptr;
		if (d == ANYTHING)
			return tk;
		if (d != nullptr && tk->data() != d)
			return nullptr;

		return tk;
	}
	Token::Ptr current(Token::Types y, Variant d = nullptr) {
		State &state = top();

		return current(_tokens, state.tokenCursor, y, d);
	}
	// The `consume(...)` functions check whether the current token matches the specific pattern,
	// then move the cursor to the next location if matched, otherwise return `nullptr`.
	static Token::Ptr consume(const Token::Array &tokens, int &index) {
		if (index >= (int)tokens.size())
			return nullptr;

		return tokens[index++];
	}
	static Token::Ptr consume(const Token::Array &tokens, int &index, Token::Types y, Variant d = nullptr) {
		if (is(y, Token::Types::END_OF_LINE)) {
			if (index >= (int)tokens.size()) { // No token for end-of-line.
				Token::Ptr node(new Token());
				node
					->type(Token::Types::END_OF_LINE);

				return node;
			}
		}

		if (index >= (int)tokens.size())
			return nullptr;

		const Token::Ptr &tk = tokens[index];

		if (tk->isNot(y))
			return nullptr;
		if (d == ANYTHING) {
			++index;

			return tk;
		}
		if (d != nullptr && tk->data() != d)
			return nullptr;

		++index;

		return tk;
	}
	static Token::Ptr consume(const Token::Array &tokens, int &index, Consumer consumer) {
		Token::Ptr tk = consume(tokens, index);
		if (consumer && tk)
			consumer(tk);

		return tk;
	}
	static Token::Ptr consume(const Token::Array &tokens, int &index, Token::Types y, Variant d, Consumer consumer) {
		Token::Ptr tk = consume(tokens, index, y, d);
		if (consumer && tk)
			consumer(tk);

		return tk;
	}
	Token::Ptr consume(void) {
		State &state = top();

		return consume(_tokens, state.tokenCursor);
	}
	Token::Ptr consume(Consumer consumer) {
		Token::Ptr tk = consume();
		if (consumer && tk)
			consumer(tk);

		return tk;
	}
	Token::Ptr consume(Token::Types y) {
		State &state = top();

		return consume(_tokens, state.tokenCursor, y, nullptr);
	}
	Token::Ptr consume(Token::Types y, Variant d) {
		State &state = top();

		return consume(_tokens, state.tokenCursor, y, d);
	}
	Token::Ptr consume(Token::Types y, Variant d, Consumer consumer) {
		Token::Ptr tk = consume(y, d);
		if (consumer && tk)
			consumer(tk);

		return tk;
	}
	bool consume(Context &ctx, bool &byAddress, int &bank, int &address, std::string &symbol, std::string &caseSensitiveSymbol, Error::Handler onError) {
		byAddress = false;
		bank = 0;
		address = 0;
		symbol.clear();
		caseSensitiveSymbol.clear();

		if (!consume([&] (Token::Ptr tk) -> void {
			if (tk->is(Token::Types::INTEGER)) {
				byAddress = true;
				bank = (int)tk->data();
			} else {
				symbol = (std::string)tk->data();
				caseSensitiveSymbol = (std::string)tk->caseSensitiveText();
			}
		})) { return false; }
		if (byAddress) {
			if (!consume([&] (Token::Ptr tk) -> void {
				address = (int)tk->data();
				address += ctx.startAddress;
			})) { return false; }
		}

		return true;
	}

	/**< Retrieve children. */

	bool noChild(void) const {
		return _children.empty();
	}
	const Array &allChildren(void) const {
		return _children;
	}
	Array &allChildren(void) {
		return _children;
	}
	Ptr onlyChild(void) const {
		if (_children.size() != 1)
			return nullptr;
		if (!_children.front()->_children.empty())
			return nullptr;

		return _children.front();
	}
	Token::Array allTokens(bool includeComments) const {
		Token::Array result;
		for (const Token::Ptr &tk : _tokens) {
			if (includeComments) {
				result.push_back(tk);
			} else {
				if (tk->isNot(Token::Types::COMMENT))
					result.push_back(tk);
			}
		}

		return result;
	}
	Token::Ptr onlyToken(void) const {
		if (_tokens.empty())
			return nullptr;

		if (_tokens.size() == 1) {
			if (_tokens.front()->is(Token::Types::COMMENT))
				return nullptr;

			return _tokens.front();
		}

		for (int i = 1; i < (int)_tokens.size(); ++i) {
			const Token::Ptr &tk = _tokens[i];
			if (tk->isNot(Token::Types::COMMENT))
				return nullptr;
		}

		return _tokens.front();
	}
	Token::Ptr onlyTokenInOnlyChild(void) const {
		Ptr child = onlyChild();
		if (!child)
			return nullptr;

		return child->onlyToken();
	}
	Token::Ptr onlyTokenInNthChild(int index) const {
		if (index < 0 || index >= (int)_children.size())
			return nullptr;

		const Ptr &child = _children[index];
		if (!child)
			return nullptr;

		return child->onlyToken();
	}
	Token::Ptr firstTokenInThisOrChildren(void) const {
		if (!_tokens.empty())
			return _tokens.front();

		return firstTokenInChildren();
	}
	Token::Ptr firstTokenInChildren(void) const {
		if (_children.empty())
			return nullptr;

		for (const Ptr &child : _children) {
			Token::Ptr ret = child->firstTokenInThisOrChildren();
			if (ret)
				return ret;
		}

		return nullptr;
	}
	Token::Ptr firstNonNumericTokenInThisOrChildren(void) const {
		for (int i = 0; i < (int)_tokens.size(); ++i) {
			const Token::Ptr &tk = _tokens[i];
			if (tk->isNot(Token::Types::NUMBER) && tk->isNot(Token::Types::COMMENT))
				return tk;
		}

		return firstNonNumericTokenInChildren();
	}
	Token::Ptr firstNonNumericTokenInChildren(void) const {
		if (_children.empty())
			return nullptr;

		for (const Ptr &child : _children) {
			Token::Ptr ret = child->firstNonNumericTokenInThisOrChildren();
			if (ret)
				return ret;
		}

		return nullptr;
	}
	Token::Array flatOnlyTokens(const Range &range) const {
		// Prepare.
		auto flat_ = [&] (Token::Array &ret, int index) -> bool {
			if (index < 0 || index >= (int)_children.size())
				return false;

			const Ptr &child = _children[index];
			Token::Ptr tk = child->onlyToken();
			if (!tk)
				return false;

			ret.push_back(tk);

			return true;
		};

		// Generate a range of children.
		Token::Array result;
		if (range.first == range.second) {
			if (!flat_(result, range.first))
				return Token::Array();
		} else if (range.first < range.second) {
			for (int i = range.first; i <= range.second; ++i) {
				if (!flat_(result, i))
					return Token::Array();
			}
		} else /* if (range.first > range.second) */ {
			for (int i = range.first; i >= range.second; --i) {
				if (!flat_(result, i))
					return Token::Array();
			}
		}

		return result;
	}
	static bool flatNumericOrLabeledDestinationString(const Context::Stack &/* context */, const std::string &txt, int &page, Destination* dest /* nullable */) {
		page = -1;
		if (dest)
			*dest = Destination(Left<int>(0));

		const std::string txt_ = Text::trim(txt);
		const Text::Array parts = Text::split(txt_, ":");
		if (parts.size() == 1) { // Monad token destination.
			std::string tk = Text::trim(parts.front()); // Line number, page or label.
			if (tk.empty() || tk.front() != '#')
				return false;
			tk = tk.substr(1 /* after '#' */);
			if (!Text::fromString(tk, page))
				return false;
			if (dest)
				*dest = Destination(Left<int>(page));

			return true;
		} else if (parts.size() == 2) { // Triad tokens destination.
			std::string tk0 = Text::trim(parts.front()); // `#N`, page number.
			std::string tk2 = Text::trim(parts.back()); // Line number or label.

			do {
				if (tk0.empty() || tk0.front() != '#')
					break;
				tk0 = tk0.substr(1 /* after '#' */);
				if (!Text::fromString(tk0, page))
					break;

				if (dest) {
					int ln = -1;
					if (Text::fromString(tk2, ln))
						*dest = Destination(Left<int>(ln));
					else
						*dest = Destination(Right<std::string>(tk2));
				}

				return true;
			} while (false);
		}

		return false;
	}
	Token::Array flatNumericOrLabeledDestinationTokens(const Context::Stack &context, int &page, Destination* dest /* nullable */, int index, bool allowSingleTokenPage) const {
		const Context &ctx = context.top();

		Token::Array result;
		page = -1;
		if (dest)
			*dest = Destination(Left<int>(0));
		if (index < 0 || index >= (int)_children.size())
			return result;
		const Ptr &child = _children[index];
		if (!child)
			return result;

		Token::Array tks = child->allTokens(false);
		if (tks.size() == 1) { // Monad token destination.
			const Token::Ptr &tk = tks.front(); // Line number, page or label.
			if (tk->is(Token::Types::INTEGER)) {
				if (dest)
					*dest = Destination(Left<int>((int)tk->data()));
			} else if (tk->is(Token::Types::PAGE) && allowSingleTokenPage) {
				std::string pagestr = (std::string)tk->data();
				if (pagestr.empty() || pagestr.front() != '#')
					return result;
				pagestr = pagestr.substr(1 /* after '#' */);
				if (!Text::fromString(pagestr, page))
					return result;
				if (dest)
					*dest = Destination(Left<int>(page));
			} else if (tk->is(Token::Types::IDENTIFIER)) {
				const std::string id = (std::string)tk->data();
				const BuiltinTable::Entry* entry = ctx.builtins->find(id);
				if (dest) {
					if (entry && entry->type == BuiltinTable::Entry::Types::VALUE)
						*dest = Destination(Left<int>(entry->value));
					else
						*dest = Destination(Right<std::string>((std::string)tk->data()));
				}
			} else {
				if (dest)
					*dest = Destination(Right<std::string>((std::string)tk->data()));
			}

			std::swap(result, tks);
		} else if (tks.size() == 3) { // Triad tokens destination.
			const Token::Ptr &tk0 = tks[0]; // `#N`, page number.
			const Token::Ptr &tk1 = tks[1]; // `:`.
			const Token::Ptr &tk2 = tks[2]; // Line number or label.

			do {
				if (tk0->isNot(Token::Types::PAGE))
					break;
				std::string pagestr = (std::string)tk0->data();
				if (pagestr.empty() || pagestr.front() != '#')
					break;
				pagestr = pagestr.substr(1 /* after '#' */);
				if (!Text::fromString(pagestr, page))
					break;

				if (tk1->isNot(Token::Types::OPERATOR) || tk1->data() != ":")
					break;

				if (dest) {
					if (tk2->is(Token::Types::INTEGER))
						*dest = Destination(Left<int>((int)tk2->data()));
					else
						*dest = Destination(Right<std::string>((std::string)tk2->data()));
				}

				std::swap(result, tks);
			} while (false);
		}

		return result;
	}
	Token::Array flatNumericDestinationTokens(const Context::Stack &/* context */, int &page, Destination* dest /* nullable */, int index) const {
		Token::Array result;
		page = -1;
		if (dest)
			*dest = Destination(Left<int>(0));
		if (index < 0 || index >= (int)_children.size())
			return result;
		const Ptr &child = _children[index];
		if (!child)
			return result;

		Token::Array tks = child->allTokens(false);
		if (tks.size() == 1) { // Monad token destination.
			const Token::Ptr &tk = tks.front(); // Page.
			if (tk->is(Token::Types::INTEGER)) {
				return result;
			} else if (tk->is(Token::Types::PAGE)) {
				std::string pagestr = (std::string)tk->data();
				if (pagestr.empty() || pagestr.front() != '#')
					return result;
				pagestr = pagestr.substr(1 /* after '#' */);
				if (!Text::fromString(pagestr, page))
					return result;
			} else {
				return result;
			}

			std::swap(result, tks);
		} else if (tks.size() == 3) { // Triad tokens destination.
			const Token::Ptr &tk0 = tks[0]; // `#N`, page number.
			const Token::Ptr &tk1 = tks[1]; // `:`.
			const Token::Ptr &tk2 = tks[2]; // Layer number.

			do {
				if (tk0->isNot(Token::Types::PAGE))
					break;
				std::string pagestr = (std::string)tk0->data();
				if (pagestr.empty() || pagestr.front() != '#')
					break;
				pagestr = pagestr.substr(1 /* after '#' */);
				if (!Text::fromString(pagestr, page))
					break;

				if (tk1->isNot(Token::Types::OPERATOR) || tk1->data() != ":")
					break;

				if (tk2->is(Token::Types::INTEGER)) {
					if (dest)
						*dest = Destination(Left<int>((int)tk2->data()));
				} else {
					return result;
				}

				std::swap(result, tks);
			} while (false);
		}

		return result;
	}

	/**< Extract token. */

	template<typename T> bool isNumber(Context::Stack &context, int n, int &val, Token::Ptr* tkptr /* nullable */) const {
		Context &ctx = context.top();

		val = 0;
		if (tkptr)
			*tkptr = nullptr;

		if (n < 0 || n >= (int)_children.size())
			return false;

		const Ptr &child = _children[n];
		Token::Ptr tk = child->onlyToken();
		if (!tk)
			return false;

		Int data = 0;
		if (tk->is(Token::Types::IDENTIFIER)) {
			const std::string id = (std::string)tk->data();
			const BuiltinTable::Entry* entry = ctx.builtins->find(id);
			if (!entry || entry->type != BuiltinTable::Entry::Types::VALUE)
				return false;

			data = entry->value;
		} else {
			if (tk->isNot(Token::Types::INTEGER))
				return false;

			data = (Int)tk->data();
		}
		if (data < std::numeric_limits<T>::min() || data > std::numeric_limits<T>::max())
			return false;

		val = (int)data;
		if (tkptr)
			*tkptr = tk;

		return true;
	}
	bool isInt8(Context::Stack &context, int n, int &val, Token::Ptr* tkptr/* nullable */) const {
		return isNumber<Int8>(context, n, val, tkptr);
	}
	bool isUInt8(Context::Stack &context, int n, int &val, Token::Ptr* tkptr/* nullable */) const {
		return isNumber<UInt8>(context, n, val, tkptr);
	}
	bool isInt16(Context::Stack &context, int n, int &val, Token::Ptr* tkptr/* nullable */) const {
		return isNumber<Int16>(context, n, val, tkptr);
	}
	bool isUInt16(Context::Stack &context, int n, int &val, Token::Ptr* tkptr/* nullable */) const {
		return isNumber<UInt16>(context, n, val, tkptr);
	}
	bool isString(Context::Stack &context, int n, std::string* val, Token::Ptr* tkptr/* nullable */) const {
		(void)context;

		if (val)
			val->clear();
		if (tkptr)
			*tkptr = nullptr;

		if (n < 0 || n >= (int)_children.size())
			return false;

		const Ptr &child = _children[n];
		Token::Ptr tk = child->onlyToken();
		if (!(tk && tk->is(Token::Types::STRING)))
			return false;

		if (val)
			*val = (std::string)tk->data();
		if (tkptr)
			*tkptr = tk;

		return true;
	}
	bool isBuiltin(Context::Stack &context, const std::string &id) const {
		Context &ctx = context.top();

		if (!ctx.builtins)
			return false;

		const BuiltinTable::Entry* entry = ctx.builtins->find(id);
		if (!entry)
			return false;

		switch (entry->type) {
		case BuiltinTable::Entry::Types::INSTRUCTION:  // Fall through.
		case BuiltinTable::Entry::Types::VALUE:        // Fall through.
		case BuiltinTable::Entry::Types::USER_DEFINED:
			return true;
		default:
			return false;
		}
	}

	template<typename T> void replenishFormatted(Context::Stack &context, int offset) {
		const int size = Math::max((int)_children.size() - offset, 0);
		if (size == 0)
			return;

		if (isString(context, offset, nullptr, nullptr))
			return;

		std::string fmt;
		for (int i = 0; i < size; ++i) {
			fmt += "%d";
			if (i != size - 1)
				fmt += " ";
		}
		Token::Ptr tk(new Token());
		tk
			->type(Token::Types::STRING)
			->data(fmt);
		Ptr exp(new T());
		exp->concat(tk);
		while (exp->count() < count())
			exp->push();
		_children.insert(_children.begin() + offset, exp);
	}

	/**
	 * Output interfaces.
	 */

	/**< Emitting and filling functions that output opcodes, oprands and data. */

	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, const Asm &data) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		n += bytes->writeByte(data.opcode);
		const size_t m = bytes->peek();
		for (int i = 0; i < data.size; ++i)
			n += bytes->writeUInt8(0);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, const Op &data) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		n += bytes->writeByte(data.opcode);
		const size_t m = bytes->peek();
		for (int i = 0; i < data.size; ++i)
			n += bytes->writeUInt8(0);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, Int8 data) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		union {
			Int8 data;
			UInt8 bytes[1];
		} u;
		u.data = data;
		n += bytes->writeUInt8(u.bytes[0]);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, UInt8 data) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		n += bytes->writeUInt8(data);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, Int16 data, Endians endian = Endians::BIG) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		union {
			Int16 data;
			UInt8 bytes[2];
		} u;
		u.data = data;
		if (isDifferentEndian(endian))
			std::swap(u.bytes[0], u.bytes[1]);
		n += bytes->writeUInt8(u.bytes[0]);
		n += bytes->writeUInt8(u.bytes[1]);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, UInt16 data, Endians endian = Endians::BIG) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		union {
			UInt16 data;
			UInt8 bytes[2];
		} u;
		u.data = data;
		if (isDifferentEndian(endian))
			std::swap(u.bytes[0], u.bytes[1]);
		n += bytes->writeUInt8(u.bytes[0]);
		n += bytes->writeUInt8(u.bytes[1]);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, const std::string &data) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		n += bytes->writeString(data);
		n += bytes->writeUInt8(0);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}
	template<typename T> Byte* emit(Bytes::Ptr &bytes, Context::Stack &context, const T &data) {
		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		n += bytes->writeBytes((const Byte*)&data, sizeof(T));

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}

	Byte* fill(Byte* &args, const Op &data) {
		*args++ = data.opcode;

		return args;
	}
	Byte* fill(Byte* &args, Int8 data) const {
		union {
			Int8 data;
			UInt8 bytes[1];
		} u;
		u.data = data;
		*args++ = u.bytes[0];

		return args;
	}
	Byte* fill(Byte* &args, UInt8 data) const {
		*args++ = data;

		return args;
	}
	Byte* fill(Byte* &args, Int16 data, Endians endian = Endians::BIG) const {
		union {
			Int16 data;
			UInt8 bytes[2];
		} u;
		u.data = data;
		if (isDifferentEndian(endian))
			std::swap(u.bytes[0], u.bytes[1]);
		*args++ = u.bytes[0];
		*args++ = u.bytes[1];

		return args;
	}
	Byte* fill(Byte* &args, UInt16 data, Endians endian = Endians::BIG) const {
		union {
			UInt16 data;
			UInt8 bytes[2];
		} u;
		u.data = data;
		if (isDifferentEndian(endian))
			std::swap(u.bytes[0], u.bytes[1]);
		*args++ = u.bytes[0];
		*args++ = u.bytes[1];

		return args;
	}
	template<typename S, typename T> Byte* fill(Byte* &args, S data, Endians endian = Endians::BIG) const {
		union {
			S s;
			T t;
		} u;
		u.s = data;
		if (isDifferentEndian(endian)) {
			const int n = sizeof(u) / 2;
			for (int i = 0; i < n; ++i) {
				const int m = i;
				const int n = sizeof(u) - 1 - m;
				std::swap(((Byte*)&u)[m], ((Byte*)&u)[n]);
			}
		}
		for (int i = 0; i < sizeof(u); ++i) {
			*args++ = ((Byte*)&u)[i];
		}

		return args;
	}
	Byte* fill(const Bytes::Ptr &bytes, intptr_t offset, Int8 data) const {
		Byte* args = (Byte*)(bytes->pointer() + offset);

		return fill(args, data);
	}
	Byte* fill(const Bytes::Ptr &bytes, intptr_t offset, UInt8 data) const {
		Byte* args = (Byte*)(bytes->pointer() + offset);

		return fill(args, data);
	}
	Byte* fill(const Bytes::Ptr &bytes, intptr_t offset, Int16 data, Endians endian = Endians::BIG) const {
		Byte* args = (Byte*)(bytes->pointer() + offset);

		return fill(args, data, endian);
	}
	Byte* fill(const Bytes::Ptr &bytes, intptr_t offset, UInt16 data, Endians endian = Endians::BIG) const {
		Byte* args = (Byte*)(bytes->pointer() + offset);

		return fill(args, data, endian);
	}

	Byte* reserve(Bytes::Ptr &bytes, Context::Stack &context, int size) {
		if (size <= 0)
			return nullptr;

		Context &ctx = context.top();
		State &state = top();

		int n = 0;
		const size_t m = bytes->peek();
		for (int i = 0; i < size; ++i)
			n += bytes->writeUInt8(0);

		state.inRom.size += n;

		ctx.addressCursor += n;
		if (ctx.addressCursor >= ctx.bankSize) {
			++ctx.bank;
			ctx.addressCursor = 0;
		}

		Byte* result = bytes->pointer() + m;

		return result;
	}

	template<typename T> intptr_t prefill(const Bytes::Ptr &bytes, Byte* &args) const {
		const intptr_t result = (intptr_t)(args - bytes->pointer());
		args += sizeof(T);

		return result;
	}

	/**< Writing functions. */

	void write(Bytes::Ptr &bytes, Context::Stack &context, Generator_Void_Bool generator, bool allowTail, Error::Handler onError) {
		// Save the context and state.
		context.push(context.top());
		push();

		// Try to generate.
		constexpr const int TRY_FOR = 2;
		bool overflow = false;
		int i = 1;
		for (; i <= TRY_FOR; ++i) {
			// DOC: ROM SCHEMA.
			// Try for a few times:
			//   1. Write in the current bank, succeeds if the space is sufficient, otherwise
			//      skip the rest space of the current bank and try for another time
			//   2. Write for the second time, succeeds if the space is sufficient, otherwise
			//      the whole attempt fails since the second attempt is in a complete bank

			// Generate.
			const size_t size = bytes->count();
			generator(overflow);

			const bool sameBank = top().inRom.bank == context.top().bank;
			const int addressCursor = top().inRom.address + top().inRom.size;
			const int bankSize = context.top().bankSize;
			const bool isTail = !sameBank && addressCursor == bankSize;
			const bool sufficient = sameBank || (isTail && allowTail);
			if (sufficient) { // The current bank's space is sufficient.
				break;
			} else { // The current bank's space is insufficient.
				// The next attempt will be a far one (next bank).
				overflow = true;

				// Pop the old context and state.
				pop();
				context.pop();
				const int bank = context.top().bank;

				// Push new context and state.
				context.push(context.top());
				push();

				// Restore the bytes, emit a `VM_NEXT_BANK` instructon, fill in placeholder bytes to the old bank.
				const int expSize = (context.top().bank - context.top().startBank + 1) * context.top().bankSize;
				bytes->resize(size); // Restore the size.

				const Asm::Instructions &INSTRUCTIONS = *context.top().instructions;
				emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::NEXT_BANK]);

				const int n = expSize - (int)bytes->count();
				if (n > 0)
					bytes->writeBytes(COMPILER_INVALID_INSTRUCTION, (size_t)n);
				GBBASIC_ASSERT(n >= 0 && "Impossible.");

				// Set the top context and state to next bank.
				if (bank == context.top().bank)
					context.top().bank++;
				context.top().addressCursor = 0;
			}
		}
		if (i > TRY_FOR) {
			pop();
			context.pop();

			THROW_BANK_OVERFLOW(onError);
		}

		// Active the top context and state.
		set();
		const Context top_ = context.top();
		context.pop();
		context.top() = top_;

		// Put the code to ROM location correspondence.
		context.top().put(top().inCode, top().inRom);
	}
	void write(Bytes::Ptr &bytes, Context::Stack &context, Generator_Void_Void generator, bool allowTail, Error::Handler onError) {
		// Same as the above version, but doesn't care about the `overflow` parameter.
		write(
			bytes, context,
			[&] (bool /* overflow */) -> void {
				generator();
			},
			allowTail,
			onError
		);
	}
	void writeInteger(Bytes::Ptr &bytes, Context::Stack &context, const Token::Ptr &tk) {
		const int val = (int)tk->data();
		switch (tk->details().integerType) {
		case Token::IntegerTypes::UNSPECIFIED:
			if (val >= (Variant::Int)std::numeric_limits<Int8>::min() && val < 0) {
				// Is 8-bit signed integer.
				emit(bytes, context, (Int8)val);
			} else {
				// Is 8-bit unsigned integer.
				emit(bytes, context, (UInt8)val);
			}

			break;
		case Token::IntegerTypes::INT:
			// Is 16-bit signed integer.
			emit(bytes, context, (Int16)val, Endians::LITTLE);

			break;
		default:
			GBBASIC_ASSERT(false && "Not implemented.");

			break;
		}
	}
	bool writeBuiltin(Bytes::Ptr &bytes, Context::Stack &context, Asm::Types ref, const std::string &id, int index) {
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		COUNTER_GUARD(ctx, stk);

		if (!ctx.builtins)
			return false;

		const BuiltinTable::Entry* entry = ctx.builtins->find(id);
		if (!entry)
			return false;

		switch (entry->type) {
		case BuiltinTable::Entry::Types::INSTRUCTION: {
				const Asm::Types type = entry->instruction;
				switch (ref) {
				case Asm::Types::SET: {
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)type]);
						args = fill(args, (Int16)index);
					}

					return true;
				case Asm::Types::PUSH: {
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
						args = fill(args, (UInt16)0);

						args = emit(bytes, context, INSTRUCTIONS[(size_t)type]);
						args = fill(args, (Int16)ARG0);
					}

					return true;
				default:
					GBBASIC_ASSERT(false && "Not implemented.");

					return false;
				}
			}
		case BuiltinTable::Entry::Types::VALUE: // Fall through.
		case BuiltinTable::Entry::Types::USER_DEFINED: {
				const int value = entry->value;
				switch (ref) {
				case Asm::Types::SET: {
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
						args = fill(args, (Int16)value);
						args = fill(args, (Int16)index);
					}

					return true;
				case Asm::Types::PUSH: {
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
						args = fill(args, (UInt16)value);
					}

					return true;
				default:
					GBBASIC_ASSERT(false && "Not implemented.");

					return false;
				}
			}
		default:
			return false;
		}
	}
	void writeArrayIndices(Bytes::Ptr &bytes, Context::Stack &context, const Context::Array::Dimensions* dimensions, const Range &range, Error::Handler onError) {
		// Prepare.
		auto generate_ = [&] (int index, Counter &stk) -> void {
			// Prepare.
			if (index < 0 || index >= (int)_children.size())
				return;

			Context &ctx = context.top();
			const int indexBase = ctx.array ? ctx.array->base : 0;

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Emit the indices.
			const Ptr &child = _children[index];
			Token::Ptr simpleTk = child->onlyToken();
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				if (indexBase == 0)
					args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
				else
					args = fill(args, (UInt16)(BOOLEAN(simpleTk->data()) - indexBase));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				if (indexBase == 0)
					args = fill(args, (UInt16)(Int)simpleTk->data());
				else
					args = fill(args, (UInt16)((Int)simpleTk->data() - indexBase));
			} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
				const std::string id = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
				int data = 0;
				if (ramLocation) {
					data = ramLocation->address;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)data);
				} else {
					if (writeBuiltin(bytes, context, Asm::Types::PUSH, id, -1)) {
						// Do nothing.
					} else {
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
					}
				}
				if (indexBase != 0) {
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);

					Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT8]); INC_COUNTER(stk, 2);
					fill(args, (Int8)indexBase);

					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::SUB]); DEC_COUNTER(stk, 2);

					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);
				}
			} else { // EXPR.
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				child->generate(bytes, context, onError);
				if (indexBase != 0) {
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);

					Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT8]); INC_COUNTER(stk, 2);
					fill(args, (Int8)indexBase);

					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::SUB]); DEC_COUNTER(stk, 2);

					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);
				}
			}
		};

		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		COUNTER_GUARD(ctx, stk);

		// Generate a range of children.
		int c = 0;
		if (range.first == range.second) {
			generate_(range.first, stk);
			++c;
		} else if (range.first < range.second) {
			for (int i = range.first; i <= range.second; ++i) {
				generate_(i, stk);
				++c;
			}
		} else /* if (range.first > range.second) */ {
			for (int i = range.first; i >= range.second; --i) {
				generate_(i, stk);
				++c;
			}
		}

		// FEAT: OPTIMIZATION.
		// Optimized for array with only 1 dimension.
		if (c == 1)
			return;

		// Generate the calculation of the index.
		VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

		{
			// Prepare.
			int offset = 0;

			// `result = 0`.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)(Int)0);
			const int argR = ARG1;
			++offset;

			// `factor = 1`.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)(Int)1);
			const int argF = ARG0;
			++offset;

			// Iterate all the dimensions.
			for (int i = 0; i < c; ++i) {
				// `result = result + n[i] * factor`.
				const int argN = i - c - offset;

				emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);
				{
					Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::REF]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)argN, ctx.expression.endian);
					args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::REF]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)argF, ctx.expression.endian);
					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::MUL]); DEC_COUNTER(stk, 2);
					args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::REF]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)argR, ctx.expression.endian);
					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::ADD]); DEC_COUNTER(stk, 2);
				}
				emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);

				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
				args = fill(args, (Int16)ARG0);
				args = fill(args, (Int16)(argR - 1));

				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
				args = fill(args, (UInt8)1);

				// `factor = factor * dimensions[i]`.
				emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);
				{
					Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT16]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)dimensions->bounds[i], ctx.expression.endian);
					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::MUL]); DEC_COUNTER(stk, 2);
				}
				emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);
			}

			// Pop `factor`.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
			args = fill(args, (UInt8)1);
		}

		// Pop `n[]`.
		Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP_1]); DEC_COUNTER(stk, 2 * c);
		args = fill(args, (UInt8)c);
	}
	void writeFormatted(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Asm::Types instruction, const Range &range, Generator_Void_Byteptr opcodes, Generator_Void_Void generate, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		auto format = [] (std::wstring &escaped, const wchar_t* fmt) -> int {
			int result = 0;
			escaped.clear();

			const wchar_t* wptr = fmt;
			while (*wptr) {
				if (*wptr == GLYPH_ESCAPE_PLACEHOLDER) {
					escaped.push_back(*wptr);

					switch (*++wptr) {
					case GLYPH_ESCAPE_INT: // Fall through.
					case GLYPH_ESCAPE_HEX: // Fall through.
					case GLYPH_ESCAPE_CHAR:
						++result;

						break;
					case GLYPH_ESCAPE_PERCENT:
						++wptr;

						// Fall through.
					default:
						continue;
					}
				} else if (*wptr == GLYPH_ESCAPE_SPECIAL) {
					switch (*++wptr) {
					case GLYPH_ESCAPE_UNICODE: {
							std::wstring wstr;
							wptr = escapeUnicode(wptr, wstr);

							escaped += wstr;

							++wptr;

							continue;
						}
					case GLYPH_ESCAPE_STACK: // Fall through.
					case GLYPH_ESCAPE_BACKSLASH:
						escaped.push_back('\\');
						escaped.push_back(*wptr);

						++wptr;

						// Fall through.
					default:
						continue;
					}
				} else {
					escaped.push_back(*wptr);

					++wptr;

					continue;
				}

				escaped.push_back(*wptr);

				++wptr;
			}

			return result;
		};

		// Check the children.
		const int size = Math::max((int)_children.size() - range.second, 0);
		if (size == 0) {
			THROW_TOO_FEW_ARGUMENTS(onError);
		} else if (size <= 255) {
			Token::Ptr tk = nullptr;
			auto count = [&] (int index) -> int {
				std::string fmt;
				if (isString(context, index, &fmt, &tk) && tk) {
					const std::wstring wfmt = Unicode::toWide(fmt);
					std::wstring wescaped;
					const int n = format(wescaped, wfmt.c_str());
					const std::string escaped = Unicode::fromWide(wescaped);
					if (tk->data() != escaped) {
						tk->text("\"" + escaped + "\"");
						tk->data(escaped);
					}

					return n;
				}

				return -1;
			};
			int n = 0;
			if (range.first == range.second) {
				const int m = count(range.first);
				if (m >= 0) { n += m; }
				else { CHECK_FOR_STRING(onError, tk); }
			} else if (range.first < range.second) {
				for (int i = range.first; i <= range.second; ++i) {
					const int m = count(i);
					if (m >= 0) { n += m; }
					else { CHECK_FOR_STRING(onError, tk); }
				}
			} else /* if (range.first > range.second) */ {
				for (int i = range.first; i >= range.second; --i) {
					const int m = count(i);
					if (m >= 0) { n += m; }
					else { CHECK_FOR_STRING(onError, tk); }
				}
			}

			if (size - 1 < n) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (size - 1 > n) {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}
		} else {
			THROW_TOO_MANY_ARGUMENTS(onError);
		}

		// Emit the evaluations.
		do {
			VAR_GUARD(ctx.expect.lnno, false);
			VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.
			VAR_GUARD(
				ctx.expression.category,
				Context::Expression::Categories::EVALUATION
			);
			VAR_GUARD(ctx.expression.alwaysEvaluate, true);
			VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

			if (size >= 2)
				Node::generate(bytes, context, Range(1 + range.first, size - 1 + range.second), onError);
		} while (false);

		// Emit the specific instruction.
		Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)instruction]);
		if (opcodes)
			opcodes(args);

		// Emit the consts, variables, and slots of evaluation.
		do {
			VAR_GUARD(ctx.expect.lnno, false);
			VAR_GUARD(
				ctx.expression.category,
				Context::Expression::Categories::CONST |
				Context::Expression::Categories::VARIABLE |
				Context::Expression::Categories::SLOT
			);
			VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

			if (size >= 2)
				Node::generate(bytes, context, Range(1 + range.first, size - 1 + range.second), onError); // Emit the arguments.
			generate(); // Emit the string.
		} while (false);
		const int slotCount = ctx.expression.slotCount();
		if (slotCount > 0) {
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * slotCount);
			args = fill(args, (UInt8)slotCount);
		}
	}
	void writeFormatted(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Asm::Types instruction, int offset, Generator_Void_Byteptr opcodes, Generator_Void_Void generate, Error::Handler onError) {
		writeFormatted(bytes, context, stk, instruction, Range(offset), opcodes, generate, onError);
	}
	void writeFormatted(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Asm::Types instruction, const Range &range, const bool* newLine, Error::Handler onError) {
		writeFormatted(
			bytes, context,
			stk,
			instruction, range,
			[&] (Byte* &args) -> void {
				const int size = Math::max((int)_children.size() - range.second, 0);
				args = fill(args, (UInt8)(size - 1));
				if (newLine)
					args = fill(args, (UInt8)BOOLEAN(*newLine));
			},
			[&] (void) -> void {
				Node::generate(bytes, context, range, onError);
			},
			onError
		);
	}
	void writeFormatted(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Asm::Types instruction, int offset, const bool* newLine, Error::Handler onError) {
		writeFormatted(bytes, context, stk, instruction, Range(offset), newLine, onError);
	}
	void writeRightHand(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Generator_Void_Void generate, int toPop, bool toPush, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Emit a `VM_PUSH` instruction to reserve for the return value temporarily.
		const bool withDeclaring = ctx.declaration.declaring != -1;
		if (toPush && !withDeclaring) {
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)0);
		}

		// Emit a `VM_PUSH` instruction to allocate for the return value for outer declaration.
		if (toPush && withDeclaring) {
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)0);
		}

		// Emit the arguments and instruction.
		generate();

		// Emit a `VM_POP` instruction to remove the temporary value of the arguments.
		if (toPop > 0) {
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * toPop);
			args = fill(args, (UInt8)toPop);
		}

		// Emit a `VM_POP` instruction if isn't emitting during a declration to remove the temporary value.
		if (toPush && !withDeclaring) {
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
			args = fill(args, (UInt8)1);
		}
	}
	void writeRoutine(Bytes::Ptr &bytes, Context::Stack &context, Asm::Types instruction, Generator_Void_Byteptr opcodes, int argn, Generator_Int_Counter argf, Generator_Void_Counter argi, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Check the children.
		if (argn >= 0) {
			if ((int)_children.size() == argn) {
				// Do nothing.
			} else if ((int)_children.size() <= argn - 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (!argi) {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}
		}

		// Set the stack footprint guard.
		VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
		COUNTER_GUARD(ctx, stk);

		// Set the expression slot guard.
		VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

		// Emit the arguments.
		int dec = (int)_children.size();
		if (argf) {
			dec = argf(stk);
		} else {
			if (!_children.empty())
				writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);
		}

		// Emit the specific instruction.
		Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)instruction]); DEC_COUNTER(stk, 2 * dec);
		if (opcodes)
			opcodes(args);
		if (argi)
			argi(stk);

		// Check the stack footprint.
		CHECK_COUNTER(ctx, onError);
	}
	void writeRoutine(Bytes::Ptr &bytes, Context::Stack &context, Asm::Types instruction, int op0, int argn, Generator_Int_Counter argf, Generator_Void_Counter argi, Error::Handler onError) {
		writeRoutine(
			bytes, context,
			instruction,
			[&] (Byte* &args) -> void {
				if (op0 >= 0) // Is not `ASSET_SOURCE_IGNORED`.
					args = fill(args, (UInt8)op0);
			},
			argn, argf, argi,
			onError
		);
	}
	void writeRoutine(Bytes::Ptr &bytes, Context::Stack &context, Asm::Types instruction, int op0, int op1, int argn, Generator_Int_Counter argf, Generator_Void_Counter argi, Error::Handler onError) {
		writeRoutine(
			bytes, context,
			instruction,
			[&] (Byte* &args) -> void {
				args = fill(args, (UInt8)op1);
				args = fill(args, (UInt8)op0);
			},
			argn, argf, argi,
			onError
		);
	}
	void writeFunction(Bytes::Ptr &bytes, Context::Stack &context, Asm::Types instruction, Generator_Void_Byteptr opcodes, int argn, Generator_Int_Counter argf, Generator_Void_Counter argi, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Check the children.
		if (argn >= 0) {
			if ((int)_children.size() == argn) {
				// Do nothing.
			} else if ((int)_children.size() <= argn - 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (!argi) {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}
		}

		// Set the stack footprint guard.
		COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
		COUNTER_GUARD(ctx, stk);

		// Set the expression slot guard.
		VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

		// Emit the right hand value.
		const bool withDeclaring = ctx.declaration.declaring != -1;
		writeRightHand(
			bytes, context, stk,
			[&] (void) -> void {
				// Emit the arguments.
				int dec = (int)_children.size();
				if (argf) {
					dec = argf(stk);
				} else {
					if (!_children.empty())
						writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);
				}

				// Emit the specific instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)instruction]); DEC_COUNTER(stk, 2 * dec); INC_COUNTER(stk, 2);
				if (opcodes)
					opcodes(args);
				if (argi)
					argi(stk);
			}, withDeclaring ? 0 : 1, false,
			onError
		);

		// Check the stack footprint.
		CHECK_COUNTER(ctx, onError);
	}
	void writeFunction(Bytes::Ptr &bytes, Context::Stack &context, Asm::Types instruction, int op0, int argn, Generator_Int_Counter argf, Generator_Void_Counter argi, Error::Handler onError) {
		writeFunction(
			bytes, context,
			instruction,
			[&] (Byte* &args) -> void {
				if (op0 >= 0)
					args = fill(args, (UInt8)op0);
			},
			argn, argf, argi,
			onError
		);
	}
	void writeChildren(Bytes::Ptr &bytes, Context::Stack &context, const Range &range, Counter &stk, Error::Handler onError) {
		// Prepare.
		auto write_ = [&] (int index) -> void {
			Context &ctx = context.top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			const Ptr &child = _children[index];
			Token::Ptr simpleTk = child->onlyToken();
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
				const std::string id = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
				int data = 0;
				const int macroParamIndex = ctx.expression.macroFunctions ? ctx.expression.macroFunctions->indexOf(id) : -1; // FEAT: MACRO.
				if (ramLocation) {
					data = ramLocation->address;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)data);
				} else if (macroParamIndex != -1) {
					data = macroParamIndex - ctx.expression.macroFunctions->count();
					if (ctx.expression.temporaries)
						data -= (int)ctx.expression.temporaries->size();

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)data);
				} else {
					if (writeBuiltin(bytes, context, Asm::Types::PUSH, id, -1)) {
						// Do nothing.
					} else {
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
					}
				}
			} else { // EXPR.
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(ctx.declaration.declaring, top().inRam.address);
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				Node::generate(bytes, context, Range(index), onError);
			}
		};

		// Generate a range of children.
		if (range.first == range.second) {
			write_(range.first);
		} else if (range.first < range.second) {
			for (int i = range.first; i <= range.second; ++i)
				write_(i);
		} else /* if (range.first > range.second) */ {
			for (int i = range.first; i >= range.second; --i)
				write_(i);
		}
	}
	void writePlaceholder(Bytes::Ptr &bytes, Context::Stack &context, int rest) {
		rest = Math::max(rest, 0);

		push();

		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		const int bank = ctx.bank;
		(void)bank;
		int size = ctx.bankSize - ctx.addressCursor;
		size = Math::max(size - rest, 0);
		for (int i = 0; i < size; ++i)
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::NOP]);

		if (rest == 0) {
			GBBASIC_ASSERT((ctx.bank == bank + 1) && "Wrong data.");
			GBBASIC_ASSERT(ctx.addressCursor == 0 && "Wrong data.");
		}

		pop();
	}

	/**
	 * Auxiliary interfaces.
	 */

	/**< Compatibility checking. */

	bool usingColoredFeature(const Context &ctx, Error::Handler onError, Token::Ptr tk = nullptr) {
#if REPORT_MISUSING_COLORED_FEATURE_ENABLED
		if ((ctx.compatibility & GBBASIC::Options::Strategies::Compatibilities::COLORED) != GBBASIC::Options::Strategies::Compatibilities::NONE)
			return true;

		THROW_USING_COLORED_FEATURE_WITH_CLASSIC_CARTRIDGE_ENABLE_COLORED_FEATURE_IN_PROJECT_PROPERTY(onError, tk);

		return false;
#else /* REPORT_MISUSING_COLORED_FEATURE_ENABLED */
		(void)ctx;
		(void)onError;
		(void)tk;

		return true;
#endif /* REPORT_MISUSING_COLORED_FEATURE_ENABLED */
	}
	bool usingExtensionFeature(const Context &ctx, Error::Handler onError, Token::Ptr tk = nullptr) {
#if REPORT_MISUSING_EXTENSION_FEATURE_ENABLED
		if ((ctx.compatibility & GBBASIC::Options::Strategies::Compatibilities::EXTENSION) != GBBASIC::Options::Strategies::Compatibilities::NONE)
			return true;

		THROW_USING_EXTENSION_FEATURE_WITH_REGULAR_CARTRIDGE_ENABLE_EXTENSION_FEATURE_IN_PROJECT_PROPERTY(onError, tk);

		return false;
#else /* REPORT_MISUSING_EXTENSION_FEATURE_ENABLED */
		(void)ctx;
		(void)onError;
		(void)tk;

		return true;
#endif /* REPORT_MISUSING_EXTENSION_FEATURE_ENABLED */
	}

	/**< Error raisers. */

	void throwAmbiguousProgramPoint(Error::Handler onError, const Text::Array &options, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		std::string msg = "Ambiguous program point:\n  ";
		for (int i = 0; i < (int)options.size(); ++i) {
			msg += options[i];
			if (i != (int)options.size() - 1)
				msg += ",\n  ";
		}
		const Error err(msg, false);
		onError(err, err.format(), tk->begin());
	}
	void throwArgumentCountDoesNotMatch(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Argument count does not match", false);
		onError(err, err.format(), tk->begin());
	}
	void throwAssetIsDefinedAsAnActorButUsedAsAProjectile(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Asset is defined as an actor, but used as a projectile", false);
		onError(err, err.format(), tk->begin());
	}
	void throwAssetIsDefinedAsAProjectileButUsedAsAnActor(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Asset is defined as a projectile, but used as an actor", false);
		onError(err, err.format(), tk->begin());
	}
	void throwAssetPageOutOfBounds(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Asset page out of bounds", false);
		onError(err, err.format(), tk->begin());
	}
	void throwBankOverflow(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Bank overflow", false);
		onError(err, err.format(), tk->begin());
	}
	void throwDataSectionOverflow(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Data section overflow", false);
		onError(err, err.format(), tk->begin());
	}
	void throwDuplicateDestination(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Duplicate destination \"{0}\"", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwHeapOverflow(Error::Handler onError, Token::Ptr tk = nullptr, bool isWarning = true) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Heap overflow", isWarning); // Warning.
		onError(err, err.format(), tk->begin());
	}
	void throwIdHasBeenAlreadyDeclared(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("ID \"{0}\" has been already decleared", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwIdHasNotBeenDeclared(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("ID \"{0}\" has not been decleared", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwIdHasNotBeenDeclaredDidYouMean(Error::Handler onError, Token::Ptr tk, const std::string &fuzzy) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("ID \"{0}\" has not been decleared, did you mean \"{1}\"", false);
		onError(err, err.format({ tk->caseSensitiveText(), fuzzy }), tk->begin());
	}
	void throwInvalidAssetPoint(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid asset point", false);
		onError(err, err.format(), tk->begin());
	}
	void throwInvalidAssetPointDidYouMean(Error::Handler onError, Token::Ptr tk, const std::string &fuzzy) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid asset point, did you mean \"{0}\"", false);
		onError(err, err.format({ fuzzy }), tk->begin());
	}
	void throwInvalidColor(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid color", false);
		onError(err, err.format(), tk->begin());
	}
	void throwInvalidDataPoint(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid data point", false);
		onError(err, err.format(), tk->begin());
	}
	void throwInvalidDestination(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid destination \"{0}\"", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwInvalidExpression(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		if (tk->caseSensitiveText().length() >= 2 && Text::startsWith(tk->caseSensitiveText(), "\"", false) && Text::endsWith(tk->caseSensitiveText(), "\"", false)) {
			const Error err("Invalid expression {0}", false);
			onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
		} else {
			const Error err("Invalid expression \"{0}\"", false);
			onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
		}
	}
	void throwInvalidGlyph(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid glyph", false);
		onError(err, err.format(), tk->begin());
	}
	void throwInvalidNativeSymbol(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid native symbol", false);
		onError(err, err.format(), tk->begin());
	}
	void throwInvalidNativeSymbolDidYouMean(Error::Handler onError, Token::Ptr tk, const std::string &fuzzy) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid native symbol, did you mean \"{0}\"", false);
		onError(err, err.format({ fuzzy }), tk->begin());
	}
	void throwInvalidOperation(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid operation \"{0}\"", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwInvalidProgramPoint(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid program point", false);
		onError(err, err.format(), tk->begin());
	}
	void throwInvalidSyntax(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Invalid syntax", false);
		onError(err, err.format(), tk->begin());
	}
	void throwMemoryLeak(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Memory leak", true); // Warning.
		onError(err, err.format(), tk->begin());
	}
	void throwNoData(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("No data", false);
		onError(err, err.format(), tk->begin());
	}
	void throwNotImplemented(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Not implemented", false);
		onError(err, err.format(), tk->begin());
	}
	void throwNotSupported(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Not supported", false);
		onError(err, err.format(), tk->begin());
	}
	void throwObsoleteSyntax(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Obsolete syntax \"{0}\"", true); // Warning.
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwOutOfBounds(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Out of bounds", false);
		onError(err, err.format(), tk->begin());
	}
	void throwStackOverflow(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Stack overflow", true); // Warning.
		onError(err, err.format(), tk->begin());
	}
	void throwTableIsNotInitialized(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Table is not initialized", false);
		onError(err, err.format(), tk->begin());
	}
	void throwTooFewArguments(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Too few arguments \"{0}\"", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwTooManyArguments(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Too many arguments \"{0}\"", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwTypeExpected(Error::Handler onError, const std::string &y, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const std::string msg = y + " expected \"{0}\"";
		const Error err(msg, false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwUnexpectedOperator(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const std::string msg = "Unexpected operator \"{0}\"";
		const Error err(msg, false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwUnknownGlyph(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Unknown glyph", false);
		onError(err, err.format(), tk->begin());
	}
	void throwUnknownGlyphsInFontAsset(Error::Handler onError, const Text::Array &glyphs, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		std::string msg;
		if (glyphs.size() <= 1)
			msg = "Unknown glyph in font asset:\n  ";
		else
			msg = "Unknown glyphs in font asset:\n  ";
		for (int i = 0; i < (int)glyphs.size(); ++i) {
			msg += "\"" + glyphs[i] + "\"";
			if (i != (int)glyphs.size() - 1) {
				if ((i + 1) % 8 == 0)
					msg += ",\n  ";
				else
					msg += ", ";
			}
		}
		const Error err(msg, true);
		onError(err, err.format(), tk->begin());
	}
	void throwUnknownType(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Unknown type \"{0}\"", false);
		onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());
	}
	void throwUsingColoredFeatureWithClassicCartridgeEnableColoredFeatureInProjectProperty(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Using colored feature with classic cartridge.\n  Enable colored feature in project property?", true); // Warning.
		onError(err, err.format(), tk->begin());
	}
	void throwUsingExtensionFeatureWithRegularCartridgeEnableExtensionFeatureInProjectProperty(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Using extension feature with regular cartridge.\n  Enable extension feature in project property?", true); // Warning.
		onError(err, err.format(), tk->begin());
	}
	void throwUsingFileFeatureButCartridgeDoesNotHaveThisFunctionEnabled(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Using file feature but cartridge does not have this function enabled", true); // Warning.
		onError(err, err.format(), tk->begin());
	}
	void throwUsingRtcFeatureButCartridgeDoesNotHaveThisFunctionEnabled(Error::Handler onError, Token::Ptr tk = nullptr) const {
		if (tk == nullptr)
			tk = firstNonNumericTokenInThisOrChildren();
		const Error err("Using RTC feature but cartridge does not have this function enabled", true); // Warning.
		onError(err, err.format(), tk->begin());
	}

	/**< Dump functions. */

	std::string dump(int depth, const char* name) const {
		std::string result;

		result += Text::repeat(" ", depth);
		result += "(";
		if (name) {
			result += name;
			if (!_tokens.empty())
				result += ": ";
		}
		for (int i = 0; i < (int)_tokens.size(); ++i) {
			const Token::Ptr &tk = _tokens[i];
			result += tk->dump();
			if (i != (int)_tokens.size() - 1)
				result += ", ";
		}
		result += ")";
		result += "\n";

		if (!_children.empty()) {
			result += Text::repeat(" ", depth);
			result += "[";
			result += "\n";
			{
				for (const Ptr &child : _children)
					result += child->dump(depth + 1);
			}
			result += Text::repeat(" ", depth);
			result += "]";
			result += "\n";
		}

		return result;
	}
	using INode::dump;
};

const int Node::Context::Declaration::ARGUMENT = std::numeric_limits<int>::max();

IMPLEMENT_ENUM_OPERATORS(Node::Context::Expression::Categories)

/* ===========================================================================} */

/*
** {===========================================================================
** Program and code page
*/

class NodeProgram : public Node {
public:
	NodeProgram() {
	}
	virtual ~NodeProgram() override {
	}

	NODE_TYPE(Types::PROGRAM)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		int errs = 0;
		auto onError_ = [onError, &errs] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
			onError(err, msg, loc);
			++errs;
		};

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// DOC: ROM SCHEMA.
		// Generate data sequence, code and glyph data, in the order of:
		//   `DATA` sequence: cannot be larger than a bank
		//   compiled code: typically single statement cannot be larter than a bank, all compiled results can be larger than a bank
		//   glyph data: all glyphs of a font can be larger than a bank
		{
			// Emit the data section.
			emitDataSection(bytes, context, onError_); CHECK(errs);

			// Generate all the pages.
			Node::generate(bytes, context, onError);

			// Emit the glyph assets.
			emitGlyphSection(bytes, context, onError_); CHECK(errs);
		}

		// Finish.
		GBBASIC_ASSERT(_state.size() == 1 && "Corrupt stack.");
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		int errs = 0;
		auto onError_ = [onError, &errs] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
			onError(err, msg, loc);
			++errs;
		};

		// Determine the location in the ROM.
		const int bank    = state.inRom.bank    = ctx.bank;
		const int address = state.inRom.address = ctx.addressCursor;
		const int size    = state.inRom.size    = 0;
		(void)bank;
		(void)address;
		(void)size;

		// Post all the pages.
		Node::post(bytes, context, onError);

		// Finish.
		GBBASIC_ASSERT(
			bank    == state.inRom.bank    && bank    == ctx.bank          &&
			address == state.inRom.address && address == ctx.addressCursor &&
			size    == state.inRom.size    &&
			"Corrupt ROM."
		);
		GBBASIC_ASSERT(_state.size() == 1 && "Corrupt stack.");
	}

	virtual Abstract abstract(void) const override {
		return abstract("PROG");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PROG");
	}
	using Node::dump;

private:
	void emitDataSection(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		if (!ctx.data || ctx.data->empty())
			return;

		const Context::Data::Value::Array &values = ctx.data->values;
		const size_t sizeInBytes = ctx.data->size();

		// Emit a `VM_JUMP_FAR` instruction to skip the data section and jump to the execution area.
		Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP_FAR]);
		const intptr_t offset0 = prefill<UInt16>(bytes, args);
		const intptr_t offset1 = prefill<UInt8>(bytes, args);

		// Check whether the data section overflows.
		const bool dataOverflow = ctx.addressCursor + (int)sizeInBytes > ctx.bankSize;
		if (dataOverflow) { THROW_DATA_SECTION_OVERFLOW(onError); }

		// Emit the data.
		for (int i = 0; i < (int)values.size(); ++i) {
			const Context::Data::Value &data = values.at(i);
			switch (data.type) {
			case Token::IntegerTypes::UNSPECIFIED:
				if (data.value >= (Variant::Int)std::numeric_limits<Int8>::min() && data.value < 0) {
					// Is 8-bit signed integer.
					emit(bytes, context, (Int8)data.value);
				} else {
					// Is 8-bit unsigned integer.
					emit(bytes, context, (UInt8)data.value);
				}

				break;
			case Token::IntegerTypes::INT:
				// Is 16-bit signed integer.
				emit(bytes, context, (Int16)data.value, Endians::LITTLE);

				break;
			default:
				GBBASIC_ASSERT(false && "Not implemented.");

				break;
			}
		}

		// Fill in the address.
		const int addressA = ctx.startAddress + ctx.addressCursor;
		fill(bytes, offset0, (UInt16)addressA);
		fill(bytes, offset1, (UInt8)ctx.bank);
	}
	void emitGlyphSection(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		FontAssets &fonts = ctx.assets->fonts;

		// Emit.
		// DOC: GLYPHS.
		// Writing layout:
		//   the header
		//     the font option
		//     the font size
		//   the arbitraries
		//     the arbitrary count
		//     the arbitraries in glyphs
		//   the glyphs (can be filled into multiple banks)
		//     the pixels
		//     ...
		Bytes::Ptr buf(Bytes::create());
		const int before = (int)bytes->count();
		for (int i = 0; i < fonts.count(); ++i) {
			// Prepare.
			FontAssets::Entry* font = fonts.get(i);
			if (!font) { THROW_INVALID_ASSET_POINT(onError); }
			const int bankSize = context.top().bankSize;

			if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
			int refCount = 0;
			if (!ctx.pipeline->lookup(AssetsBundle::Categories::FONT, i, refCount))
				refCount = 0;

			// Check whether the font is in use.
			const int arbCount = refCount > 0 ?
				Math::min(font->arbitrary.count(), (int)std::numeric_limits<UInt8>::max() + 1) :
				0;
			if (font->glyphs.count() == 0 && arbCount == 0)
				continue;

			// Determine the start location.
			int diff = (ctx.addressCursor + ((int)sizeof(UInt8) + (int)sizeof(glyph_t) * arbCount)) - bankSize;
			if (diff > 0) {
				diff = bankSize - ctx.addressCursor;
				for (int k = 0; k < diff; ++k) {
					// The current bank is insufficient, ignore the rest space of it.
					emit(bytes, context, (UInt8)COMPILER_INVALID_INSTRUCTION);
				}
			}
			const int addressA = ctx.startAddress + ctx.addressCursor;
			font->bank = ctx.bank;
			font->address = addressA;

			// Emit the header.
			const glyph_option_t opt(
				font->isTwoBitsPerPixel,
				font->preferFullWord,
				font->preferFullWordForNonAscii,
				font->inverted
			);
			emit<glyph_option_t>(bytes, context, opt); // Emit the option.
			emit(bytes, context, (UInt8)font->size.y); // Emit the font size.

			// Emit the arbitrary.
			emit(bytes, context, (UInt8)arbCount); // Emit the arbitrary count.
			const intptr_t offset = (intptr_t)bytes->peek();
			for (int j = 0; j < arbCount; ++j) {
				const glyph_t g;
				emit<glyph_t>(bytes, context, g); // Prefill an arbitrary.

				const Font::Codepoint cp = font->arbitrary[j];
				if (!font->glyphs.find(cp)) {
					const GlyphTable::Entry glyph(cp);
					font->glyphs.add(glyph);
					font->glyphs.sort();
				}
			}

			// Emit the glyphs.
			for (int j = 0; j < font->glyphs.count(); ++j) {
				// Prepare.
				GlyphTable::Entry &glyph = *font->glyphs.get(j);

				// Bake a glyph to bits.
				int bytes_ = 0;
				if (!FontAssets::bake(*font, glyph, buf.get(), &bytes_)) {
					// Do nothing.
				}

				// Determine the glyph's location in ROM.
				int diff = (ctx.addressCursor + bytes_) - bankSize;
				if (diff > 0) {
					diff = bankSize - ctx.addressCursor;
					for (int k = 0; k < diff; ++k) {
						// The current bank is insufficient, ignore the rest space of it.
						emit(bytes, context, (UInt8)COMPILER_INVALID_INSTRUCTION);
					}
				}
				const int addressA = ctx.startAddress + ctx.addressCursor;
				glyph.address = addressA;
				glyph.bank = ctx.bank;

				// Fill the glyph's pixels.
				for (int k = 0; k < (int)buf->count(); ++k) {
					const Byte b = buf->get(k);
					emit(bytes, context, (UInt8)b); // Emit one byte.
				}
				buf->clear();
			}

			// Refill the arbitrary.
			glyph_t* arbitrary = (glyph_t*)(bytes->pointer() + offset);
			for (int j = 0; j < arbCount; ++j) {
				const Font::Codepoint cp = font->arbitrary[j];
				glyph_t &g = arbitrary[j];
				const GlyphTable::Entry* entry = font->glyphs.find(cp);
				GBBASIC_ASSERT(entry && "Impossible.");
				g = glyph_t((UInt8)entry->bank, (UInt16)entry->address, (UInt8)entry->size() /* in pixels */); // Fill it.
			}

			// Clear temporary data.
			font->cleanupSubstitution();
		}
		const int after = (int)bytes->count();
		const int diffSize = after - before;
		GBBASIC_ASSERT(diffSize >= 0 && "Impossible.");
		Pipeline::Size &effectiveSize = ctx.pipeline->effectiveSize();
		effectiveSize.addFont(diffSize);
	}
};

class NodePage : public Node {
private:
	int _page = -1;

public:
	NodePage() {
	}
	virtual ~NodePage() override {
	}

	NODE_TYPE(Types::PAGE)

	virtual void options(const IDictionary::Ptr &options) override {
		_page = (int)options->get("page");
	}

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Determine the location in code.
		state.inCode = SourceLocation(_page);

		// Generate all the children.
		Node::generate(bytes, context, onError);

		// Emit a `VM_HALT` instructon.
#if HALT_AT_PAGE_END_ENABLED
		emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::HALT]);
#endif /* HALT_AT_PAGE_END_ENABLED */

		// Finish.
		++ctx.currentPage;

		GBBASIC_ASSERT(_state.size() == 1 && "Corrupt stack.");
	}

	virtual Abstract abstract(void) const override {
		const std::string name = "#" + Text::toString(_page);

		return abstract("#", name.c_str());
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		const std::string name = "#" + Text::toString(_page);

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Expression and evaluation
*/

class NodeExpression : public Node {
public:
	NodeExpression() {
	}
	virtual ~NodeExpression() override {
	}

	NODE_TYPE(Types::EXPRESSION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		if (ctx.expect.lnno) {
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
			})) { THROW_INVALID_SYNTAX(onError); }
		}

		// Generate.
		COUNTER_GUARD(ctx, stk);
		do {
			// Try to generate slot.
			if (ctx.expression.allow(Context::Expression::Categories::SLOT)) {
				const int slot = ctx.expression.getSlot();
				if (slot) {
					generateSlot(bytes, context, slot, stk, onError);

					break;
				}
			}

			// Try to generate const and variable.
			if (ctx.expression.allow(Context::Expression::Categories::CONST | Context::Expression::Categories::VARIABLE)) {
				generateConstOrVariable(bytes, context, stk, onError);

				break;
			}

			// Try to generate evaluation.
			if (ctx.expression.allow(Context::Expression::Categories::EVALUATION)) {
				generateEvaluation(bytes, context, stk, onError);

				break;
			}
		} while (false);
	}

	virtual Abstract abstract(void) const override {
		return abstract("EXPR");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "EXPR");
	}
	using Node::dump;

private:
	void generateSlot(Bytes::Ptr &bytes, Context::Stack &context, int index, Counter &stk, Error::Handler onError) {
		// Prepare.
		(void)stk;

		Context &ctx = context.top();

		// Emit the slot.
		emit(bytes, context, (Int16)index, ctx.expression.endian);
	}
	void generateConstOrVariable(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Error::Handler onError) {
		// Prepare.
		(void)stk;

		Context &ctx = context.top();

		// Ignore if there are more than one tokens.
		if (!(onlyToken() && noChild()))
			return;

		// Consume the tokens, emit the data.
		int cursor = 0;
		consume(_tokens, cursor, [&] (Token::Ptr tk) -> void {
			switch (tk->type()) {
			case Token::Types::IDENTIFIER: {
					const std::string id = (std::string)tk->data();
					std::string fuzzyName;
					const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
					int data = 0;
					const int macroParamIndex = ctx.expression.macroFunctions ? ctx.expression.macroFunctions->indexOf(id) : -1; // FEAT: MACRO.
					if (ramLocation) {
						data = ramLocation->address;
					} else if (macroParamIndex != -1) {
						data = macroParamIndex - ctx.expression.macroFunctions->count();
						if (ctx.expression.temporaries)
							data -= (int)ctx.expression.temporaries->size();
					} else {
						if (isBuiltin(context, id)) {
							break;
						} else {
							if (!fuzzyName.empty()) {
								THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, tk, fuzzyName);
							}

							THROW_ID_HAS_NOT_BEEN_DECLARED(onError, tk);
						}
					}
					emit(bytes, context, (Int16)data, ctx.expression.endian);
				}

				break;
			case Token::Types::BOOLEAN: {
					const Int16 data = (Int16)BOOLEAN(tk->data());
					emit(bytes, context, data, ctx.expression.endian);
				}

				break;
			case Token::Types::INTEGER: {
					const Int16 data = (Int16)(Variant::Long)tk->data();
					emit(bytes, context, data, ctx.expression.endian);
				}

				break;
			case Token::Types::REAL:
				THROW_NOT_IMPLEMENTED(onError, tk);
			case Token::Types::STRING: {
					const std::string data = (std::string)tk->data();
					emit(bytes, context, data);
				}

				break;
			default:
				THROW_INVALID_EXPRESSION(onError, tk);
			}
		});
	}
	void generateEvaluation(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Ignore if there is less than one token.
		Token::Ptr simpleTk = nullptr;
		do {
			Token::Ptr tk = onlyToken();
			if (!(tk && noChild()))
				break; // Allow if there are more than one tokens.

			switch (tk->type()) {
			case Token::Types::IDENTIFIER: // Fall through.
			case Token::Types::BOOLEAN:    // Fall through.
			case Token::Types::INTEGER:
				simpleTk = tk;

				break;
			case Token::Types::REAL:
				THROW_NOT_IMPLEMENTED(onError, tk);
			default:
				// Do nothing.

				break;
			}

			if (simpleTk) {
				if (!ctx.expression.alwaysEvaluate)
					return; // Ignore.
			}
		} while (false);

		// Mark the slot for later filling.
		ctx.expression.putSlot(ctx.expression.index);

		// FEAT: OPTIMIZATION.
		// Optimized to generate the only simple token if there's any.
		if (simpleTk) {
			switch (simpleTk->type()) {
			case Token::Types::IDENTIFIER: {
					const std::string id = (std::string)simpleTk->data();
					std::string fuzzyName;
					const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
					int data = 0;
					if (ramLocation) {
						data = ramLocation->address;
					} else {
						if (isBuiltin(context, id)) {
							if (writeBuiltin(bytes, context, Asm::Types::PUSH, id, -1))
								return; // Finished.
						} else {
							if (!fuzzyName.empty()) {
								THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
							}

							THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
						}
					}
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)data);

					return; // Finished.
				}

				break;
			case Token::Types::BOOLEAN: {
					const Int16 data = (Int16)BOOLEAN(simpleTk->data());
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)data);
				}

				return; // Finished.
			case Token::Types::INTEGER: {
					const Int16 data = (Int16)(Variant::Long)simpleTk->data();
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)data);
				}

				return; // Finished.
			case Token::Types::REAL:
				THROW_NOT_IMPLEMENTED(onError, simpleTk);
			default:
				// Do nothing.

				break;
			}
		}

		// Convert the infix expression to RPN.
		Token::Array rpn;
		if (!toRpn(context, rpn, onError))
			return; // Error occured.

		// Emit the temporaries.
		Context::Expression::Temporaries temporaries;
		VAR_GUARD(ctx.expression.temporaries, &temporaries);

		int cursor = 0;
		Token::Ptr q = nullptr;
		do {
			q = consume(rpn, cursor, [&] (Token::Ptr tk) -> void {
				switch (tk->type()) {
				case Token::Types::IDENTIFIER: {
						const std::string id = (std::string)tk->data();
						if (ctx.expression.macroFunctions && ctx.expression.macroFunctions->indexOf(id) != -1)
							break;

						if (temporaries.find(id) != temporaries.end())
							break;

						if (isBuiltin(context, id)) {
							writeBuiltin(bytes, context, Asm::Types::PUSH, id, -1); // Temporary builtin.
							const int n = (int)temporaries.size();
							temporaries.insert(std::make_pair(id, n));
						}
					}

					break;
				case Token::Types::INTERMEDIA: case Token::Types::MATH: case Token::Types::STATEMENT: case Token::Types::ARRAY: case Token::Types::MACRO: {
						const std::string id = tk->dump();
						GBBASIC_ASSERT(temporaries.find(id) == temporaries.end() && "Impossible.");

						const int index = (int)tk->data();
						Node::generate(bytes, context, Range(index), onError); // Intermedia value.
						const int n = (int)temporaries.size();
						temporaries.insert(std::make_pair(id, n));
					}

					break;
				default:
					// Do nothing.

					break;
				}
			});
		} while (q);

		// FEAT: OPTIMIZATION.
		// If there's only one token in the RPN and it's already on the stack, then
		// optimize to use it directly.
		if (rpn.size() == 1 && temporaries.size() == 1) {
			const Token::Ptr &tk = rpn.front();
			switch (tk->type()) {
			case Token::Types::IDENTIFIER: // Fall through.
			case Token::Types::INTERMEDIA: case Token::Types::MATH: case Token::Types::STATEMENT: case Token::Types::ARRAY: case Token::Types::MACRO:
				return; // Finished.
			default:
				GBBASIC_ASSERT(false && "Impossible.");

				break; // Not optimized.
			}
		}

		// Emit a `VM_RPN` instruction.
		emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);

		// Consume the tokens, emit a `VM_RPN` instructions.
		cursor = 0;
		q = nullptr;
		int offset = 0;
		do {
			bool isTrue = false;
			bool isFalse = false;
			q = consume(rpn, cursor, [&] (Token::Ptr tk) -> void {
				switch (tk->type()) {
				case Token::Types::OPERATOR: {
						const std::string data = (std::string)tk->data();
						if (data == "+") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::ADD]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "-") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::SUB]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == NEGATIVE) {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::NEG]);
						} else if (data == "*") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::MUL]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "/") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::DIV]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "mod") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::MOD]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "=") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::EQ]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "<") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::LT]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "<=") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::LE]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == ">") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::GT]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == ">=") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::GE]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "<>") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::NE]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "and") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::AND]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "or") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::OR]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "not") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::NOT]);
						} else if (data == "band") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::BITWISE_AND]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "bor") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::BITWISE_OR]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "bxor") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::BITWISE_XOR]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "bnot") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::BITWISE_NOT]);
						} else if (data == "lshift") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::BITWISE_LSHIFT]); DEC_COUNTER(stk, 2);
							++offset;
						} else if (data == "rshift") {
							emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::BITWISE_RSHIFT]); DEC_COUNTER(stk, 2);
							++offset;
						}
					}

					break;
				case Token::Types::IDENTIFIER: {
						Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::REF]); INC_COUNTER(stk, 2);
						const std::string id = (std::string)tk->data();
						std::string fuzzyName;
						const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
						int address = 0;
						const int macroParamIndex = ctx.expression.macroFunctions ? ctx.expression.macroFunctions->indexOf(id) : -1; // FEAT: MACRO.
						if (ramLocation) {
							address = ramLocation->address;

							args = fill(args, (Int16)address, ctx.expression.endian);
						} else if (macroParamIndex != -1) {
							address = macroParamIndex - ctx.expression.macroFunctions->count();
							address -= (int)temporaries.size();

							args = fill(args, (Int16)address, ctx.expression.endian);
						} else {
							Context::Expression::Temporaries::const_iterator it = temporaries.find(id);
							if (it != temporaries.end()) {
								const int idx = it->second - (int)temporaries.size();
								args = fill(args, (Int16)idx, ctx.expression.endian); // Temporary builtin.
							} else {
								if (!fuzzyName.empty()) {
									THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, tk, fuzzyName);
								}

								THROW_ID_HAS_NOT_BEEN_DECLARED(onError, tk);
							}
						}
						--offset;
					}

					break;
				case Token::Types::BOOLEAN: {
						if (tk->text() == "true") {
							const Token::Ptr nxt = current(rpn, cursor, Token::Types::OPERATOR);
							if (nxt) {
								if (nxt->data() == "=") {
									isTrue = true;

									break;
								} else if (nxt->data() == "<>") {
									isFalse = true;

									break;
								} else {
									THROW_INVALID_EXPRESSION(onError, tk);
								}
							}
						} else if (tk->text() == "false") {
							const Token::Ptr nxt = current(rpn, cursor, Token::Types::OPERATOR);
							if (nxt) {
								if (nxt->data() == "=") {
									isFalse = true;

									break;
								} else if (nxt->data() == "<>") {
									isTrue = true;

									break;
								} else {
									THROW_INVALID_EXPRESSION(onError, tk);
								}
							}
						}
						const Int8 data = (Int8)BOOLEAN(tk->data());
						Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT8]); INC_COUNTER(stk, 2);
						fill(args, (Int8)data);
						--offset;
					}

					break;
				case Token::Types::INTEGER: {
						const Int16 data = (Int16)(Variant::Long)tk->data();
						if (std::numeric_limits<signed char>::min() <= data && data <= std::numeric_limits<signed char>::max()) {
							Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT8]); INC_COUNTER(stk, 2);
							fill(args, (Int8)data);
						} else {
							Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT16]); INC_COUNTER(stk, 2);
							fill(args, data, ctx.expression.endian);
						}
						--offset;
					}

					break;
				case Token::Types::REAL:
					THROW_NOT_SUPPORTED(onError, tk);
				case Token::Types::STRING: {
						const std::string data = (std::string)tk->data();
						emit(bytes, context, data);
						--offset;
					}

					break;
				case Token::Types::INTERMEDIA: case Token::Types::MATH: case Token::Types::STATEMENT: case Token::Types::ARRAY: case Token::Types::MACRO: {
						Byte* args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::REF]); INC_COUNTER(stk, 2);
						const std::string id = (std::string)tk->dump();
						Context::Expression::Temporaries::const_iterator it = temporaries.find(id);
						if (it != temporaries.end()) {
							const int idx = it->second - (int)temporaries.size();
							args = fill(args, (Int16)idx, ctx.expression.endian); // Intermedia value.
						} else {
							THROW_INVALID_EXPRESSION(onError, tk);
						}
						--offset;
					}

					break;
				default:
					THROW_INVALID_EXPRESSION(onError, tk);
				}
			});
			if (isTrue) {
				consume(rpn, cursor);
			} else if (isFalse) {
				consume(rpn, cursor);

				emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::NOT]);
				++offset;
			}
		} while (q);
		emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);

		// Emit a `VM_POP_1` instruction to remove the temporaries.
		if (!temporaries.empty()) {
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP_1]); DEC_COUNTER(stk, 2 * (int)temporaries.size());
			args = fill(args, (UInt8)temporaries.size());
		}
	}

	bool toRpn(Context::Stack &context, Token::Array &rpn, Error::Handler onError) const {
		// Prepare.
		typedef std::stack<Token::Ptr> Stack;

		Context &ctx = context.top();

		Token::Array result;
		Stack stack;

		auto valid = [&ctx] (const Token::Ptr &tk) -> bool {
			if (!ctx.operators)
				return false;

			const std::string key = (std::string)tk->data();
			const OperatorTable::Entry* entry = ctx.operators->find(key);
			if (!entry)
				return false;

			return true;
		};
		auto get = [&ctx] (const Token::Ptr &tk) -> Op {
			if (!ctx.operators)
				return Op::OPERATORS[(size_t)Op::Types::STOP];

			const std::string key = (std::string)tk->data();
			const OperatorTable::Entry* entry = ctx.operators->find(key);
			if (!entry)
				return Op::OPERATORS[(size_t)Op::Types::STOP];

			return Op::OPERATORS[(size_t)entry->type];
		};
		auto equals = [] (const Token::Ptr &tk, const std::string &key_) -> bool {
			const std::string key = (std::string)tk->data();

			return key_ == key;
		};
		auto compare = [] (const Op &left, const Op &right) -> int {
			return left.precedence - right.precedence;
		};
		auto is = [&rpn] (Token::Types y, Variant d = nullptr) -> Token::Ptr {
			if (rpn.empty())
				return nullptr;
			const Token::Ptr &tk = rpn.back();
			if (tk->type() != y)
				return nullptr;
			if (d != nullptr && tk->data() != d)
				return nullptr;

			return tk;
		};
		auto add = [&rpn, &ctx, is] (const Token::Ptr &tk) -> void {
			// FEAT: OPTIMIZATION.
			// Replace some multiplication and division with bitwise shifting to optimize the code.
			Token::Ptr newnum = nullptr;
			Token::Ptr newop = nullptr;
			if (ctx.expression.optimize) {
				Token::Ptr tknum = is(Token::Types::INTEGER);
				if (tknum) {
					const int num = (int)tknum->data();
					const double exp = std::log2(num);
					if ((num > 0 && num <= 8192) && Math::isInteger(exp)) {
						newnum = Token::Ptr(new Token());
						newnum
							->type(Token::Types::INTEGER)
							->data((int)exp);
					}
				}
				if (tk->is(Token::Types::OPERATOR)) {
					if ((std::string)tk->data() == "/") {
						newop = Token::Ptr(new Token());
						newop
							->type(Token::Types::OPERATOR)
							->data("rshift");
					} else if ((std::string)tk->data() == "*") {
						newop = Token::Ptr(new Token());
						newop
							->type(Token::Types::OPERATOR)
							->data("lshift");
					}
				}
			}

			// Push token.
			if (newnum && newop) { // Push optimized tokens.
				rpn.pop_back();
				rpn.push_back(newnum);
				rpn.push_back(newop);
			} else { // Push the unoptimized token.
				rpn.push_back(tk);
			}
		};

		// Iterate the tokens.
		Token::Ptr expectsOperator = Token::Ptr(new Token());
		Token::Ptr expectsOperand = nullptr;
		for (const Token::Ptr &tk : _tokens) {
			switch (tk->type()) {
			case Token::Types::OPERATOR:
				if (expectsOperator == nullptr) {
					if (tk->data() == "(") {
						expectsOperand = tk;
					} else {
						throwUnexpectedOperator(onError, tk);

						return false;
					}
				} else {
					if (tk->data() == ")") {
						expectsOperator = Token::Ptr(new Token());
					} else {
						expectsOperator = nullptr;
					}
				}
				if (tk->data() != "(" && tk->data() != ")") {
					expectsOperand = tk;
				}

				break;
			case Token::Types::SYMBOL: case Token::Types::KEYWORD: case Token::Types::IDENTIFIER: // Fall through.
			case Token::Types::BOOLEAN:                                                           // Fall through.
			case Token::Types::NUMBER: case Token::Types::INTEGER: case Token::Types::REAL:       // Fall through.
			case Token::Types::INTERMEDIA: case Token::Types::MATH: case Token::Types::STATEMENT: case Token::Types::ARRAY: case Token::Types::MACRO:
				expectsOperator = tk;
				expectsOperand = nullptr;

				break;
			case Token::Types::COMMENT:
				continue;
			default:
				throwInvalidExpression(onError, tk);

				return false;
			}

			if (valid(tk)) { // The token is an operator.
				while (!stack.empty() && valid(stack.top())) { // While there is an operator (y) at the top of the operators stack.
					// Either (x) is left-associative and its precedence is less or equal to that of (y), or
					// (x) is right-associative and its precedence is less than (y).
					const Op currentOperator = get(tk); // The current operator.
					const Op lastOperator = get(stack.top()); // The top operator from the stack.
					if ((currentOperator.associativity == -1 && compare(currentOperator, lastOperator) <= 0) || (currentOperator.associativity == 1 && compare(currentOperator, lastOperator) < 0)) {
						// Pop (y) from the stack.
						// Add (y) to the output collection.
						const Token::Ptr top = stack.top();
						stack.pop();
						add(top);

						continue;
					}

					break;
				}
				// Push the new operator on the stack.
				stack.push(tk);
			} else if (equals(tk, "(")) { // The token is a left parenthesis.
				// Push it on the stack.
				stack.push(tk);
			} else if (equals(tk, ")")) { // The token is a right parenthesis.
				while (!stack.empty() && !equals(stack.top(), "(")) {
					// Until the top token (from the stack) is left parenthesis,
					// pop from the stack to the output collection.
					const Token::Ptr top = stack.top();
					stack.pop();
					add(top);
				}
				// Also pop the left parenthesis but don't include it in the output collection.
				stack.pop();
			} else { // Otherwise.
				// Add the token to the output collection.
				add(tk);
			}
		}
		if (expectsOperand) {
			throwUnexpectedOperator(onError, expectsOperand);

			return false;
		}

		while (!stack.empty()) { // While there are still operator tokens in the stack.
			// Pop them to the output collection.
			const Token::Ptr top = stack.top();
			stack.pop();
			add(top);
		}

		// Finish.
		return true;
	}
};

class NodeMath : public Node {
private:
	std::string _name;

public:
	NodeMath(const std::string &name) : _name(name) {
	}
	virtual ~NodeMath() override {
	}

	NODE_TYPE(Types::MATH)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				GBBASIC_ASSERT(id == _name && "Impossible.");
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			if (!ctx.operators) { THROW_TABLE_IS_NOT_INITIALIZED(onError); }
			const OperatorTable::Entry* entry = ctx.operators->find(id);
			if (!entry) { THROW_INVALID_SYNTAX(onError); }
			if (entry->parameters != (int)_children.size()) { THROW_INVALID_SYNTAX(onError); }

			// Set the stack footprint guard.
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit a `VM_RPN` instruction to calculate.
			if (!_children.empty())
				writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);
			{
				const Op::Types type = entry->type;
				emit(bytes, context, Op::OPERATORS[(size_t)type]);
			}
			emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return abstract(name.c_str());
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

class NodeAsc : public Node {
public:
	NodeAsc() {
	}
	virtual ~NodeAsc() override {
	}

	NODE_TYPE(Types::ASC)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "asc")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the ASCII value of a character.
			int ret = 0;
			Token::Ptr simpleTk = onlyTokenInOnlyChild();
			if (simpleTk) {
				if (simpleTk->is(Token::Types::STRING)) {
					std::string txt = simpleTk->caseSensitiveText();
					if (Text::startsWith(txt, "\"", false))
						txt.erase(txt.begin());
					if (Text::endsWith(txt, "\"", false))
						txt.pop_back();
					Token::Ptr tk(new Token());
					tk
						->type(Token::Types::STRING)
						->text(txt)
						->parse(false);
					const std::string id = (std::string)simpleTk->data();
					if (id.length() == 1) {
						union {
							UInt8 byte;
							std::string::value_type char_;
						} u;
						u.char_ = id.front();
						ret = u.byte;
					} else if (id.length() > 1) {
						const std::wstring wstr = Unicode::toWide(id);
						const wchar_t* wptr = wstr.c_str();
						if (*wptr == GLYPH_ESCAPE_SPECIAL) {
							switch (*++wptr) {
							case GLYPH_ESCAPE_UNICODE: {
									++wptr;
									unsigned cp = 0;
									if (!escapeUnicode(wptr, cp)) {
										THROW_TYPE_EXPECTED(onError, "Character", tk);
									}

									ret = (int)cp;

									++wptr;
								}

								break;
							case GLYPH_ESCAPE_STACK:
								THROW_TYPE_EXPECTED(onError, "Character", tk);
							case GLYPH_ESCAPE_BACKSLASH:
								ret = GLYPH_ESCAPE_BACKSLASH;

								++wptr;

								break;
							default:
								THROW_TYPE_EXPECTED(onError, "Character", tk);
							}

							const wchar_t* t = wstr.c_str() + wstr.length();

							GBBASIC_ASSERT(wptr <= t && "Impossible");

							if (wptr != t) {
								THROW_TYPE_EXPECTED(onError, "Character", tk);
							}
						} else {
							THROW_TYPE_EXPECTED(onError, "Character", tk);
						}
					} else {
						THROW_TYPE_EXPECTED(onError, "Character", tk);
					}
				} else {
					THROW_TYPE_EXPECTED(onError, "Character", simpleTk);
				}
			} else {
				THROW_TYPE_EXPECTED(onError, "Character", simpleTk);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			if (ctx.expression.optimize && withDeclaring) {
				// FEAT: OPTIMIZATION.
				// Emit a `VM_PUSH` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)ret);
			} else {
				writeRightHand(
					bytes, context, stk,
					[&] (void) -> void {
						// Emit a `VM_SET_CONST` instruction to set the data.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
						args = fill(args, (Int16)ret);
						args = fill(args, (Int16)ARG0);
					}, 0, true,
					onError
				);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("ASC");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ASC");
	}
	using Node::dump;
};

class NodeDeg : public Node {
public:
	NodeDeg() {
	}
	virtual ~NodeDeg() override {
	}

	NODE_TYPE(Types::DEG)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "deg")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the internal value of a specific degree.
			Token::Ptr tk = nullptr;
			int val = 0;
			if (!isInt16(context, 0, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Integer constant", tk); }
			val = (int)(val * (256.0f / 360.0f));
			const int deg = (val >= 0) ?
				(val % 256) :
				((val % 256 + 256) % 256);

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET_CONST` instruction to set the data.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
					args = fill(args, (Int16)deg);
					args = fill(args, (Int16)ARG0);
				}, 0, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("DEG");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEG");
	}
	using Node::dump;
};

class NodeLen : public Node {
public:
	NodeLen() {
	}
	virtual ~NodeLen() override {
	}

	NODE_TYPE(Types::LEN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "len")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the length of a value.
			int ret = 0;
			Token::Ptr simpleTk = onlyTokenInOnlyChild();
			if (simpleTk) {
				if (simpleTk->is(Token::Types::IDENTIFIER)) {
					// Get the array size.
					const std::string id = (std::string)simpleTk->data();
					const Context::Array::Dimensions* dimensions = nullptr;
					if (ctx.array) {
						dimensions = ctx.array->find(id);
						if (!dimensions) { THROW_INVALID_SYNTAX(onError); }
					} else {
						THROW_INVALID_SYNTAX(onError);
					}
					ret = 1;
					for (int n : dimensions->bounds)
						ret *= n;
				} else if (simpleTk->is(Token::Types::STRING)) {
					// Get the string length.
					const std::string id = (std::string)simpleTk->data();
					ret = (int)id.length();
				} else {
					THROW_INVALID_SYNTAX(onError);
				}
			} else {
				THROW_INVALID_SYNTAX(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET_CONST` instruction to set the data.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
					args = fill(args, (Int16)ret);
					args = fill(args, (Int16)ARG0);
				}, 0, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("LEN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "LEN");
	}
	using Node::dump;
};

class NodeRandomize : public Node {
public:
	NodeRandomize() {
	}
	virtual ~NodeRandomize() override {
	}

	NODE_TYPE(Types::RANDOMIZE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "randomize")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit instructions to initialize the randomizer.
			if (_children.empty()) {
				// Prepare.
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				// `VM_QUERY        SYS_TIME`; a.k.a. `_sys_time` as `.ARG1`.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)DEVICE_QUERY_SYS_TIME);
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::QUERY]); DEC_COUNTER(stk, 2); INC_COUNTER(stk, 2);

				// `VM_QUERY        DIV_REG`; a.k.a. `_DIV_REG` as `.ARG0`.
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)DEVICE_QUERY_DIV_REG);
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::QUERY]); DEC_COUNTER(stk, 2); INC_COUNTER(stk, 2);

				// `VM_RPN`.
				emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);
					// `.R_INT16    256`.
					args = emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::INT16]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)256, ctx.expression.endian);
					// `.R_OPERATOR .MUL`.
					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::MUL]); DEC_COUNTER(stk, 2);
					// `.R_OPERATOR .ADD`.
					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::ADD]); DEC_COUNTER(stk, 2);
					// `.R_STOP`.
					emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);

				// `VM_SRAND        .ARG0`.
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SRAND]);
				args = fill(args, (Int16)ARG0);

				// `VM_POP          1`.
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
				args = fill(args, (UInt8)1);
			} else {
				// Emit the argument from the child.
				writeChildren(bytes, context, Range(0), stk, onError);

				// Emit a `VM_SRAND` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SRAND]);
				args = fill(args, (Int16)ARG0);

				// Emit a `VM_POP` instruction to remove the temporary value of the argument.
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
				args = fill(args, (UInt8)1);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RANDOMIZE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RANDOMIZE");
	}
	using Node::dump;
};

class NodeRnd : public Node {
public:
	NodeRnd() {
	}
	virtual ~NodeRnd() override {
	}

	NODE_TYPE(Types::RND)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::OPERATOR, "rnd")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the arguments.
					switch (_children.size()) {
					case 0: {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);

							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)100);
						}

						break;
					case 1: {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);

							writeChildren(bytes, context, Range(0), stk, onError);
						}

						break;
					case 2:
						writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

						break;
					}

					// Emit a `VM_RAND` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RAND]);
					args = fill(args, (Int16)ARG0);
					args = fill(args, (Int16)ARG1);
					args = fill(args, (Int16)ARG2);
				}, 2, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RND");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RND");
	}
	using Node::dump;
};

class NodeBankOf : public Node {
public:
	NodeBankOf() {
	}
	virtual ~NodeBankOf() override {
	}

	NODE_TYPE(Types::BANKOF)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "bankof")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the bank of the specific target.
			int page = -1;
			Destination dest(0);
			Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
			if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }

			int bank = 0;
			do {
				// Prepare.
				if (!dest.isRight())
					break;

				// Search for builtin name.
				const std::string name = dest.right().get();
				if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
				const RomLocation* romLocation = ctx.symbols->find(name);
				if (romLocation) { // By builtin name.
					bank = romLocation->bank;

					break;
				}

				// Search for identifier.
				const RomLocation* scriptMemoryRamLocation = ctx.symbols ? ctx.symbols->find(SCRIPT_MEMORY_ENTRY_NAME) : nullptr; // It's defined in the ROM symbols, although it's RAM location but not ROM.
				const RamLocation* ramLocation = ctx.findPageAndGlobal(name);
				const Context::Array::Dimensions* dimensions = ctx.array->find(name);
				if (scriptMemoryRamLocation && ramLocation) {
					if (dimensions) { // By array name.
						bank = scriptMemoryRamLocation->bank;

						break;
					} else { // By variable name.
						bank = scriptMemoryRamLocation->bank;

						break;
					}
				}
			} while (false);

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET_CONST` instruction to set the data.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
					args = fill(args, (Int16)bank);
					args = fill(args, (Int16)ARG0);
				}, 0, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("BANKOF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "BANKOF");
	}
	using Node::dump;
};

class NodeAddressOf : public Node {
public:
	NodeAddressOf() {
	}
	virtual ~NodeAddressOf() override {
	}

	NODE_TYPE(Types::ADDRESSOF)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "addressof")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the address of the specific target.
			int page = -1;
			Destination dest(0);
			Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
			if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }

			int address = -1;
			do {
				// Prepare.
				if (!dest.isRight())
					break;

				// Search for builtin name.
				const std::string name = dest.right().get();
				if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
				const RomLocation* romLocation = ctx.symbols->find(name);
				if (romLocation) { // By builtin name.
					address = romLocation->address;

					break;
				}

				// Search for identifier.
				const RomLocation* scriptMemoryRamLocation = ctx.symbols ? ctx.symbols->find(SCRIPT_MEMORY_ENTRY_NAME) : nullptr; // It's defined in the ROM symbols, although it's RAM location but not ROM.
				const RamLocation* ramLocation = ctx.findPageAndGlobal(name);
				const Context::Array::Dimensions* dimensions = ctx.array->find(name);
				if (scriptMemoryRamLocation && ramLocation) {
					if (dimensions) { // By array name.
						address =
							scriptMemoryRamLocation->address /* start address */ +
							ramLocation->address /* address in RAM as `int16_t*` */ *
								WORD_SIZE /* 2 bytes per word */;

						break;
					} else { // By variable name.
						address =
							scriptMemoryRamLocation->address /* start address */ +
							ramLocation->address /* address in RAM as `int16_t*` */ *
								WORD_SIZE /* 2 bytes per word */;

						break;
					}
				}
			} while (false);

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET_CONST` instruction to set the data.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
					args = fill(args, (Int16)address);
					args = fill(args, (Int16)ARG0);
				}, 0, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("ADDRESSOF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ADDRESSOF");
	}
	using Node::dump;
};

class NodeArrayRead : public Node {
public:
	NodeArrayRead() {
	}
	virtual ~NodeArrayRead() override {
	}

	NODE_TYPE(Types::ARRAY_READ)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "[")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "]")) { THROW_INVALID_SYNTAX(onError); }

			// Find the array ID in RAM.
			const Context::Array::Dimensions* dimensions = nullptr;
			if (ctx.array) {
				dimensions = ctx.array->find(id);
				if (!dimensions) { THROW_INVALID_SYNTAX(onError); }
			} else {
				THROW_INVALID_SYNTAX(onError);
			}
			std::string fuzzyName;
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
			if (!ramLocation) {
				if (!fuzzyName.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
			}

			// Set the stack footprint guard.
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the array index.
			writeArrayIndices(bytes, context, dimensions, Range(0, (int)_children.size() - 1), onError);

			// Emit a `VM_RPN` instruction to calculate the indirect address.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)ramLocation->address);

			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);
			{
				emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::ADD]); DEC_COUNTER(stk, 2);
			}
			emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);

			// Emit a `VM_GET_INDIRECT` instruction to get the array element.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::GET_INDIRECT]);
			args = fill(args, (Int16)ARG0);
			args = fill(args, (Int16)ARG0);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("=[...]");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "=[...]");
	}
	using Node::dump;
};

class NodeArrayWrite : public Node {
public:
	NodeArrayWrite() {
	}
	virtual ~NodeArrayWrite() override {
	}

	NODE_TYPE(Types::ARRAY_WRITE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "[")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "]")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }

			// Find the array ID in RAM.
			const Context::Array::Dimensions* dimensions = nullptr;
			if (ctx.array) {
				dimensions = ctx.array->find(id);
				if (!dimensions) { THROW_INVALID_SYNTAX(onError); }
			} else {
				THROW_INVALID_SYNTAX(onError);
			}
			std::string fuzzyName;
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
			if (!ramLocation) {
				if (!fuzzyName.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the array index.
			writeArrayIndices(bytes, context, dimensions, Range(0, (int)_children.size() - 1 - 1 /* Minus the last child of right hand value. */), onError);

			// Emit a `VM_RPN` instruction to calculate the indirect address.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)ramLocation->address);

			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RPN]);
			{
				emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::ADD]); DEC_COUNTER(stk, 2);
			}
			emit(bytes, context, Op::OPERATORS[(size_t)Op::Types::STOP]);

			// Emit the right hand value.
			if (!_children.empty())
				writeChildren(bytes, context, Range((int)_children.size() - 1), stk, onError);

			// Emit a `VM_SET_INDIRECT` instruction to set the array element.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_INDIRECT]);
			args = fill(args, (Int16)ARG0);
			args = fill(args, (Int16)ARG1);

			// Emit a `VM_POP` instruction to remove the temporary values.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 4);
			args = fill(args, (UInt8)2);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("[...]=");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "[...]=");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Blank, comment and nop
*/

class NodeBlank : public Node {
public:
	NodeBlank() {
	}
	virtual ~NodeBlank() override {
	}

	NODE_TYPE(Types::BLANK)

	virtual void generate(Bytes::Ptr &/* bytes */, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		if (ctx.expect.lnno) {
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
			})) { THROW_INVALID_SYNTAX(onError); }
		}
		if (consume(Token::Types::OPERATOR, ";")) { /* Do nothing. */ }
		if (!consume(Token::Types::END_OF_LINE)) { THROW_INVALID_SYNTAX(onError); }

		// Put the code to ROM location correspondence.
		context.top().put(top().inCode, top().inRom);
	}

	virtual Abstract abstract(void) const override {
		return { "BLANK" };
	}

	virtual std::string dump(int depth) const override {
		return dump(depth, "BLANK");
	}
	using Node::dump;
};

class NodeRem : public Node {
public:
	NodeRem() {
	}
	virtual ~NodeRem() override {
	}

	NODE_TYPE(Types::REM)

	virtual void generate(Bytes::Ptr &/* bytes */, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		if (ctx.expect.lnno) {
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
			})) { THROW_INVALID_SYNTAX(onError); }
		}
		if (!consume(Token::Types::COMMENT)) { THROW_INVALID_SYNTAX(onError); }
		if (!consume(Token::Types::END_OF_LINE)) { THROW_INVALID_SYNTAX(onError); }

		// Put the code to ROM location correspondence.
		context.top().put(top().inCode, top().inRom);
	}

	virtual Abstract abstract(void) const override {
		return { "REM" };
	}

	virtual std::string dump(int depth) const override {
		return dump(depth, "REM");
	}
	using Node::dump;
};

class NodeDoNothing : public Node {
public:
	NodeDoNothing() {
	}
	virtual ~NodeDoNothing() override {
	}

	NODE_TYPE(Types::DO_NOTHING)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "do")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::IDENTIFIER, "nothing")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::END_OF_LINE)) { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			if (_children.size() <= 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Emit a `VM_NOP` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::NOP]);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return { "DONOTHING" };
	}

	virtual std::string dump(int depth) const override {
		return dump(depth, "DONOTHING");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Declaration
*/

/**
 * @brief Base class for all declaration nodes.
 */
class NodeDecl : public Node {
public:
	NodeDecl() {
	}
	virtual ~NodeDecl() override {
	}

	void generate(const std::string &keyword, bool assignmentRequired, Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			bool hasAssign = false;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			const bool withKey = !!current(Token::Types::KEYWORD, keyword);
			if (withKey) {
				if (!consume(Token::Types::KEYWORD, keyword)) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (assignmentRequired) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			} else {
				if (consume(Token::Types::OPERATOR, "=")) { hasAssign = true; }
			}

			// Find the left hand ID in RAM.
			if (ctx.array) {
				const Context::Array::Dimensions* dimensions = ctx.array->find(id);
				if (dimensions) { THROW_INVALID_SYNTAX(onError); }
			}
			std::string fuzzyName;
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
			int stackRef = -1;
			do {
				if (!Text::startsWith(id, "stack", true))
					break;
				const std::string idxTxt = id.substr(5 /* after "stack" */);
				int idx = -1;
				if (!Text::fromString(idxTxt, idx))
					break;
				if (idx < 0 || idx >= COMPILER_STACK_ARGUMENT_MAX_COUNT)
					break;

				stackRef = idx;
			} while (false);
			if (ramLocation) {
				if (withKey) { // Duplicated declaration.
#if DECLARE_WITH_LET_AND_ACCEPT_ELSEWHERE_ENABLED
					bool acceptOthers = false;
					switch (ramLocation->usage) {
					case RamLocation::Usages::LOOP: // Fall through.
					case RamLocation::Usages::READ: // Fall through.
					case RamLocation::Usages::TOUCH: // Fall through.
					case RamLocation::Usages::VIEWPORT:
						acceptOthers = true;

						break;
					default:
						// Do nothing.

						break;
					}
					if (acceptOthers) {
						const RamLocation inRam = *ramLocation;
						top().inRam = inRam;
					} else {
						THROW_ID_HAS_BEEN_ALREADY_DECLARED(onError, idtk);
					}
#else /* DECLARE_WITH_LET_AND_ACCEPT_ELSEWHERE_ENABLED */
					THROW_ID_HAS_BEEN_ALREADY_DECLARED(onError, idtk);
#endif /* DECLARE_WITH_LET_AND_ACCEPT_ELSEWHERE_ENABLED */
				} else { // Assign statement.
					const RamLocation inRam = *ramLocation;
					top().inRam = inRam;
				}
			} else if (stackRef >= 0) {
				// Do nothing.
			} else {
				const bool declarationRequired = ctx.declaration.declarationRequired;
				if (!declarationRequired || withKey) { // Declaration.
					const TextLocation &txtLoc = idtk->begin();
					if (!allocateHeap(ctx, ctx.heapSize, WORD_SIZE, id, RamLocation::Usages::VARIABLE, txtLoc)) {
						if (allocateHeap(ctx, ctx.heapSize * 2, WORD_SIZE, id, RamLocation::Usages::VARIABLE, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
						else { THROW_HEAP_OVERFLOW(onError, false); }
					}
				} else { // Not declared.
					if (!fuzzyName.empty()) {
						THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
					}

					THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
				}
			}

			// Emit assignment if there is any.
			if (assignmentRequired || hasAssign) {
				// Determine the target slot.
				if (stackRef < 0) { // Variable in RAM.
					// Prepare.
					const int ref = top().inRam.address;

					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Emit the right hand value.
					Token::Ptr simpleTk = onlyTokenInOnlyChild();
					if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
						args = fill(args, (Int16)BOOLEAN(simpleTk->data()));
						args = fill(args, (Int16)ref);
					} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
						args = fill(args, (Int16)(Int)simpleTk->data());
						args = fill(args, (Int16)ref);
					} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
						const std::string id = (std::string)simpleTk->data();
						std::string fuzzyName;
						const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
						int data = 0;
						if (ramLocation) {
							data = ramLocation->address;

							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
							args = fill(args, (Int16)data);
							args = fill(args, (Int16)ref);
						} else {
							if (writeBuiltin(bytes, context, Asm::Types::SET, id, ref)) {
								// Do nothing.
							} else {
								if (!fuzzyName.empty()) {
									THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
								}

								THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
							}
						}
					} else { // EXPR.
						VAR_GUARD(ctx.expect.lnno, false);
						VAR_GUARD(ctx.declaration.declaring, ref);
						VAR_GUARD(
							ctx.expression.category,
							Context::Expression::Categories::EVALUATION
						);
						VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

						Node::generate(bytes, context, onError);

						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
						args = fill(args, (Int16)ARG0);
						args = fill(args, (Int16)ref);

						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
						args = fill(args, (UInt8)1);
					}

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				} else { // Local variable of the current thread.
					// Prepare.
					const int ref = stackRef;

					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Emit the right hand value.
					Token::Ptr simpleTk = onlyTokenInOnlyChild();
					if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
						args = fill(args, (Int16)BOOLEAN(simpleTk->data()));

						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_TLOCAL]);
						args = fill(args, (Int16)ARG0);
						args = fill(args, (Int16)ref);

						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
						args = fill(args, (UInt8)1);
					} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
						args = fill(args, (Int16)(Int)simpleTk->data());

						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_TLOCAL]);
						args = fill(args, (Int16)ARG0);
						args = fill(args, (Int16)ref);

						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
						args = fill(args, (UInt8)1);
					} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
						const std::string id = (std::string)simpleTk->data();
						std::string fuzzyName;
						const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
						int data = 0;
						if (ramLocation) {
							data = ramLocation->address;

							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_TLOCAL]);
							args = fill(args, (Int16)data);
							args = fill(args, (Int16)ref);
						} else {
							if (writeBuiltin(bytes, context, Asm::Types::SET_TLOCAL, id, ref)) {
								// Do nothing.
							} else {
								if (!fuzzyName.empty()) {
									THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
								}

								THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
							}
						}
					} else { // EXPR.
						VAR_GUARD(ctx.expect.lnno, false);
						VAR_GUARD(ctx.declaration.declaring, ref);
						VAR_GUARD(
							ctx.expression.category,
							Context::Expression::Categories::EVALUATION
						);
						VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

						Node::generate(bytes, context, onError);

						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_TLOCAL]);
						args = fill(args, (Int16)ARG0);
						args = fill(args, (Int16)ref);

						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
						args = fill(args, (UInt8)1);
					}

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}
			}
		};

		write(bytes, context, generator, false, onError);
	}
};

class NodeConst : public NodeDecl {
public:
	NodeConst() {
	}
	virtual ~NodeConst() override {
	}

	NODE_TYPE(Types::CONST)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "const")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }

			// Not implemented.
			THROW_NOT_IMPLEMENTED(onError, nullptr);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("CONST");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "CONST");
	}
	using Node::dump;
};

class NodeLet : public NodeDecl {
public:
	NodeLet() {
	}
	virtual ~NodeLet() override {
	}

	NODE_TYPE(Types::LET)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		NodeDecl::generate("let", false, bytes, context, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("let");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "LET");
	}
	using Node::dump;
};

class NodeDim : public Node {
public:
	NodeDim() {
	}
	virtual ~NodeDim() override {
	}

	NODE_TYPE(Types::DIM)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "dim")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "[")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "]")) { THROW_INVALID_SYNTAX(onError); }

			// Find the left hand ID in RAM.
			const Context::Array::Dimensions* dimensions = nullptr;
			if (ctx.array) {
				dimensions = ctx.array->find(id);
				if (!dimensions) { THROW_INVALID_SYNTAX(onError); }
			} else {
				THROW_INVALID_SYNTAX(onError);
			}
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id);
			if (ramLocation) {
				THROW_ID_HAS_BEEN_ALREADY_DECLARED(onError, idtk);
			} else { // Declaration.
				const TextLocation &txtLoc = idtk->begin();
				const int expSize = dimensions->size() * WORD_SIZE;
				if (!allocateHeap(ctx, ctx.heapSize, expSize, id, RamLocation::Usages::ARRAY, txtLoc)) {
					if (allocateHeap(ctx, ctx.heapSize * 2, expSize, id, RamLocation::Usages::ARRAY, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
					else { THROW_HEAP_OVERFLOW(onError, false); }
				}
			}

			// Emit a `VM_FILL` instruction to initialize the array.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FILL]);
			args = fill(args, (Int16)dimensions->size());
			args = fill(args, (Int16)0);
			args = fill(args, (Int16)top().inRam.address);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("DIM");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DIM");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Conditional
*/

class NodeIf : public Node {
private:
	bool _singleLine = false;

public:
	NodeIf() {
	}
	virtual ~NodeIf() override {
	}

	NODE_TYPE(Types::IF)

	virtual void options(const IDictionary::Ptr &options) override {
		_singleLine = (bool)options->get("single_line");
	}

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 2) {
				THROW_INVALID_SYNTAX(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the conditions and statements.
			Addresses endOfChunk;
			for (int i = 0; i < (int)_children.size(); i += 2) {
				// Prepare.
				int j = i;
				const bool isElse = (_children.size() % 2) != 0 && i == (int)_children.size() - 1;

				intptr_t offset0 = 0;
				if (!isElse) {
					// Emit the conditional expression.
					do {
						VAR_GUARD(ctx.expect.lnno, false);
						VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.
						VAR_GUARD(
							ctx.expression.category,
							Context::Expression::Categories::EVALUATION
						);
						VAR_GUARD(ctx.expression.alwaysEvaluate, true);
						VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

						// `cond`.
						const Ptr &cond = _children[j++];
						cond->generate(bytes, context, onError);
					} while (false);

					// `IF cond = 0 THEN GOTO (a)`.
					// Emit a `VM_IF_CONST` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::IF_CONST]);
					args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2); // Pop the conditional expression value.
					offset0 = prefill<UInt16>(bytes, args);
					args = fill(args, (Int16)0); // Is `FALSE`.
					args = fill(args, (Int16)ARG0);
					args = fill(args, Op::OPERATORS[(size_t)Op::Types::EQ]);
				}

				// Emit the statements of the conditional body.
				if (_singleLine) {
					VAR_GUARD(ctx.expect.lnno, false);

					const Ptr &stmt = _children[j++];
					stmt->generate(bytes, context, onError);
				} else {
					const Ptr &stmt = _children[j++];
					stmt->generate(bytes, context, onError);
				}

				// `GOTO (b)`.
				// Emit a `VM_JUMP` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
				const intptr_t offset1 = prefill<UInt16>(bytes, args);
				endOfChunk.push_back(offset1);

				// (a).
				const int addressA = ctx.startAddress + ctx.addressCursor;
				// Fill in the addresses.
				if (!isElse)
					fill(bytes, offset0, (UInt16)addressA);
			}

			// (b).
			const int addressB = ctx.startAddress + ctx.addressCursor;
			// Fill in the addresses.
			for (intptr_t addr : endOfChunk)
				fill(bytes, addr, (UInt16)addressB);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("IF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "IF");
	}
	using Node::dump;
};

class NodeThen : public Node {
public:
	NodeThen() {
	}
	virtual ~NodeThen() override {
	}

	NODE_TYPE(Types::THEN)

	virtual Abstract abstract(void) const override {
		return abstract("THEN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "THEN");
	}
	using Node::dump;
};

class NodeElse : public Node {
public:
	NodeElse() {
	}
	virtual ~NodeElse() override {
	}

	NODE_TYPE(Types::ELSE)

	virtual Abstract abstract(void) const override {
		return abstract("ELSE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ELSE");
	}
	using Node::dump;
};

class NodeElseIf : public Node {
public:
	NodeElseIf() {
	}
	virtual ~NodeElseIf() override {
	}

	NODE_TYPE(Types::ELSE_IF)

	virtual Abstract abstract(void) const override {
		return abstract("ELSE IF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ELSE IF");
	}
	using Node::dump;
};

class NodeIif : public Node {
public:
	NodeIif() {
	}
	virtual ~NodeIif() override {
	}

	NODE_TYPE(Types::IIF)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "iif")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 2) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 3) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the arguments.
					{
						VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.

						writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);
					}

					// Emit a `VM_IIF` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::IIF]);
					args = fill(args, (Int16)ARG0);
					args = fill(args, (Int16)ARG1);
					args = fill(args, (Int16)ARG2);
					args = fill(args, (Int16)ARG3);
				}, 3, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("IIF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "IIF");
	}
	using Node::dump;
};

class NodeSelect : public Node {
public:
	NodeSelect() {
	}
	virtual ~NodeSelect() override {
	}

	NODE_TYPE(Types::SELECT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "select")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::KEYWORD, "case")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			if (_children.size() < 2) {
				THROW_INVALID_SYNTAX(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Find the condition ID.
			std::string fuzzyName;
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
			if (!ramLocation) {
				if (!fuzzyName.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
			}

			// Emit the conditions and statements.
			Addresses endOfChunk;
			for (int i = 0; i < (int)_children.size(); i += 2) {
				// Prepare.
				int j = i;
				const bool isElse = (_children.size() % 2) != 0 && i == (int)_children.size() - 1;

				intptr_t offset0 = 0;
				if (!isElse) {
					// Emit the conditional expression.
					do {
						VAR_GUARD(ctx.expect.lnno, false);
						VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.
						VAR_GUARD(
							ctx.expression.category,
							Context::Expression::Categories::EVALUATION
						);
						VAR_GUARD(ctx.expression.alwaysEvaluate, true);
						VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

						// `cond`.
						const Ptr &cond = _children[j++];
						cond->generate(bytes, context, onError);
					} while (false);

					// `IF cond = 0 THEN GOTO (a)`.
					// Emit a `VM_IF_CONST` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::IF_CONST]);
					args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2); // Pop the conditional expression value.
					offset0 = prefill<UInt16>(bytes, args);
					args = fill(args, (Int16)0); // Is `FALSE`.
					args = fill(args, (Int16)ARG0);
					args = fill(args, Op::OPERATORS[(size_t)Op::Types::EQ]);
				}

				// Emit the statements of the conditional body.
				const Ptr &stmt = _children[j++];
				stmt->generate(bytes, context, onError);

				// `GOTO (b)`.
				// Emit a `VM_JUMP` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
				const intptr_t offset1 = prefill<UInt16>(bytes, args);
				endOfChunk.push_back(offset1);

				// (a).
				const int addressA = ctx.startAddress + ctx.addressCursor;
				// Fill in the addresses.
				if (!isElse)
					fill(bytes, offset0, (UInt16)addressA);
			}

			// (b).
			const int addressB = ctx.startAddress + ctx.addressCursor;
			// Fill in the addresses.
			for (intptr_t addr : endOfChunk)
				fill(bytes, addr, (UInt16)addressB);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SELECT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SELECT");
	}
	using Node::dump;
};

class NodeCase : public Node {
public:
	NodeCase() {
	}
	virtual ~NodeCase() override {
	}

	NODE_TYPE(Types::CASE)

	virtual Abstract abstract(void) const override {
		return abstract("CASE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "CASE");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** On/off
*/

class NodeOn : public Node {
private:
	typedef std::vector<int> Indices;

private:
	Scheduled::Array _scheduled;
	Indices _indices;
	EventTypes _type = EventTypes::NONE;

public:
	NodeOn() {
	}
	virtual ~NodeOn() override {
	}

	NODE_TYPE(Types::ON)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		typedef std::vector<int> Pages;
		typedef std::vector<Destination> Destinations;

		const Generator_Void_Bool generator = [&] (bool overflow) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_indices.clear();
			_type = EventTypes::NONE;

			// Consume the tokens.
			EventTargets target = EventTargets::GOTO;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "on")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "btn")) { _type = EventTypes::BUTTON; }
			else if (consume(Token::Types::KEYWORD, "btnd")) { _type = EventTypes::BUTTON_DOWN; }
			else if (consume(Token::Types::KEYWORD, "btnu")) { _type = EventTypes::BUTTON_UP; }
			else if (consume(Token::Types::KEYWORD, "touch")) { _type = EventTypes::TOUCH; }
			else if (consume(Token::Types::KEYWORD, "touchd")) { _type = EventTypes::TOUCH_DOWN; }
			else if (consume(Token::Types::KEYWORD, "touchu")) { _type = EventTypes::TOUCH_UP; }
			else { _type = EventTypes::CONDITIONAL; }
			const bool isButtonInput = !!((unsigned)_type & (unsigned)EventTypes::BUTTON_INPUT);
			const bool isTouchInput = !!((unsigned)_type & (unsigned)EventTypes::TOUCH_INPUT);
			if (isButtonInput || isTouchInput) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			}
			if (consume(Token::Types::KEYWORD, "goto")) { target = EventTargets::GOTO; }
			else if (consume(Token::Types::KEYWORD, "gosub")) { target = EventTargets::GOSUB; }
			else if (consume(Token::Types::KEYWORD, "start")) { target = EventTargets::START; }
			if (_type == EventTypes::CONDITIONAL && target != EventTargets::GOTO && target != EventTargets::GOSUB) { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			Pages pages;
			Destinations dests;
			switch (_type) {
			case EventTypes::CONDITIONAL:
				if (_children.empty()) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() <= 256) {
					for (int i = 1; i < (int)_children.size(); ++i) {
						int page = -1;
						Destination dest(0);
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, i, false);
						if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
						pages.push_back(page);
						dests.push_back(dest);
					}
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				break;
			case EventTypes::BUTTON:      // Fall through.
			case EventTypes::BUTTON_DOWN: // Fall through.
			case EventTypes::BUTTON_UP:
				if (_children.empty()) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() <= 2) {
					int page = -1;
					Destination dest(Left<int>(0));
					Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, (int)_children.size() - 1, false);
					if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
					pages.push_back(page);
					dests.push_back(dest);
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				break;
			case EventTypes::TOUCH:      // Fall through.
			case EventTypes::TOUCH_DOWN: // Fall through.
			case EventTypes::TOUCH_UP:
				if (_children.empty()) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() == 1) {
					int page = -1;
					Destination dest(Left<int>(0));
					Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, (int)_children.size() - 1, false);
					if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
					pages.push_back(page);
					dests.push_back(dest);
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				usingExtensionFeature(ctx, onError); // Check for feature compatibility.

				break;
			default:
				THROW_TOO_FEW_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the specific instruction.
			switch (_type) {
			case EventTypes::CONDITIONAL: {
					// Emit the condition expression.
					{
						VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.

						writeChildren(bytes, context, Range(0), stk, onError);
					}

					// Emit a `VM_SWITCH` instruction.
					VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

					const int indexBase = ctx.array ? ctx.array->base : 0;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SWITCH]);
					switch (target) {
					case EventTargets::GOTO:
						args = fill(args, (UInt8)FALSE); // Jump far.

						break;
					case EventTargets::GOSUB:
						args = fill(args, (UInt8)TRUE); // Call far.

						break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)(_children.size() - 1));
					args = fill(args, (Int16)ARG0, ctx.expression.endian);
					for (int i = 0; i < (int)dests.size(); ++i) {
						const int page = pages[i];
						const Destination &dest = dests[i];
						SourceLocation target;
						if (dest.isLeft())
							target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
						else
							target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
						const RomLocation* romLocation = ctx.find(target);
						const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
						args = reserve(bytes, context, 5);
						if (romLocation) {
							args = fill(args, (Int16)(i + indexBase), ctx.expression.endian); // Case.
							args = fill(args, (UInt16)address, ctx.expression.endian);
							args = fill(args, (UInt8)romLocation->bank);
						} else {
							_scheduled.push_back(Scheduled(target, bytes->pointer(), args, overflow));
							_indices.push_back(i);
						}
					}
				}

				break;
			case EventTypes::BUTTON:      // Fall through.
			case EventTypes::BUTTON_DOWN: // Fall through.
			case EventTypes::BUTTON_UP: {
					// Determine the input options.
					int method = EVENT_HANDLER_GOSUB;
					switch (target) {
					case EventTargets::GOTO:    method = EVENT_HANDLER_GOTO;  break;
					case EventTargets::GOSUB:   method = EVENT_HANDLER_GOSUB; break;
					case EventTargets::START:   method = EVENT_HANDLER_START; break;
					}
					int cat = 0;
					switch (_type) {
					case EventTypes::BUTTON:        cat = 0; break;
					case EventTypes::BUTTON_DOWN:   cat = 1; break;
					case EventTypes::BUTTON_UP:     cat = 2; break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					Token::Ptr tk = nullptr;
					int btn = 0;
					if (_children.size() == 1) {
						btn = INPUT_HANDLER_BTN_ANY;
					} else /* if (_children.size() == 2) */ {
						int val = 0;
						if (!isUInt8(context, 0, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
						switch (val) {
						case INPUT_BUTTON_UP:       btn = INPUT_HANDLER_BTN_UP;     break;
						case INPUT_BUTTON_DOWN:     btn = INPUT_HANDLER_BTN_DOWN;   break;
						case INPUT_BUTTON_LEFT:     btn = INPUT_HANDLER_BTN_LEFT;   break;
						case INPUT_BUTTON_RIGHT:    btn = INPUT_HANDLER_BTN_RIGHT;  break;
						case INPUT_BUTTON_A:        btn = INPUT_HANDLER_BTN_A;      break;
						case INPUT_BUTTON_B:        btn = INPUT_HANDLER_BTN_B;      break;
						case INPUT_BUTTON_SELECT:   btn = INPUT_HANDLER_BTN_SELECT; break;
						case INPUT_BUTTON_START:    btn = INPUT_HANDLER_BTN_START;  break;
						}
					}
					const int inputHandlerOptions = method | (cat * ((INPUT_HANDLER_COUNT - 3) / 3) + btn);

					// Emit a `VM_ON_INPUT` instruction.
					const int page = pages.front();
					const Destination &dest = dests.front();
					SourceLocation target;
					if (dest.isLeft())
						target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
					else
						target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
					const RomLocation* romLocation = ctx.find(target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_INPUT]);
					args = fill(args, (UInt8)inputHandlerOptions);
					if (romLocation) {
						args = fill(args, (UInt16)address);
						args = fill(args, (UInt8)romLocation->bank);
					} else {
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, overflow));
					}
				}

				break;
			case EventTypes::TOUCH:      // Fall through.
			case EventTypes::TOUCH_DOWN: // Fall through.
			case EventTypes::TOUCH_UP: {
					// Determine the input options.
					int method = EVENT_HANDLER_GOSUB;
					switch (target) {
					case EventTargets::GOTO:    method = EVENT_HANDLER_GOTO;  break;
					case EventTargets::GOSUB:   method = EVENT_HANDLER_GOSUB; break;
					case EventTargets::START:   method = EVENT_HANDLER_START; break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					int cat = 0;
					switch (_type) {
					case EventTypes::TOUCH:        cat = 0; break;
					case EventTypes::TOUCH_DOWN:   cat = 1; break;
					case EventTypes::TOUCH_UP:     cat = 2; break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					const int inputHandlerOptions = method | (cat + INPUT_HANDLER_TOUCH);

					// Emit a `VM_ON_INPUT` instruction.
					const int page = pages.front();
					const Destination &dest = dests.front();
					SourceLocation target;
					if (dest.isLeft())
						target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
					else
						target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
					const RomLocation* romLocation = ctx.find(target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_INPUT]);
					args = fill(args, (UInt8)inputHandlerOptions);
					if (romLocation) {
						args = fill(args, (UInt16)address);
						args = fill(args, (UInt8)romLocation->bank);
					} else {
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, overflow));
					}
				}

				break;
			default:
				GBBASIC_ASSERT(false && "Impossible.");

				break;
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case EventTypes::CONDITIONAL: {
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				const int indexBase = ctx.array ? ctx.array->base : 0;

				for (int i = 0; i < (int)_scheduled.size(); ++i) {
					Scheduled &scheduled = _scheduled[i];
					const int index = _indices[i];
					if (!scheduled.pending())
						continue;

					const RomLocation* romLocation = ctx.find(scheduled.target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					if (romLocation) {
						Byte* args = scheduled.args(bytes->pointer());
						args = fill(args, (Int16)(index + indexBase), ctx.expression.endian);
						args = fill(args, (UInt16)address, ctx.expression.endian);
						args = fill(args, (UInt8)romLocation->bank);
					} else {
						THROW_INVALID_PROGRAM_POINT(onError);
					}
				}
			}

			break;
		case EventTypes::BUTTON:      // Fall through.
		case EventTypes::BUTTON_DOWN: // Fall through.
		case EventTypes::BUTTON_UP:   // Fall through.
		case EventTypes::TOUCH:       // Fall through.
		case EventTypes::TOUCH_DOWN:  // Fall through.
		case EventTypes::TOUCH_UP: {
				Scheduled &scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				const RomLocation* romLocation = ctx.find(scheduled.target);
				const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
				if (romLocation) {
					Byte* args = scheduled.args(bytes->pointer());
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					THROW_INVALID_PROGRAM_POINT(onError);
				}
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("ON");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ON");
	}
	using Node::dump;
};

class NodeOff : public Node {
public:
	NodeOff() {
	}
	virtual ~NodeOff() override {
	}

	NODE_TYPE(Types::OFF)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			EventTypes type = EventTypes::NONE;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "off")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "btn")) { type = EventTypes::BUTTON; }
			else if (consume(Token::Types::KEYWORD, "btnd")) { type = EventTypes::BUTTON_DOWN; }
			else if (consume(Token::Types::KEYWORD, "btnu")) { type = EventTypes::BUTTON_UP; }
			else if (consume(Token::Types::KEYWORD, "touch")) { type = EventTypes::TOUCH; }
			else if (consume(Token::Types::KEYWORD, "touchd")) { type = EventTypes::TOUCH_DOWN; }
			else if (consume(Token::Types::KEYWORD, "touchu")) { type = EventTypes::TOUCH_UP; }
			else { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			switch (type) {
			case EventTypes::BUTTON:      // Fall through.
			case EventTypes::BUTTON_DOWN: // Fall through.
			case EventTypes::BUTTON_UP:
				if (_children.size() <= 1) {
					// Do nothing.
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				usingExtensionFeature(ctx, onError); // Check for feature compatibility.

				break;
			case EventTypes::TOUCH:      // Fall through.
			case EventTypes::TOUCH_DOWN: // Fall through.
			case EventTypes::TOUCH_UP:
				if (_children.empty()) {
					// Do nothing.
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				break;
			default:
				THROW_INVALID_SYNTAX(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit the specific instruction.
			switch (type) {
			case EventTypes::BUTTON:      // Fall through.
			case EventTypes::BUTTON_DOWN: // Fall through.
			case EventTypes::BUTTON_UP: {
					// Determine the input options.
					int cat = 0;
					switch (type) {
					case EventTypes::BUTTON:        cat = 0; break;
					case EventTypes::BUTTON_DOWN:   cat = 1; break;
					case EventTypes::BUTTON_UP:     cat = 2; break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					Token::Ptr tk = nullptr;
					int btn = 0;
					if (_children.empty()) {
						btn = INPUT_HANDLER_BTN_ANY;
					} else /* if (_children.size() == 2) */ {
						int val = 0;
						if (!isUInt8(context, 0, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
						switch (val) {
						case INPUT_BUTTON_UP:       btn = INPUT_HANDLER_BTN_UP;     break;
						case INPUT_BUTTON_DOWN:     btn = INPUT_HANDLER_BTN_DOWN;   break;
						case INPUT_BUTTON_LEFT:     btn = INPUT_HANDLER_BTN_LEFT;   break;
						case INPUT_BUTTON_RIGHT:    btn = INPUT_HANDLER_BTN_RIGHT;  break;
						case INPUT_BUTTON_A:        btn = INPUT_HANDLER_BTN_A;      break;
						case INPUT_BUTTON_B:        btn = INPUT_HANDLER_BTN_B;      break;
						case INPUT_BUTTON_SELECT:   btn = INPUT_HANDLER_BTN_SELECT; break;
						case INPUT_BUTTON_START:    btn = INPUT_HANDLER_BTN_START;  break;
						}
					}
					const int inputHandlerOptions = cat * ((INPUT_HANDLER_COUNT - 3) / 3) + btn;

					// Emit a `VM_ON_INPUT` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_INPUT]);
					args = fill(args, (UInt8)inputHandlerOptions);
					args = fill(args, (UInt16)0);
					args = fill(args, (UInt8)0);
				}

				break;
			case EventTypes::TOUCH:      // Fall through.
			case EventTypes::TOUCH_DOWN: // Fall through.
			case EventTypes::TOUCH_UP: {
					// Determine the input options.
					int cat = 0;
					switch (type) {
					case EventTypes::TOUCH:        cat = 0; break;
					case EventTypes::TOUCH_DOWN:   cat = 1; break;
					case EventTypes::TOUCH_UP:     cat = 2; break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					const int inputHandlerOptions = cat + INPUT_HANDLER_TOUCH;

					// Emit a `VM_ON_INPUT` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_INPUT]);
					args = fill(args, (UInt8)inputHandlerOptions);
					args = fill(args, (UInt16)0);
					args = fill(args, (UInt8)0);
				}

				break;
			default:
				GBBASIC_ASSERT(false && "Impossible.");

				break;
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("OFF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "OFF");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Loop
*/

/**
 * @brief Base class for all loop nodes.
 */
class NodeLoop : public Node {
public:
	NodeLoop() {
	}
	virtual ~NodeLoop() override {
	}

protected:
	auto beginLoop(Context::Loop::Stack &loop, Context::Loop::Types y) {
		return [&, y] (void) -> void {
			loop.push_back(Context::Loop(y));
		};
	}
	auto beginLoop(Context::Loop::Stack &loop, Context::Loop::Types y, const std::string &c) {
		return [&, y, c] (void) -> void {
			loop.push_back(Context::Loop(y, c));
		};
	}
	auto endLoop(Context::Loop::Stack &loop) {
		return [&] (void) -> void {
			loop.pop_back();
		};
	}
};

class NodeFor : public NodeLoop {
public:
	NodeFor() {
	}
	virtual ~NodeFor() override {
	}

	NODE_TYPE(Types::FOR)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "for")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::KEYWORD, "to")) { THROW_INVALID_SYNTAX(onError); }
			const bool withStep = !!consume(Token::Types::KEYWORD, "step");

			// Check the children.
			if (withStep) {
				if (_children.size() != 4) {
					THROW_INVALID_SYNTAX(onError);
				}
			} else {
				if (_children.size() != 3) {
					THROW_INVALID_SYNTAX(onError);
				}
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// FEAT: OPTIMIZATION.
			// Use simplified loop instruction for `FOR` loops with constant condition and step values.
			const bool optimize = ctx.expression.optimize;
			bool optimizable = false;
			if (optimize) {
				Token::Ptr simpleTk1 = onlyTokenInNthChild(1); // Get the loop termination.
				Token::Ptr simpleTk2 = onlyTokenInNthChild(2); // Get the loop step.
				optimizable =
					(simpleTk1 && (simpleTk1->is(Token::Types::BOOLEAN) || simpleTk1->is(Token::Types::NUMBER))) && // Const termination, and.
					(!withStep || // No step, or.
						(simpleTk2 && (simpleTk2->is(Token::Types::BOOLEAN) || simpleTk2->is(Token::Types::NUMBER)))); // Const step.

				GBBASIC_ASSERT((withStep && !!simpleTk2) || (!withStep && !simpleTk2) && "Wrong data.");
			}

			// Determine possible loop step if it's not provided.
			int step = 0;
			if (!withStep) {
				Token::Ptr simpleTk0 = onlyTokenInNthChild(0); // Get the loop initial.
				Token::Ptr simpleTk1 = onlyTokenInNthChild(1); // Get the loop termination.
				const bool determinable =
					(simpleTk0 && (simpleTk0->is(Token::Types::BOOLEAN) || simpleTk0->is(Token::Types::NUMBER))) && // Const initial, and.
					(simpleTk1 && (simpleTk1->is(Token::Types::BOOLEAN) || simpleTk1->is(Token::Types::NUMBER))); // Const termination.
				if (determinable) {
					int val0 = 0;
					if (simpleTk0->is(Token::Types::BOOLEAN)) // Const.
						val0 = (int)BOOLEAN(simpleTk0->data());
					else if (simpleTk0->is(Token::Types::NUMBER)) // Const.
						val0 = (int)(Int)simpleTk0->data();
					int val1 = 0;
					if (simpleTk1->is(Token::Types::BOOLEAN)) // Const.
						val1 = (int)BOOLEAN(simpleTk1->data());
					else if (simpleTk1->is(Token::Types::NUMBER)) // Const.
						val1 = (int)(Int)simpleTk1->data();
					if (val0 < val1)
						step = 1;
					else if (val0 > val1)
						step = -1;
				}
			}

			// Emit a loop instruction.
			if (optimizable) {
				// If the loop condition and step are constants, optimize the compilation
				// to use the `FOR` directive in combination with the `LOOP` instruction.
				// It is approximately 10% faster than pure `FOR` loop in some cases.
				generateLoop(bytes, context, stk, idtk, id, withStep, step, onError);
			} else {
				generateFor(bytes, context, stk, idtk, id, withStep, step, onError);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("FOR");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "FOR");
	}
	using Node::dump;

private:
	void generateLoop(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, const Token::Ptr &idtk, const std::string &id, bool withStep, int step, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Emit the initialization ID and expression.
		{
			// Find the left hand ID in RAM.
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id);
			if (ramLocation) { // Assignment.
				const RamLocation inRam = *ramLocation;
				top().inRam = inRam;
			} else { // Declaration.
				const TextLocation &txtLoc = idtk->begin();
				if (!allocateHeap(ctx, ctx.heapSize, WORD_SIZE, id, RamLocation::Usages::LOOP, txtLoc)) {
					if (allocateHeap(ctx, ctx.heapSize * 2, WORD_SIZE, id, RamLocation::Usages::LOOP, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
					else { THROW_HEAP_OVERFLOW(onError, false); }
				}
			}

			// Emit the right hand value.
			Token::Ptr simpleTk = onlyTokenInNthChild(0);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
				args = fill(args, (Int16)BOOLEAN(simpleTk->data()));
				args = fill(args, (Int16)top().inRam.address);
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
				args = fill(args, (Int16)(Int)simpleTk->data());
				args = fill(args, (Int16)top().inRam.address);
			} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
				const std::string id_ = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id_, fuzzyName);
				int data = 0;
				if (ramLocation) {
					data = ramLocation->address;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
					args = fill(args, (Int16)data);
					args = fill(args, (Int16)top().inRam.address);
				} else {
					if (writeBuiltin(bytes, context, Asm::Types::SET, id_, top().inRam.address)) {
						// Do nothing.
					} else {
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
					}
				}
			} else { // EXPR.
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				const Ptr &expr = _children[0]; // Get the initialization expression.
				expr->generate(bytes, context, onError);

				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
				args = fill(args, (Int16)ARG0);
				args = fill(args, (Int16)top().inRam.address);

				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
				args = fill(args, (UInt8)1);
			}
		}

		// Emit the loop step.
		PROC_GUARD(beginLoop(ctx.loop, Context::Loop::Types::LOOP, id), endLoop(ctx.loop));
		Context::Loop &loop = ctx.loop.back();
		{
			// Emit the right hand value.
			Token::Ptr simpleTk = onlyTokenInNthChild(2);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else if (!simpleTk) {
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(step != 0 ? step : 1));
			} else {
				GBBASIC_ASSERT(false && "Impossible.");

				THROW_TYPE_EXPECTED(onError, "Integer constant", simpleTk);
			}
		}

		// Emit the loop termination.
		{
			// Emit the right hand value.
			Token::Ptr simpleTk = onlyTokenInNthChild(1);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else {
				GBBASIC_ASSERT(false && "Impossible.");

				THROW_TYPE_EXPECTED(onError, "Integer constant", simpleTk);
			}
		}

		// `IF NOT FOR (i, t, s) THEN GOTO (b)`.
		// Emit the conditional expression.
		Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FOR]);
		args = fill(args, (UInt8)2); DEC_COUNTER(stk, 2 * 2); // Pop the loop termination and step value.
		const intptr_t offset0 = prefill<UInt16>(bytes, args);
		args = fill(args, (Int16)ARG1);
		args = fill(args, (Int16)ARG0);
		args = fill(args, (Int16)top().inRam.address);

		// (a).
		const int addressA = ctx.startAddress + ctx.addressCursor;
		// Emit the statements of the conditional body.
		const Ptr &stmt = _children[withStep ? 3 : 2];
		stmt->generate(bytes, context, onError);

		// (c).
		const int addressC = ctx.startAddress + ctx.addressCursor;
		// `IF LOOP (i, t, s) THEN GOTO (a)`.
		// Emit a `VM_LOOP` instruction.
		args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::LOOP]);
		args = fill(args, (UInt8)0); DEC_COUNTER(stk, 0); // Pop nothing.
		args = fill(args, (UInt16)addressA);
		{
			// Emit the loop step.
			Token::Ptr simpleTk = onlyTokenInNthChild(2);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else if (!simpleTk) {
				args = fill(args, (UInt16)(step != 0 ? step : 1));
			} else {
				GBBASIC_ASSERT(false && "Impossible.");
			}
		}
		{
			// Emit the loop termination.
			Token::Ptr simpleTk = onlyTokenInNthChild(1);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else {
				GBBASIC_ASSERT(false && "Impossible.");
			}
		}
		args = fill(args, (Int16)top().inRam.address); // Emit the loop variable.

		// Fill in the addresses.
		const Context::Loop::Offsets* offsets = loop.getNext(id);
		if (offsets) {
			for (intptr_t offset : *offsets)
				fill(bytes, offset, (UInt16)addressC);
			loop.removeNext(id);
		}

		// (b).
		const int addressB = ctx.startAddress + ctx.addressCursor;
		// Fill in the addresses.
		fill(bytes, offset0, (UInt16)addressB);

		for (intptr_t offset : loop.toBreak)
			fill(bytes, offset, (UInt16)addressB);
		loop.clearBreaks();
	}
	void generateFor(Bytes::Ptr &bytes, Context::Stack &context, Counter &stk, const Token::Ptr &idtk, const std::string &id, bool withStep, int step, Error::Handler onError) {
		// Prepare.
		Context &ctx = context.top();

		const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

		// Emit the initialization ID and expression.
		{
			// Find the left hand ID in RAM.
			const RamLocation* ramLocation = ctx.findPageAndGlobal(id);
			if (ramLocation) { // Assignment.
				const RamLocation inRam = *ramLocation;
				top().inRam = inRam;
			} else { // Declaration.
				const TextLocation &txtLoc = idtk->begin();
				if (!allocateHeap(ctx, ctx.heapSize, WORD_SIZE, id, RamLocation::Usages::LOOP, txtLoc)) {
					if (allocateHeap(ctx, ctx.heapSize * 2, WORD_SIZE, id, RamLocation::Usages::LOOP, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
					else { THROW_HEAP_OVERFLOW(onError, false); }
				}
			}

			// Emit the right hand value.
			Token::Ptr simpleTk = onlyTokenInNthChild(0);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
				args = fill(args, (Int16)BOOLEAN(simpleTk->data()));
				args = fill(args, (Int16)top().inRam.address);
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
				args = fill(args, (Int16)(Int)simpleTk->data());
				args = fill(args, (Int16)top().inRam.address);
			} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
				const std::string id_ = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id_, fuzzyName);
				int data = 0;
				if (ramLocation) {
					data = ramLocation->address;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
					args = fill(args, (Int16)data);
					args = fill(args, (Int16)top().inRam.address);
				} else {
					if (writeBuiltin(bytes, context, Asm::Types::SET, id_, top().inRam.address)) {
						// Do nothing.
					} else {
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
					}
				}
			} else { // EXPR.
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				const Ptr &expr = _children[0]; // Get the initialization expression.
				expr->generate(bytes, context, onError);

				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
				args = fill(args, (Int16)ARG0);
				args = fill(args, (Int16)top().inRam.address);

				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
				args = fill(args, (UInt8)1);
			}
		}

		// (a).
		const int addressA = ctx.startAddress + ctx.addressCursor;
		// Emit the loop step.
		PROC_GUARD(beginLoop(ctx.loop, Context::Loop::Types::FOR, id), endLoop(ctx.loop));
		Context::Loop &loop = ctx.loop.back();
		{
			// Emit the right hand value.
			Token::Ptr simpleTk = onlyTokenInNthChild(2);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
				GBBASIC_ASSERT(withStep && "Impossible.");

				const std::string id_ = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id_, fuzzyName);
				int data = 0;
				if (ramLocation) {
					data = ramLocation->address;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)data);
				} else {
					if (writeBuiltin(bytes, context, Asm::Types::PUSH, id_, -1)) {
						// Do nothing.
					} else {
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
					}
				}
			} else if (!simpleTk) {
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(step != 0 ? step : 1));
			} else { // EXPR.
				GBBASIC_ASSERT(withStep && "Impossible.");

				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				const Ptr &expr = _children[2]; // Get the step expression.
				expr->generate(bytes, context, onError);
			}
		}

		// Emit the loop termination.
		{
			// Emit the right hand value.
			Token::Ptr simpleTk = onlyTokenInNthChild(1);
			if (simpleTk && simpleTk->is(Token::Types::BOOLEAN)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)BOOLEAN(simpleTk->data()));
			} else if (simpleTk && simpleTk->is(Token::Types::NUMBER)) { // Const.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)(Int)simpleTk->data());
			} else if (simpleTk && simpleTk->is(Token::Types::IDENTIFIER)) { // Variable.
				const std::string id_ = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id_, fuzzyName);
				int data = 0;
				if (ramLocation) {
					data = ramLocation->address;

					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)data);
				} else {
					if (writeBuiltin(bytes, context, Asm::Types::PUSH, id_, -1)) {
						// Do nothing.
					} else {
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
					}
				}
			} else { // EXPR.
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				const Ptr &expr = _children[1]; // Get the termination expression.
				expr->generate(bytes, context, onError);
			}
		}

		// `IF NOT FOR (i, t, s) THEN GOTO (b)`.
		// Emit the conditional expression.
		Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FOR]);
		args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2); // Pop the loop termination value.
		const intptr_t offset0 = prefill<UInt16>(bytes, args);
		args = fill(args, (Int16)ARG1);
		args = fill(args, (Int16)ARG0);
		args = fill(args, (Int16)top().inRam.address);

		// Emit the statements of the conditional body.
		const Ptr &stmt = _children[withStep ? 3 : 2];
		stmt->generate(bytes, context, onError);

		// (c).
		const int addressC = ctx.startAddress + ctx.addressCursor;
		// Emit the loop step.
		args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ACC]);
		args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2); // Pop the loop step value.
		args = fill(args, (Int16)ARG0);
		args = fill(args, (Int16)top().inRam.address);

		// Fill in the addresses.
		const Context::Loop::Offsets* offsets = loop.getNext(id);
		if (offsets) {
			for (intptr_t offset : *offsets)
				fill(bytes, offset, (UInt16)addressC);
			loop.removeNext(id);
		}

		// `GOTO (a)`.
		// Emit a `VM_JUMP` instruction.
		args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
		args = fill(args, (UInt16)addressA);

		// (b).
		const int addressB = ctx.startAddress + ctx.addressCursor;
		// Fill in the addresses.
		fill(bytes, offset0, (UInt16)addressB);

		for (intptr_t offset : loop.toBreak)
			fill(bytes, offset, (UInt16)addressB);
		loop.clearBreaks();

		// Emit a `VM_POP` instruction to pop the loop step value.
		args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); // Do not: `DEC_COUNTER(stk, 2);`
				                                                            // because this is a replenish of the `VM_ACC`,
				                                                            // which was not executed when a loop ends.
		args = fill(args, (UInt8)1);
	}
};

class NodeNext : public Node {
public:
	NodeNext() {
	}
	virtual ~NodeNext() override {
	}

	NODE_TYPE(Types::NEXT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "next")) { THROW_INVALID_SYNTAX(onError); }
			const bool withId = !!current(Token::Types::IDENTIFIER);
			if (withId) {
				if (!consume([&] (Token::Ptr tk) -> void {
					idtk = tk;
					id = (std::string)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Get any current loop.
			Context::Loop* loop = ctx.loop.empty() ? nullptr : &ctx.loop.back();
			if (!loop) { THROW_INVALID_SYNTAX(onError); }

			// Emit a `VM_JUMP` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
			const intptr_t offset = prefill<UInt16>(bytes, args);
			if (!withId)
				id = loop->current;
			loop->addNext(id, offset);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("NEXT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "NEXT");
	}
	using Node::dump;
};

class NodeWhile : public NodeLoop {
public:
	NodeWhile() {
	}
	virtual ~NodeWhile() override {
	}

	NODE_TYPE(Types::WHILE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() != 2) {
				THROW_INVALID_SYNTAX(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// (a).
			const int addressA = ctx.startAddress + ctx.addressCursor;
			// Emit the conditional expression.
			PROC_GUARD(beginLoop(ctx.loop, Context::Loop::Types::WHILE), endLoop(ctx.loop));
			Context::Loop &loop = ctx.loop.back();
			do {
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.alwaysEvaluate, true);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				// `cond`.
				const Ptr &cond = _children[0];
				cond->generate(bytes, context, onError);
			} while (false);

			// `IF COND = 0 THEN GOTO (b)`.
			// Emit a `VM_IF_CONST` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::IF_CONST]);
			args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2);
			const intptr_t offset0 = prefill<UInt16>(bytes, args);
			args = fill(args, (Int16)0); // Is `FALSE`.
			args = fill(args, (Int16)ARG0);
			args = fill(args, Op::OPERATORS[(size_t)Op::Types::EQ]);

			// Emit the statements of the loop body.
			const Ptr &stmt = _children[1];
			stmt->generate(bytes, context, onError);

			// `GOTO (a)`.
			// Emit a `VM_JUMP` instruction.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
			args = fill(args, (UInt16)addressA);

			// (b).
			const int addressB = ctx.startAddress + ctx.addressCursor;
			// Fill in the addresses.
			fill(bytes, offset0, (UInt16)addressB);

			for (intptr_t offset : loop.toBreak)
				fill(bytes, offset, (UInt16)addressB);
			loop.clearBreaks();

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("WHILE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "WHILE");
	}
	using Node::dump;
};

class NodeRepeat : public NodeLoop {
public:
	NodeRepeat() {
	}
	virtual ~NodeRepeat() override {
	}

	NODE_TYPE(Types::REPEAT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() != 2) {
				THROW_INVALID_SYNTAX(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// (a).
			const int addressA = ctx.startAddress + ctx.addressCursor;
			// Emit the statements of the loop body.
			PROC_GUARD(beginLoop(ctx.loop, Context::Loop::Types::REPEAT), endLoop(ctx.loop));
			Context::Loop &loop = ctx.loop.back();
			const Ptr &stmt = _children[0];
			stmt->generate(bytes, context, onError);

			// Emit the conditional expression.
			do {
				VAR_GUARD(ctx.expect.lnno, false);
				VAR_GUARD(ctx.declaration.declaring, Context::Declaration::ARGUMENT); // As argument of a function.
				VAR_GUARD(
					ctx.expression.category,
					Context::Expression::Categories::EVALUATION
				);
				VAR_GUARD(ctx.expression.alwaysEvaluate, true);
				VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

				// `cond`.
				const Ptr &cond = _children[1];
				cond->generate(bytes, context, onError);
			} while (false);

			// `IF COND = 0 THEN GOTO (a)`.
			// Emit a `VM_IF_CONST` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::IF_CONST]);
			args = fill(args, (UInt8)1); DEC_COUNTER(stk, 2);
			args = fill(args, (UInt16)addressA);
			args = fill(args, (Int16)0); // Is `FALSE`.
			args = fill(args, (Int16)ARG0);
			args = fill(args, Op::OPERATORS[(size_t)Op::Types::EQ]);

			// (b).
			const int addressB = ctx.startAddress + ctx.addressCursor;

			for (intptr_t offset : loop.toBreak)
				fill(bytes, offset, (UInt16)addressB);
			loop.clearBreaks();

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("REPEAT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "REPEAT");
	}
	using Node::dump;
};

class NodeExit : public Node {
public:
	NodeExit() {
	}
	virtual ~NodeExit() override {
	}

	NODE_TYPE(Types::EXIT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "exit")) { THROW_INVALID_SYNTAX(onError); }

			// Get any current loop.
			Context::Loop* loop = ctx.loop.empty() ? nullptr : &ctx.loop.back();
			if (!loop) { THROW_INVALID_SYNTAX(onError); }

			// Emit a `VM_JUMP` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
			const intptr_t offset = prefill<UInt16>(bytes, args);
			loop->addBreak(offset);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("EXIT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "EXIT");
	}
	using Node::dump;
};

class NodeDo : public Node {
public:
	NodeDo() {
	}
	virtual ~NodeDo() override {
	}

	NODE_TYPE(Types::DO)

	virtual Abstract abstract(void) const override {
		return abstract("DO");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DO");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Jump and flow control
*/

class NodeDestination : public Node {
private:
	std::string _name;
	std::string _caseSensitiveName;

public:
	NodeDestination() {
	}
	virtual ~NodeDestination() override {
	}

	NODE_TYPE(Types::DESTINATION)

	virtual void options(const IDictionary::Ptr &options) override {
		_name = (std::string)options->get("name");
		_caseSensitiveName = (std::string)options->get("case_sensitive_name");
	}

	virtual void generate(Bytes::Ptr &/* bytes */, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		Token::Ptr idtk = nullptr;
		if (ctx.expect.lnno) {
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				push();
				{
					State &state_ = top();
					state_.inRom.bank = ctx.bank;
					state_.inRom.address = ctx.addressCursor;
					state_.inRom.size = 0;
					state_.inCode = SourceLocation(tk->begin().page, (int)tk->data()); // `#pg:lno`.
					if (!context.top().put(top().inCode, top().inRom)) {
						THROW_DUPLICATE_DESTINATION(onError, idtk);
					}
				}
				pop();
			})) { THROW_INVALID_SYNTAX(onError); }
		}
		if (!consume(Token::Types::LABEL, ANYTHING, [&] (Token::Ptr tk) -> void {
			idtk = tk;
			std::string lbl = (std::string)tk->data();
			if (!lbl.empty() && lbl.back() == ':')
				lbl = lbl.substr(0, lbl.length() - 1);
			state.inCode = SourceLocation(tk->begin().page, lbl); // `#pg:lbl`. Labeled destination is determined by page and label name.
		})) { THROW_INVALID_SYNTAX(onError); }

		// Put the code to ROM location correspondence.
		if (!context.top().put(top().inCode, top().inRom)) {
			THROW_DUPLICATE_DESTINATION(onError, idtk);
		}
	}

	virtual Abstract abstract(void) const override {
		return { _caseSensitiveName, ":" };
	}

	virtual std::string dump(int depth) const override {
		const std::string name = _name + ":";

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

class NodeGoto : public Node {
private:
	Scheduled _scheduled;
	bool _longJump = false;

public:
	NodeGoto() {
	}
	virtual ~NodeGoto() override {
	}

	NODE_TYPE(Types::GOTO)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Bool generator = [&] (bool overflow) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();
			_longJump = false;

			// Check the children.
			int page = -1;
			Destination dest(0);
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
				if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "goto")) { /* Do nothing. */ }

			// Emit a `VM_JUMP_FAR` instruction.
			SourceLocation target;
			if (dest.isLeft())
				target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
			else
				target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
			const RomLocation* romLocation = ctx.find(target);
			const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
			_longJump = overflow || !romLocation || ctx.bank != romLocation->bank; // Use long jump if overflowed or the destination has been determined being in another bank, otherwise use near jump.
			if (_longJump) {
				// Long jump.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP_FAR]);
				if (romLocation) {
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					_scheduled = Scheduled(target, bytes->pointer(), args, overflow);
				}
			} else {
				// Near jump.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JUMP]);
				if (romLocation) {
					args = fill(args, (UInt16)address);
				} else {
					_scheduled = Scheduled(target, bytes->pointer(), args, overflow);

					// Technically, it is impossible to be here.
					GBBASIC_ASSERT(false && "Impossible.");
				}
			}
		};

		write(bytes, context, generator, true, onError); // Allow this emission to be placed at the tail of a bank, since it is always a far jump.
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		const RomLocation* romLocation = nullptr;
		findDestination(ctx, _scheduled.target, &romLocation, onError);
		if (!romLocation)
			return;

		const int address = ctx.startAddress + romLocation->address;
		if (_longJump) {
			// Long jump.
			Byte* args = _scheduled.args(bytes->pointer());
			args = fill(args, (UInt16)address);
			args = fill(args, (UInt8)romLocation->bank);
		} else {
			// Near jump.
			Byte* args = _scheduled.args(bytes->pointer());
			args = fill(args, (UInt16)address);

			// Technically, it is impossible to be here.
			GBBASIC_ASSERT(false && "Impossible.");
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("GOTO");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "GOTO");
	}
	using Node::dump;
};

class NodeGosub : public Node {
private:
	Scheduled _scheduled;

public:
	NodeGosub() {
	}
	virtual ~NodeGosub() override {
	}

	NODE_TYPE(Types::GOSUB)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Bool generator = [&] (bool overflow) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();

			// Check the children.
			int page = -1;
			Destination dest(0);
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
				if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "gosub")) { THROW_INVALID_SYNTAX(onError); }

			// Emit a `VM_CALL_FAR` instruction.
			SourceLocation target;
			if (dest.isLeft())
				target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
			else
				target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
			const RomLocation* romLocation = ctx.find(target);
			const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
			if (overflow) {
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::CALL_FAR]);
				if (romLocation) {
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					_scheduled = Scheduled(target, bytes->pointer(), args, overflow);
				}
			} else {
				// Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::CALL]);
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::CALL_FAR]);
				if (romLocation) {
					// args = fill(args, (UInt16)address);
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					_scheduled = Scheduled(target, bytes->pointer(), args, overflow);
				}
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		const RomLocation* romLocation = nullptr;
		findDestination(ctx, _scheduled.target, &romLocation, onError);
		if (!romLocation)
			return;

		const int address = ctx.startAddress + romLocation->address;
		if (_scheduled.overflow) {
			Byte* args = _scheduled.args(bytes->pointer());
			args = fill(args, (UInt16)address);
			args = fill(args, (UInt8)romLocation->bank);
		} else {
			Byte* args = _scheduled.args(bytes->pointer());
			// args = fill(args, (UInt16)address);
			args = fill(args, (UInt16)address);
			args = fill(args, (UInt8)romLocation->bank);
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("GOSUB");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "GOSUB");
	}
	using Node::dump;
};

class NodeReturn : public Node {
public:
	NodeReturn() {
	}
	virtual ~NodeReturn() override {
	}

	NODE_TYPE(Types::RETURN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "return")) { THROW_INVALID_SYNTAX(onError); }

			// Set the stack footprint guard.
			COUNTER_GUARD(ctx, stk);

			// Get `FOR` loops.
			int forLoops = 0;
			for (const Context::Loop &loop : ctx.loop) {
				if (loop.type == Context::Loop::Types::FOR)
					++forLoops;
			}
			if (forLoops > 0) { // For non-optimized raw `FOR` loops without `VM_LOOP` instructions.
				// Emit a `VM_POP` instruction to remove the temporaries of `FOR` loops.
				// In particular "temporaries" means un-popped loop steps.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); // Do not: `DEC_COUNTER(stk, 2);`
					                                                                      // because this is a replenish of the `VM_ACC`,
					                                                                      // which was not executed when a loop ends.
				args = fill(args, (UInt8)forLoops);
			}

			// Emit a `VM_RET_FAR` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RET_FAR]);
			args = fill(args, (UInt8)0); DEC_COUNTER(stk, 0);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RETURN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RETURN");
	}
	using Node::dump;
};

class NodeEnd : public Node {
public:
	NodeEnd() {
	}
	virtual ~NodeEnd() override {
	}

	NODE_TYPE(Types::END)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "end")) { THROW_INVALID_SYNTAX(onError); }

			// Emit a `VM_HALT` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::HALT]);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("END");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "END");
	}
	using Node::dump;
};

class NodeCall : public Node {
public:
	NodeCall() {
	}
	virtual ~NodeCall() override {
	}

	NODE_TYPE(Types::CALL)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			bool byAddress = false;
			int bank = 0;
			int address = 0;
			std::string functionName, caseSensitiveFunctionName;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "call")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(ctx, byAddress, bank, address, functionName, caseSensitiveFunctionName, onError)) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Get the native function pointer in the ROM.
			if (!byAddress) {
				if (!ctx.symbols) { THROW_INVALID_NATIVE_SYMBOL(onError); }
				const RomLocation* romLocation = ctx.symbols->find(caseSensitiveFunctionName);
				if (!romLocation) {
					std::string fuzzyName;
					if (ctx.symbols->fuzzy(caseSensitiveFunctionName, fuzzyName)) {
						THROW_INVALID_NATIVE_SYMBOL_DID_YOU_MEAN(onError, fuzzyName);
					}

					THROW_INVALID_NATIVE_SYMBOL(onError);
				}
				bank = romLocation->bank;
				address = romLocation->address;
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the evaluations.
			if (!_children.empty())
				writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

			// Emit a `VM_INVOKE_FN` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::INVOKE_FN]);
			if (_children.empty()) {
				args = fill(args, (Int16)0);
				args = fill(args, (UInt8)0);
				args = fill(args, (UInt16)address);
				args = fill(args, (UInt8)bank);
			} else if (_children.size() <= 255) {
				args = fill(args, (Int16)(-(int)_children.size())); // Offset from `ARG0`.
				args = fill(args, (UInt8)(_children.size()));
				args = fill(args, (UInt16)address);
				args = fill(args, (UInt8)bank);
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("CALL");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "CALL");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Thread
*/

class NodeStart : public Node {
private:
	struct ScheduledStart : public Scheduled {
		bool put = false;
		int declaring = -1;

		ScheduledStart() {
		}
		ScheduledStart(
			const SourceLocation &t, const Byte* begin, const Byte* end, bool overflow_,
			bool put_, int decl
		) :
			Scheduled(t, begin, end, overflow_),
			put(put_), declaring(decl)
		{
		}
	};

	typedef std::vector<int> Indices;

private:
	ScheduledStart _scheduled;
	int _arguments = 0;
	Indices _indices;
	bool _inplaceJoin = false;

public:
	NodeStart() {
	}
	virtual ~NodeStart() override {
	}

	NODE_TYPE(Types::START)

	virtual Variant options(const std::string &key) const override {
		if (key == "inplace_join")
			return _inplaceJoin;

		return nullptr;
	}
	virtual void options(const IDictionary::Ptr &options) override {
		_inplaceJoin = (bool)options->get("inplace_join");
	}

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Bool generator = [&] (bool overflow) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = ScheduledStart();
			_arguments = 0;
			_indices.clear();

			// Check the children.
			int page = -1;
			Destination dest(0);
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() <= 1 + THREAD_PARAMETER_MAX_COUNT) {
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
				if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
				_arguments = (int)_children.size() - 1;
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			Token::Ptr tk1st = firstTokenInThisOrChildren();
			if (tk1st) state.inCode = SourceLocation(tk1st->begin().page);
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "start")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Emit the instruction.
			if (_inplaceJoin) {
				// Set the stack footprint guard.
				Counter &stk = *ctx.stackFootprint;

				// Emit a `VM_PUSH` instruction to reserve for the thread handle temporarily.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)NULL);

				// Emit the thread arguments.
				if (_arguments > 0)
					writeChildren(bytes, context, Range((int)_children.size() - 1, 1), stk, onError);

				// Emit a `VM_BEGIN_THREAD` instruction.
				SourceLocation target;
				if (dest.isLeft())
					target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
				else
					target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
				const RomLocation* romLocation = ctx.find(target);
				const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
				constexpr const bool put = true;
				const int handle = ARG0 - _arguments;
				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::BEGIN_THREAD]);
				if (romLocation) {
					args = fill(args, (UInt8)_arguments);
					args = fill(args, (Int16)handle); // Assign the handle.
					args = fill(args, (UInt8)BOOLEAN(put));
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
					for (int i = _arguments - 1; i >= 0; --i) {
						const int j = ARG0 - i;
						emit(bytes, context, (Int16)j);
					}
				} else {
					_scheduled = ScheduledStart(
						target, bytes->pointer(), args, overflow,
						put, handle
					);
					reserve(bytes, context, _arguments * WORD_SIZE);
					for (int i = _arguments - 1; i >= 0; --i) {
						const int j = ARG0 - i;
						_indices.push_back(j);
					}
				}

				// Emit a `VM_POP` instruction to remove the thread arguments.
				if (_arguments > 0) {
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * _arguments);
					args = fill(args, (UInt8)_arguments);
				}

				// Check the stack footprint.
				CHECK_COUNTER(ctx, onError);
			} else {
				// Set the stack footprint guard.
				COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
				COUNTER_GUARD(ctx, stk);

				// FEAT: OPTIMIZATION.
				// Omit pushing temporary value for thread handle preservation since the VM doesn't use it.
				const bool optimize = ctx.expression.optimize;

				// Emit a `VM_PUSH` instruction to reserve for the thread handle temporarily.
				const bool withDeclaring = ctx.declaration.declaring != -1;
				if (!optimize && !withDeclaring) {
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)NULL);
				}

				// Emit the thread arguments.
				if (_arguments > 0)
					writeChildren(bytes, context, Range((int)_children.size() - 1, 1), stk, onError);

				// Emit a `VM_BEGIN_THREAD` instruction.
				SourceLocation target;
				if (dest.isLeft())
					target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
				else
					target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
				const RomLocation* romLocation = ctx.find(target);
				const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
				const bool put = withDeclaring;
				const int handle = withDeclaring ?
					ctx.declaration.declaring : (
						optimize ?
							(int)NULL :
							ARG0 - _arguments
					);
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::BEGIN_THREAD]);
				if (romLocation) {
					args = fill(args, (UInt8)_arguments);
					args = fill(args, (Int16)handle); // Assign the handle.
					args = fill(args, (UInt8)BOOLEAN(put));
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
					for (int i = _arguments - 1; i >= 0; --i) {
						const int j = ARG0 - i;
						emit(bytes, context, (Int16)j);
					}
				} else {
					_scheduled = ScheduledStart(
						target, bytes->pointer(), args, overflow,
						put, handle
					);
					reserve(bytes, context, _arguments * WORD_SIZE);
					for (int i = _arguments - 1; i >= 0; --i) {
						const int j = ARG0 - i;
						_indices.push_back(j);
					}
				}

				// Emit a `VM_POP` instruction to remove the thread arguments.
				if (_arguments > 0) {
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * _arguments);
					args = fill(args, (UInt8)_arguments);
				}

				// Emit a `VM_PUSH_VALUE` to store the temporary result of a declaration.
				// The variable is double assigned with the `VM_BEGIN_THREAD` instruction and the `VM_SET` later.
				// This one is used to keep compatible with the declaration statements.
				if (withDeclaring) {
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]); INC_COUNTER(stk, 2);
					args = fill(args, (Int16)handle);
				}

				// Emit a `VM_POP` instruction if isn't emitting during a declration to remove the temporary handle.
				if (!optimize && !withDeclaring) {
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)1);
				}

				// Check the stack footprint.
				CHECK_COUNTER(ctx, onError);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		const RomLocation* romLocation = nullptr;
		findDestination(ctx, _scheduled.target, &romLocation, onError);
		if (!romLocation)
			return;

		const int address = ctx.startAddress + romLocation->address;
		Byte* args = _scheduled.args(bytes->pointer());
		args = fill(args, (UInt8)_arguments);
		args = fill(args, (Int16)_scheduled.declaring);
		args = fill(args, (UInt8)BOOLEAN(_scheduled.put));
		args = fill(args, (UInt16)address);
		args = fill(args, (UInt8)romLocation->bank);
		for (int j : _indices) {
			args = fill(args, (Int16)j);
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("START");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "START");
	}
	using Node::dump;
};

class NodeJoin : public Node {
public:
	NodeJoin() {
	}
	virtual ~NodeJoin() override {
	}

	NODE_TYPE(Types::JOIN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "join")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Emit the instruction.
			Ptr start = getInplaceStart();
			if (!start) { // `JOIN id`.
				// Emit a `VM_JOIN` instruction.
				Token::Ptr simpleTk = onlyTokenInOnlyChild();
				if (!(simpleTk && simpleTk->is(Token::Types::IDENTIFIER))) { THROW_INVALID_SYNTAX(onError); }
				const std::string id = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
				int data = 0;
				if (ramLocation) {
					data = ramLocation->address;
				} else {
					if (!fuzzyName.empty()) {
						THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
					}

					THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
				}

				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JOIN]);
				args = fill(args, (Int16)data);
			} else { // `JOIN START ...`.
				// Check the children.
				if (_children.empty()) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() == 1) {
					// Do nothing.
				} else if (_children.size() > 1) {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				// Set the stack footprint guard.
				VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
				COUNTER_GUARD(ctx, stk);

				// Emit the instruction.
				do {
					// Emit the argument from the child.
					VAR_GUARD(ctx.expect.lnno, false);
					VAR_GUARD(ctx.declaration.declaring, top().inRam.address);
					VAR_GUARD(
						ctx.expression.category,
						Context::Expression::Categories::EVALUATION
					);
					VAR_GUARD(ctx.expression.endian, Endians::LITTLE);

					start->generate(bytes, context, onError);

					// Emit a `VM_JOIN` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::JOIN]);
					args = fill(args, (Int16)ARG0);

					// Emit a `VM_POP` instruction to remove the argument.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)1);
				} while (false);

				// Check the stack footprint.
				CHECK_COUNTER(ctx, onError);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("JOIN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "JOIN");
	}
	using Node::dump;

private:
	Ptr getInplaceStart(void) const {
		auto child = [] (const Array &children_, Types type) -> Ptr {
			if (children_.size() != 1)
				return nullptr;
			Ptr child = children_.front();
			if (child->type() != type)
				return nullptr;

			return child;
		};

		Ptr expr = child(allChildren(), INode::Types::EXPRESSION);
		if (!expr)
			return nullptr;

		Ptr start = child(expr->allChildren(), INode::Types::START);
		if (!start)
			return nullptr;

		const bool inplace = (bool)start->options("inplace_join");
		if (!inplace)
			return nullptr;

		return start;
	}
};

class NodeKill : public Node {
public:
	NodeKill() {
	}
	virtual ~NodeKill() override {
	}

	NODE_TYPE(Types::KILL)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "kill")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Emit a `VM_TERMINATE` instruction.
			int data = 0;
			bool all = false;
			if (_children.empty()) {
				all = true;
			} else {
				Token::Ptr simpleTk = onlyTokenInOnlyChild();
				if (!(simpleTk && simpleTk->is(Token::Types::IDENTIFIER))) { THROW_INVALID_SYNTAX(onError); }
				const std::string id = (std::string)simpleTk->data();
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
				if (ramLocation) {
					data = ramLocation->address;
				} else {
					if (!fuzzyName.empty()) {
						THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, simpleTk, fuzzyName);
					}

					THROW_ID_HAS_NOT_BEEN_DECLARED(onError, simpleTk);
				}
			}

			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::TERMINATE]);
			args = fill(args, (UInt8)BOOLEAN(all));
			args = fill(args, (Int16)data);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("KILL");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "KILL");
	}
	using Node::dump;
};

class NodeWait : public Node {
public:
	NodeWait() {
	}
	virtual ~NodeWait() override {
	}

	NODE_TYPE(Types::WAIT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Get the optional argument.
			int frames = -1;
			if (_children.empty()) {
				// Do nothing.
			} else if (_children.size() == 1) {
				Token::Ptr tk = firstTokenInChildren();
				CHECK_FOR_INTEGER_OR_IDENTIFIER(onError, tk);
				frames = (int)tk->data();
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "wait")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit a `VM_WAIT` or `VM_WAIT_N` instruction.
			if (frames <= 0) {
				emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::WAIT]);
			} else {
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
				args = fill(args, (UInt16)frames);

				args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::WAIT_N]);
				args = fill(args, (Int16)ARG0);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("WAIT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "WAIT");
	}
	using Node::dump;
};

class NodeLock : public Node {
public:
	NodeLock() {
	}
	virtual ~NodeLock() override {
	}

	NODE_TYPE(Types::LOCK)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Get the optional argument.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "lock")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit a `VM_LOCK` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::LOCK]);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("LOCK");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "LOCK");
	}
	using Node::dump;
};

class NodeUnlock : public Node {
public:
	NodeUnlock() {
	}
	virtual ~NodeUnlock() override {
	}

	NODE_TYPE(Types::UNLOCK)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Get the optional argument.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "unlock")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit a `VM_UNLOCK` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::UNLOCK]);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("UNLOCK");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "UNLOCK");
	}
	using Node::dump;
};

class NodeArg : public Node { // FEAT: OBSOLETE.
public:
	NodeArg() {
	}
	virtual ~NodeArg() override {
	}

	NODE_TYPE(Types::ARG)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "arg")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			THROW_OBSOLETE_SYNTAX(onError);

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Increase the counter because the local stack doesn't match the global counter statically,
					// so we need to count an extra frame manually.
					INC_COUNTER(stk, 2);

					// Emit a `VM_GET_TLOCAL` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::GET_TLOCAL]);
					args = fill(args, (Int16)ARG1);
					args = fill(args, (Int16)ARG0);

					// Emit a `VM_POP_1` instruction to remove the argument.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP_1]); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)1);
				}, withDeclaring ? 0 : 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("ARG");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ARG");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Scope
*/

class NodeBeginDo : public Node {
public:
	NodeBeginDo() {
	}
	virtual ~NodeBeginDo() override {
	}

	NODE_TYPE(Types::BEGIN_DO)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() != 1) {
				THROW_INVALID_SYNTAX(onError);
			}

			// Emit the statements of the body.
			Node::generate(bytes, context, Range(0), onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("BEGIN DO");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "BEGIN DO");
	}
	using Node::dump;
};

class NodeBeginDef : public Node { // FEAT: MACRO.
private:
	MacroFunctionTable _macroFunctionTable;

public:
	NodeBeginDef() {
	}
	virtual ~NodeBeginDef() override {
	}

	NODE_TYPE(Types::BEGIN_DEF)

	virtual void options(const IDictionary::Ptr &options) override {
		_macroFunctionTable = *(const MacroFunctionTable*)(void*)options->get("macro_function_table");
	}

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() != 1) {
				THROW_INVALID_SYNTAX(onError);
			}

			// Emit the statements of the body.
			if (ctx.macroFunctions) {
				ctx.macroFunctions->push(_macroFunctionTable);
				{
					Node::generate(bytes, context, Range(0), onError);
				}
				ctx.macroFunctions->pop();
			} else {
				Node::generate(bytes, context, Range(0), onError);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("BEGIN DEF");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "BEGIN DEF");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Macro
*/

/**
 * @brief Base class for all macro-based nodes.
 */
class NodeMacro : public Node {
public:
	NodeMacro() {
	}
	virtual ~NodeMacro() override {
	}

	virtual void generate(Bytes::Ptr &/* bytes */, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		Token::Ptr idtk = nullptr;
		std::string id;
		if (ctx.expect.lnno) {
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
			})) { THROW_INVALID_SYNTAX(onError); }
		}
		if (!consume(Token::Types::KEYWORD, "def")) { THROW_INVALID_SYNTAX(onError); }
		if (!consume([&] (Token::Ptr tk) -> void {
			idtk = tk;
			id = (std::string)tk->data();
		})) { THROW_INVALID_SYNTAX(onError); }
		if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }

		// Put the code to ROM location correspondence.
		context.top().put(top().inCode, top().inRom);
	}
};

class NodeDefMacroAlias : public NodeMacro {
public:
	NodeDefMacroAlias() {
	}
	virtual ~NodeDefMacroAlias() override {
	}

	NODE_TYPE(Types::DEF_MACRO_ALIAS)

	virtual Abstract abstract(void) const override {
		return abstract("DEF MACRO ALIAS");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEF MACRO ALIAS");
	}
	using Node::dump;
};

class NodeDefFn : public NodeMacro {
public:
	NodeDefFn() {
	}
	virtual ~NodeDefFn() override {
	}

	NODE_TYPE(Types::DEF_FN)

	virtual void generate(Bytes::Ptr &/* bytes */, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		Token::Ptr idtk = nullptr;
		std::string id;
		if (ctx.expect.lnno) {
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
			})) { THROW_INVALID_SYNTAX(onError); }
		}
		if (!consume(Token::Types::KEYWORD, "def")) { THROW_INVALID_SYNTAX(onError); }
		if (!consume(Token::Types::KEYWORD, "fn")) { /* Do nothing. */ }
		if (!consume([&] (Token::Ptr tk) -> void {
			idtk = tk;
			id = (std::string)tk->data();
		})) { THROW_INVALID_SYNTAX(onError); }
		if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
		if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
		if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }

		// Put the code to ROM location correspondence.
		context.top().put(top().inCode, top().inRom);
	}

	virtual Abstract abstract(void) const override {
		return abstract("DEF FN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEF FN");
	}
	using Node::dump;
};

class NodeFn : public Node { // FEAT: MACRO.
public:
	NodeFn() {
	}
	virtual ~NodeFn() override {
	}

	NODE_TYPE(Types::FN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			if (!ctx.macroFunctions) { THROW_TABLE_IS_NOT_INITIALIZED(onError); }
			const MacroFunctionTable::Entry* entry = ctx.macroFunctions->find(id); // FEAT: MACRO.
			if (!entry) { THROW_INVALID_SYNTAX(onError); }
			if (_children.size() < entry->parameters.size()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() > entry->parameters.size()) {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the macro function evaluation.
			do {
				// Emit the arguments.
				if (!_children.empty())
					writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

				// Set the macro function guard.
				VAR_GUARD(ctx.expression.alwaysEvaluate, true); // To avoid a no-parameter evaluation issue.
				VAR_GUARD(ctx.expression.macroFunctions, entry);

				// Emit the expression.
				const Counter oldStk = stk;
				entry->expression->generate(bytes, context, onError);
				const bool polluted = stk != oldStk && stk.value > oldStk.value;

				// Emit a `VM_POP_1` instruction to remove the arguments.
				if (polluted) { // Emit it only when the stack is polluted, in other words, the expression has generated something that affects the stack.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP_1]); DEC_COUNTER(stk, 2 * (int)_children.size());
					args = fill(args, (UInt8)_children.size());
				}
			} while (false);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("FN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "FN");
	}
	using Node::dump;
};

class NodeDefConstant : public NodeMacro {
public:
	NodeDefConstant() {
	}
	virtual ~NodeDefConstant() override {
	}

	NODE_TYPE(Types::DEF_CONSTANT)

	virtual Abstract abstract(void) const override {
		return abstract("DEF CONSTANT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEF CONSTANT");
	}
	using Node::dump;
};

class NodeDefIdentifierAlias : public NodeMacro {
public:
	NodeDefIdentifierAlias() {
	}
	virtual ~NodeDefIdentifierAlias() override {
	}

	NODE_TYPE(Types::DEF_IDENTIFIER_ALIAS)

	virtual Abstract abstract(void) const override {
		return abstract("DEF IDENTIFIER ALIAS");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEF IDENTIFIER ALIAS");
	}
	using Node::dump;
};

class NodeDefStackN : public NodeMacro {
public:
	NodeDefStackN() {
	}
	virtual ~NodeDefStackN() override {
	}

	NODE_TYPE(Types::DEF_STACK_N)

	virtual Abstract abstract(void) const override {
		return abstract("DEF STACKN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEF STACKN");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Basic functions
*/

class NodeLocate : public Node {
public:
	NodeLocate() {
	}
	virtual ~NodeLocate() override {
	}

	NODE_TYPE(Types::LOCATE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "locate")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the evaluations.
			if (!_children.empty())
				writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

			// Emit a `VM_LOCATE` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::LOCATE]);
			args = fill(args, (Int16)ARG0);
			args = fill(args, (Int16)ARG1);

			// Emit a `VM_POP` instruction to remove the temporary values.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * 2);
			args = fill(args, (UInt8)2);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("LOCATE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "LOCATE");
	}
	using Node::dump;
};

class NodePrint : public Node {
public:
	NodePrint() {
	}
	virtual ~NodePrint() override {
	}

	NODE_TYPE(Types::PRINT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		replenishFormatted<NodeExpression>(context, 0);

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			bool newLine = true;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "print")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::OPERATOR, ";")) { newLine = false; }

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// FEAT: TEXT FORMAT.
			// Writing layout:
			//   argument evaluations
			//   the `VM_PRINT` instruction
			//     the argument count (C function argument)
			//     the new line mode (C function argument)
			//   the arguments from front to back
			//   the format text in string, with termination point
			// Emit a `VM_PRINT` instruction.
			writeFormatted(bytes, context, stk, Asm::Types::PRINT, 0, &newLine, onError);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PRINT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PRINT");
	}
	using Node::dump;
};

class NodePeek : public Node {
public:
	NodePeek() {
	}
	virtual ~NodePeek() override {
	}

	NODE_TYPE(Types::PEEK)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "peek")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the arguments.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit a `VM_PEEK` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PEEK]);
					args = fill(args, (UInt8)FALSE);
					args = fill(args, (Int16)ARG0);
					args = fill(args, (Int16)ARG1);
				}, 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PEEK");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PEEK");
	}
	using Node::dump;
};

class NodePoke : public Node {
public:
	NodePoke() {
	}
	virtual ~NodePoke() override {
	}

	NODE_TYPE(Types::POKE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "poke")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the evaluations.
			writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

			// Emit a `VM_POKE` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POKE]);
			args = fill(args, (UInt8)FALSE);
			args = fill(args, (Int16)ARG0);
			args = fill(args, (Int16)ARG1);

			// Emit a `VM_POP` instruction to remove the temporary values.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * 2);
			args = fill(args, (UInt8)2);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("POKE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "POKE");
	}
	using Node::dump;
};

class NodePeekW : public Node {
public:
	NodePeekW() {
	}
	virtual ~NodePeekW() override {
	}

	NODE_TYPE(Types::PEEKW)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "peekw")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the arguments.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit a `VM_PEEK` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PEEK]);
					args = fill(args, (UInt8)TRUE);
					args = fill(args, (Int16)ARG0);
					args = fill(args, (Int16)ARG1);
				}, 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PEEKW");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PEEKW");
	}
	using Node::dump;
};

class NodePokeW : public Node {
public:
	NodePokeW() {
	}
	virtual ~NodePokeW() override {
	}

	NODE_TYPE(Types::POKEW)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "pokew")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the evaluations.
			writeChildren(bytes, context, Range(0, (int)_children.size() - 1), stk, onError);

			// Emit a `VM_POKE` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POKE]);
			args = fill(args, (UInt8)TRUE);
			args = fill(args, (Int16)ARG0);
			args = fill(args, (Int16)ARG1);

			// Emit a `VM_POP` instruction to remove the temporary values.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * 2);
			args = fill(args, (UInt8)2);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("POKEW");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "POKEW");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Stack operations
*/

class NodeReserve : public Node {
public:
	NodeReserve() {
	}
	virtual ~NodeReserve() override {
	}

	NODE_TYPE(Types::RESERVE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "reserve")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the specific instruction to reserve a number of slots.
			if (_children.empty()) {
				// Emit a `VM_RESERVE` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RESERVE]); INC_COUNTER(stk, 2);
				args = fill(args, (Int8)1);
			} else {
				// Emit a `VM_RESERVE` instruction.
				Token::Ptr tk = nullptr;
				int val = 0;
				if (!isInt8(context, 0, val, &tk)) { THROW_TYPE_EXPECTED(onError, "8-bit integer constant", tk); }
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RESERVE]); INC_COUNTER(stk, 2 * val);
				args = fill(args, (Int8)val);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RESERVE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RESERVE");
	}
	using Node::dump;
};

class NodePush : public Node {
public:
	NodePush() {
	}
	virtual ~NodePush() override {
	}

	NODE_TYPE(Types::PUSH)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "push")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the specific instruction to push a value.
			if (_children.empty()) {
				// Emit a `VM_PUSH` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]);
				args = fill(args, (UInt16)0);
			} else {
				if (ctx.expression.optimize) {
					// FEAT: OPTIMIZATION.
					// Emit the argument from the child.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Do not need to do push since the value is already on the stack.
				} else {
					// Emit the argument from the child.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit a `VM_PUSH_VALUE` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH_VALUE]);
					args = fill(args, (UInt8)ARG0);

					// Emit a `VM_POP_1` instruction to remove the argument.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP_1]); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)1);
				}
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PUSH");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PUSH");
	}
	using Node::dump;
};

class NodePop : public Node {
public:
	NodePop() {
	}
	virtual ~NodePop() override {
	}

	NODE_TYPE(Types::POP)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "pop")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the specific instruction to pop a value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			if (withDeclaring) {
				// Increase the counter because the local stack doesn't match the global counter statically,
				// so we need to count an extra frame manually.
				INC_COUNTER(stk, 2);

				// Do nothing here, because we are trying to retrieve the top value to an outter declaration
				// then pop it, and that is what will happen in the outter declaration later.
			} else {
				// Emit a `VM_POP` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]);
				args = fill(args, (UInt8)1);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("POP");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "POP");
	}
	using Node::dump;
};

class NodeTop : public Node {
public:
	NodeTop() {
	}
	virtual ~NodeTop() override {
	}

	NODE_TYPE(Types::TOP)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "top")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET]);
					args = fill(args, (Int16)ARG1);
					args = fill(args, (Int16)ARG0);
				}, withDeclaring ? 0 : 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("TOP");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "TOP");
	}
	using Node::dump;
};

class NodeStack : public Node {
public:
	NodeStack() {
	}
	virtual ~NodeStack() override {
	}

	NODE_TYPE(Types::STACK)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "stack")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			Token::Ptr simpleTk = onlyTokenInOnlyChild();
			if (simpleTk && simpleTk->is(Token::Types::NUMBER)) {
				const Int index = (Int)simpleTk->data();
				if (index >= COMPILER_STACK_ARGUMENT_MAX_COUNT || index - 1 < -COMPILER_STACK_ARGUMENT_MAX_COUNT) {
					THROW_INVALID_EXPRESSION(onError, simpleTk);
				}
				writeRightHand(
					bytes, context, stk,
					[&] (void) -> void {
						// Emit a `VM_GET_TLOCAL` instruction.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::GET_TLOCAL]);
						args = fill(args, (Int16)(index < 0 ? index - 1 : index));
						args = fill(args, (Int16)ARG0);
					}, withDeclaring ? 0 : 1, true,
					onError
				);
			} else {
				THROW_TYPE_EXPECTED(onError, "Integer constant", simpleTk);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("STACK");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "STACK");
	}
	using Node::dump;
};

class NodeStackN : public Node {
private:
	int _index = 0;

public:
	NodeStackN(int idx) {
		_index = idx;
	}
	virtual ~NodeStackN() override {
	}

	NODE_TYPE(Types::STACK_N)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			const std::string key = "stack" + Text::toString(_index);
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::OPERATOR, key)) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_GET_TLOCAL` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::GET_TLOCAL]);
					args = fill(args, (Int16)(_index < 0 ? _index - 1 : _index));
					args = fill(args, (Int16)ARG0);
				}, withDeclaring ? 0 : 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		const std::string name = "STACK" + Text::toString(_index);

		return abstract(name.c_str());
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		const std::string name = "STACK" + Text::toString(_index);

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Memory operators
*/

class NodePack : public Node {
public:
	NodePack() {
	}
	virtual ~NodePack() override {
	}

	NODE_TYPE(Types::PACK)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		typedef std::vector<int> Indices;

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "pack")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 2) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Get the children.
					Indices vars;
					vars.push_back(0);
					vars.push_back(0);
					Indices exprs;
					int arg = ARG0;

					for (int i = (int)_children.size() - 1; i >= 0; --i) {
						// Get the token.
						const Ptr &child = _children[i];
						Token::Ptr idtk = nullptr;
						std::string id;
						idtk = child->onlyToken();
						if (idtk) id = (std::string)idtk->data();

						// Find the ID in RAM.
						RamLocation inRam;
						const RamLocation* ramLocation = id.empty() ? nullptr : ctx.findPageAndGlobal(id);

						// Determine whether it's a variable or expression.
						if (ramLocation) {
							inRam = *ramLocation;
							vars.push_back(inRam.address);
						} else {
							vars.push_back(arg--);
							exprs.push_back(i);
						}
					}

					vars.push_back(arg); // For return value.

					// Emit the instructions.
					do {
						// Emit the expression arguments.
						for (int i = (int)exprs.size() - 1; i >= 0; --i) {
							const int j = exprs[i];
							writeChildren(bytes, context, Range(j), stk, onError);
						}

						// Emit a `VM_PACK` instruction.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PACK]);
						args = fill(args, (UInt8)FALSE);
						for (int a : vars)
							args = fill(args, (Int16)a);
	
						// Emit a `VM_POP` instruction to remove the temporary values.
						if (!exprs.empty()) {
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * (int)exprs.size());
							args = fill(args, (UInt8)exprs.size());
						}
					} while (false);
				}, withDeclaring ? 0 : 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PACK");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PACK");
	}
	using Node::dump;
};

class NodeUnpack : public Node {
public:
	NodeUnpack() {
	}
	virtual ~NodeUnpack() override {
	}

	NODE_TYPE(Types::UNPACK)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "unpack")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 3) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 3) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the children.
			const Ptr &child1 = _children[0];
			Token::Ptr idtk1 = nullptr;
			std::string id1;
			idtk1 = child1->onlyToken();
			if (!idtk1) { THROW_INVALID_SYNTAX(onError); }
			id1 = (std::string)idtk1->data();

			const Ptr &child2 = _children[1];
			Token::Ptr idtk2 = nullptr;
			std::string id2;
			idtk2 = child2->onlyToken();
			if (!idtk2) { THROW_INVALID_SYNTAX(onError); }
			id2 = (std::string)idtk2->data();

			const Ptr &child3 = _children[2];
			Token::Ptr idtk3 = nullptr;
			std::string id3;
			idtk3 = child3->onlyToken();
			if (!idtk3) { THROW_INVALID_SYNTAX(onError); }
			id3 = (std::string)idtk3->data();

			// Find the ID in RAM.
			RamLocation inRam1;
			std::string fuzzyName1;
			const RamLocation* ramLocation1 = ctx.findPageAndGlobal(id1, fuzzyName1);
			if (ramLocation1) {
				inRam1 = *ramLocation1;
			} else {
				if (!fuzzyName1.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk1, fuzzyName1);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk1);
			}

			RamLocation inRam2;
			std::string fuzzyName2;
			const RamLocation* ramLocation2 = ctx.findPageAndGlobal(id2, fuzzyName2);
			if (ramLocation2) {
				inRam2 = *ramLocation2;
			} else {
				if (!fuzzyName2.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk2, fuzzyName2);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk2);
			}

			RamLocation inRam3;
			std::string fuzzyName3;
			const RamLocation* ramLocation3 = ctx.findPageAndGlobal(id3, fuzzyName3);
			if (ramLocation3) {
				inRam3 = *ramLocation3;
			} else {
				if (!fuzzyName3.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk3, fuzzyName3);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk3);
			}

			// Emit a `VM_UNPACK` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::UNPACK]);
			args = fill(args, (UInt8)FALSE);
			args = fill(args, (Int16)0);
			args = fill(args, (Int16)0);
			args = fill(args, (Int16)inRam3.address);
			args = fill(args, (Int16)inRam2.address);
			args = fill(args, (Int16)inRam1.address);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("UNPACK");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "UNPACK");
	}
	using Node::dump;
};

class NodePackN : public Node {
public:
	NodePackN() {
	}
	virtual ~NodePackN() override {
	}

	NODE_TYPE(Types::PACKN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		typedef std::vector<int> Indices;

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "packn")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 4) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 4) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Get the children.
					Indices vars;
					Indices exprs;
					int arg = ARG0;

					for (int i = (int)_children.size() - 1; i >= 0; --i) {
						// Get the token.
						const Ptr &child = _children[i];
						Token::Ptr idtk = nullptr;
						std::string id;
						idtk = child->onlyToken();
						if (idtk) id = (std::string)idtk->data();

						// Find the ID in RAM.
						RamLocation inRam;
						const RamLocation* ramLocation = id.empty() ? nullptr : ctx.findPageAndGlobal(id);

						// Determine whether it's a variable or expression.
						if (ramLocation) {
							inRam = *ramLocation;
							vars.push_back(inRam.address);
						} else {
							vars.push_back(arg--);
							exprs.push_back(i);
						}
					}

					vars.push_back(arg); // For return value.

					// Emit the instructions.
					do {
						// Emit the expression arguments.
						for (int i = (int)exprs.size() - 1; i >= 0; --i) {
							const int j = exprs[i];
							writeChildren(bytes, context, Range(j), stk, onError);
						}

						// Emit a `VM_PACK` instruction.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PACK]);
						args = fill(args, (UInt8)TRUE);
						for (int a : vars)
							args = fill(args, (Int16)a);

						// Emit a `VM_POP` instruction to remove the temporary values.
						if (!exprs.empty()) {
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2 * (int)exprs.size());
							args = fill(args, (UInt8)exprs.size());
						}
					} while (false);
				}, withDeclaring ? 0 : 1, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PACKN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PACKN");
	}
	using Node::dump;
};

class NodeUnpackN : public Node {
public:
	NodeUnpackN() {
	}
	virtual ~NodeUnpackN() override {
	}

	NODE_TYPE(Types::UNPACKN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "unpackn")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 5) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 5) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the children.
			const Ptr &child1 = _children[0];
			Token::Ptr idtk1 = nullptr;
			std::string id1;
			idtk1 = child1->onlyToken();
			if (!idtk1) { THROW_INVALID_SYNTAX(onError); }
			id1 = (std::string)idtk1->data();

			const Ptr &child2 = _children[1];
			Token::Ptr idtk2 = nullptr;
			std::string id2;
			idtk2 = child2->onlyToken();
			if (!idtk2) { THROW_INVALID_SYNTAX(onError); }
			id2 = (std::string)idtk2->data();

			const Ptr &child3 = _children[2];
			Token::Ptr idtk3 = nullptr;
			std::string id3;
			idtk3 = child3->onlyToken();
			if (!idtk3) { THROW_INVALID_SYNTAX(onError); }
			id3 = (std::string)idtk3->data();

			const Ptr &child4 = _children[3];
			Token::Ptr idtk4 = nullptr;
			std::string id4;
			idtk4 = child4->onlyToken();
			if (!idtk4) { THROW_INVALID_SYNTAX(onError); }
			id4 = (std::string)idtk4->data();

			const Ptr &child5 = _children[4];
			Token::Ptr idtk5 = nullptr;
			std::string id5;
			idtk5 = child5->onlyToken();
			if (!idtk5) { THROW_INVALID_SYNTAX(onError); }
			id5 = (std::string)idtk5->data();

			// Find the ID in RAM.
			RamLocation inRam1;
			std::string fuzzyName1;
			const RamLocation* ramLocation1 = ctx.findPageAndGlobal(id1, fuzzyName1);
			if (ramLocation1) {
				inRam1 = *ramLocation1;
			} else {
				if (!fuzzyName1.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk1, fuzzyName1);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk1);
			}

			RamLocation inRam2;
			std::string fuzzyName2;
			const RamLocation* ramLocation2 = ctx.findPageAndGlobal(id2, fuzzyName2);
			if (ramLocation2) {
				inRam2 = *ramLocation2;
			} else {
				if (!fuzzyName2.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk2, fuzzyName2);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk2);
			}

			RamLocation inRam3;
			std::string fuzzyName3;
			const RamLocation* ramLocation3 = ctx.findPageAndGlobal(id3, fuzzyName3);
			if (ramLocation3) {
				inRam3 = *ramLocation3;
			} else {
				if (!fuzzyName3.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk3, fuzzyName3);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk3);
			}

			RamLocation inRam4;
			std::string fuzzyName4;
			const RamLocation* ramLocation4 = ctx.findPageAndGlobal(id4, fuzzyName4);
			if (ramLocation4) {
				inRam4 = *ramLocation4;
			} else {
				if (!fuzzyName4.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk4, fuzzyName4);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk4);
			}

			RamLocation inRam5;
			std::string fuzzyName5;
			const RamLocation* ramLocation5 = ctx.findPageAndGlobal(id5, fuzzyName5);
			if (ramLocation5) {
				inRam5 = *ramLocation5;
			} else {
				if (!fuzzyName5.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk5, fuzzyName5);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk5);
			}

			// Emit a `VM_UNPACK` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::UNPACK]);
			args = fill(args, (UInt8)TRUE);
			args = fill(args, (Int16)inRam5.address);
			args = fill(args, (Int16)inRam4.address);
			args = fill(args, (Int16)inRam3.address);
			args = fill(args, (Int16)inRam2.address);
			args = fill(args, (Int16)inRam1.address);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("UNPACKN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "UNPACKN");
	}
	using Node::dump;
};

class NodeSwap : public Node {
public:
	NodeSwap() {
	}
	virtual ~NodeSwap() override {
	}

	NODE_TYPE(Types::SWAP)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "swap")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 2) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the children.
			const Ptr &child1 = _children.front();
			Token::Ptr idtk1 = nullptr;
			std::string id1;
			idtk1 = child1->onlyToken();
			if (!idtk1) { THROW_INVALID_SYNTAX(onError); }
			id1 = (std::string)idtk1->data();

			const Ptr &child2 = _children.back();
			Token::Ptr idtk2 = nullptr;
			std::string id2;
			idtk2 = child2->onlyToken();
			if (!idtk2) { THROW_INVALID_SYNTAX(onError); }
			id2 = (std::string)idtk2->data();

			// Find the ID in RAM.
			RamLocation inRam1;
			std::string fuzzyName1;
			const RamLocation* ramLocation1 = ctx.findPageAndGlobal(id1, fuzzyName1);
			if (ramLocation1) {
				inRam1 = *ramLocation1;
			} else {
				if (!fuzzyName1.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk1, fuzzyName1);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk1);
			}

			RamLocation inRam2;
			std::string fuzzyName2;
			const RamLocation* ramLocation2 = ctx.findPageAndGlobal(id2, fuzzyName2);
			if (ramLocation2) {
				inRam2 = *ramLocation2;
			} else {
				if (!fuzzyName2.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk2, fuzzyName2);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk2);
			}

			// Emit a `VM_SWAP` instruction to swap the two variables.
			if (inRam1.address != inRam2.address) {
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SWAP]);
				args = fill(args, (Int16)inRam2.address);
				args = fill(args, (Int16)inRam1.address);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SWAP");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SWAP");
	}
	using Node::dump;
};

class NodeInc : public Node {
public:
	NodeInc() {
	}
	virtual ~NodeInc() override {
	}

	NODE_TYPE(Types::INC)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "inc")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the children.
			const Ptr &child1 = _children.front();
			Token::Ptr idtk1 = nullptr;
			std::string id1;
			idtk1 = child1->onlyToken();
			if (!idtk1) { THROW_INVALID_SYNTAX(onError); }
			id1 = (std::string)idtk1->data();

			// Find the ID in RAM.
			RamLocation inRam1;
			std::string fuzzyName1;
			const RamLocation* ramLocation1 = ctx.findPageAndGlobal(id1, fuzzyName1);
			if (ramLocation1) {
				inRam1 = *ramLocation1;
			} else {
				if (!fuzzyName1.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk1, fuzzyName1);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk1);
			}

			// Emit a `VM_ACC_CONST` instruction to increase the variable.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ACC_CONST]);
			args = fill(args, (Int16)1);
			args = fill(args, (Int16)inRam1.address);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("INC");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "INC");
	}
	using Node::dump;
};

class NodeDec : public Node {
public:
	NodeDec() {
	}
	virtual ~NodeDec() override {
	}

	NODE_TYPE(Types::DEC)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "dec")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the children.
			const Ptr &child1 = _children.front();
			Token::Ptr idtk1 = nullptr;
			std::string id1;
			idtk1 = child1->onlyToken();
			if (!idtk1) { THROW_INVALID_SYNTAX(onError); }
			id1 = (std::string)idtk1->data();

			// Find the ID in RAM.
			RamLocation inRam1;
			std::string fuzzyName1;
			const RamLocation* ramLocation1 = ctx.findPageAndGlobal(id1, fuzzyName1);
			if (ramLocation1) {
				inRam1 = *ramLocation1;
			} else {
				if (!fuzzyName1.empty()) {
					THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk1, fuzzyName1);
				}

				THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk1);
			}

			// Emit a `VM_ACC_CONST` instruction to decrease the variable.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ACC_CONST]);
			args = fill(args, (Int16)-1);
			args = fill(args, (Int16)inRam1.address);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("DEC");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DEC");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Inline data sequence
*/

class NodeData : public Node {
public:
	NodeData() {
	}
	virtual ~NodeData() override {
	}

	NODE_TYPE(Types::DATA)

	virtual void generate(Bytes::Ptr &/* bytes */, Context::Stack &context, Error::Handler onError) override {
		// Prepare.
		Context &ctx = context.top();
		State &state = top();

		// Determine the location in the ROM.
		state.inRom.bank = ctx.bank;
		state.inRom.address = ctx.addressCursor;
		state.inRom.size = 0;

		// Consume the tokens.
		if (ctx.expect.lnno) {
			if (!consume([&] (Token::Ptr tk) -> void {
				state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
			})) { THROW_INVALID_SYNTAX(onError); }
		}
		if (consume(Token::Types::KEYWORD, "repeat")) { /* Do nothing. */ }

		// Put the code to ROM location correspondence.
		context.top().put(top().inCode, top().inRom);
	}

	virtual Abstract abstract(void) const override {
		return abstract("DATA");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "DATA");
	}
	using Node::dump;
};

class NodeRead : public Node {
public:
	NodeRead() {
	}
	virtual ~NodeRead() override {
	}

	NODE_TYPE(Types::READ)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::IntegerTypes int_ = Token::IntegerTypes::UNSPECIFIED;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "read")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "int")) { int_ = Token::IntegerTypes::INT; }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the data.
#if DATA_SEQUENCE_WITH_CONSTANT_ONLY
			if (!ctx.data || ctx.data->empty()) { THROW_NO_DATA(onError); }
#endif /* DATA_SEQUENCE_WITH_CONSTANT_ONLY */

			// Iterate all children.
			for (const Ptr &child : _children) {
				Token::Ptr idtk = nullptr;
				std::string id;
				bool copy = false;
				int skip = 0;
				idtk = child->onlyToken();
				if (!idtk) { THROW_INVALID_SYNTAX(onError); }
				copy = idtk->is(Token::Types::IDENTIFIER);
				if (copy) {
					id = (std::string)idtk->data();
				} else {
					skip = (int)idtk->data();
					if (skip < 0) { THROW_OUT_OF_BOUNDS(onError); }
				}

				// Find the left hand ID in RAM.
				bool isArray = false;
				if (copy) {
					std::string fuzzyName;
					const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
					if (ramLocation) {
						const RamLocation inRam = *ramLocation;
						top().inRam = inRam;

						const Context::Array::Dimensions* dimensions = ctx.array->find(id);
						isArray = !!dimensions;
						if (isArray && int_ != Token::IntegerTypes::UNSPECIFIED) { THROW_INVALID_SYNTAX(onError); }
					} else { // Declaration.
#if DECLARE_WITH_READ_ENABLED
						const TextLocation &txtLoc = idtk->begin();
						if (!allocateHeap(ctx, ctx.heapSize, WORD_SIZE, id, RamLocation::Usages::READ, txtLoc)) {
							if (allocateHeap(ctx, ctx.heapSize * 2, WORD_SIZE, id, RamLocation::Usages::READ, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
							else { THROW_HEAP_OVERFLOW(onError, false); }
						}
#else /* DECLARE_WITH_READ_ENABLED */
						if (!fuzzyName.empty()) {
							THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
						}

						THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
#endif /* DECLARE_WITH_READ_ENABLED */
					}
				}

				// Emit a `VM_READ` instruction to read from the data reading stream.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::READ]);
				args = fill(args, (UInt8)BOOLEAN(copy ? TRUE : FALSE));
				auto fillByte = [&, copy, skip, isArray] (Byte* &args) -> Byte* {
					if (copy) {
						if (isArray)
							args = fill(args, (UInt16)top().inRam.size); // Read bytes into array.
						else
							args = fill(args, (UInt16)1); // Read a byte into variable.
					} else {
						args = fill(args, (UInt16)skip); // Skip a number of bytes.
					}

					return args;
				};
				auto fillWord = [&, copy, skip] (Byte* &args) -> Byte* {
					if (copy) {
						args = fill(args, (UInt16)2); // Read a word into variable.
					} else {
						args = fill(args, (UInt16)(skip * 2)); // Skip a number of words.
					}

					return args;
				};
				switch (int_) {
				case Token::IntegerTypes::UNSPECIFIED:
					args = fillByte(args);

					break;
				case Token::IntegerTypes::INT:
					args = fillWord(args);

					break;
				default:
					GBBASIC_ASSERT(false && "Not implemented.");

					args = fillByte(args);

					break;
				}
				args = fill(args, (Int16)top().inRam.address);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("READ");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "READ");
	}
	using Node::dump;
};

class NodeRestore : public Node {
private:
	Scheduled _scheduled;

public:
	NodeRestore() {
	}
	virtual ~NodeRestore() override {
	}

	NODE_TYPE(Types::RESTORE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();

			// Get the offset.
			bool noargs = false;
			int page = -1;
			Destination dest(0);
			if (_children.empty()) {
				noargs = true;
			} else if (_children.size() == 1) {
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
				if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "restore")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the data.
#if DATA_SEQUENCE_WITH_CONSTANT_ONLY
			if (!ctx.data || ctx.data->empty()) { THROW_NO_DATA(onError); }
#endif /* DATA_SEQUENCE_WITH_CONSTANT_ONLY */

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Calculate the address.
			int bank = ctx.startBank;
			int address = -1;
			if (noargs) {
				address = 0;
			} else if (dest.isLeft()) {
				if (ctx.data)
					address = ctx.data->find(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
			} else {
				if (ctx.data)
					address = ctx.data->find(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
			}
			if (address == -1) {
#if !DATA_SEQUENCE_WITH_CONSTANT_ONLY
				do {
					if (!dest.isRight())
						break;

					const std::string name = dest.right().get();
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					if (romLocation) { // By builtin name.
						bank = romLocation->bank;
						address = romLocation->address;

						break;
					}

					const RomLocation* scriptMemoryRamLocation = ctx.symbols ? ctx.symbols->find(SCRIPT_MEMORY_ENTRY_NAME) : nullptr; // It's defined in the ROM symbols, although it's RAM location but not ROM.
					const RamLocation* ramLocation = ctx.findPageAndGlobal(name);
					const Context::Array::Dimensions* dimensions = ctx.array->find(name);
					if (scriptMemoryRamLocation && ramLocation) {
						if (dimensions) { // By array name.
							bank = scriptMemoryRamLocation->bank;
							address =
								scriptMemoryRamLocation->address /* start address */ +
								ramLocation->address /* address in RAM as `int16_t*` */ *
									WORD_SIZE /* 2 bytes per word */;

							break;
						}
					}
				} while (false);
#endif /* DATA_SEQUENCE_WITH_CONSTANT_ONLY */
			} else /* if (address != -1) */ { // Is `DATA` sequence.
				const int headSize = INSTRUCTIONS[(Byte)Asm::Types::JUMP_FAR].totalSize();
				address += ctx.startAddress + headSize /* skip the head `VM_JUMP_FAR` instruction */;
			}
			if (address == -1) { THROW_INVALID_DATA_POINT(onError); }

			// Emit a `VM_PUSH` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
			args = fill(args, (UInt16)address); // 0-based.

			// Emit a `VM_RESTORE` instruction.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RESTORE]);
			args = fill(args, (Int16)ARG0);
			args = fill(args, (UInt8)bank);

			// Emit a `VM_POP` instruction.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
			args = fill(args, (UInt8)1);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RESTORE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RESTORE");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Engine routines and functions
*/

class NodeRoutine : public Node {
private:
	std::string _name;
	const DefaultTable* _defaults = nullptr;

public:
	NodeRoutine(const std::string &name) : _name(name) {
	}
	NodeRoutine(const std::string &name, const DefaultTable* defaults) : _name(name), _defaults(defaults) {
	}
	virtual ~NodeRoutine() override {
	}

	NODE_TYPE(Types::ROUTINE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				GBBASIC_ASSERT(id == _name && "Impossible.");
			})) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (!ctx.functions) { THROW_TABLE_IS_NOT_INITIALIZED(onError); }
			const FunctionTable::Entry* entry = ctx.functions->find(id);
			if (!entry) { THROW_INVALID_SYNTAX(onError); }
			if (!_defaults && entry->parameters != (int)_children.size()) { THROW_INVALID_SYNTAX(onError); }
			GBBASIC_ASSERT(entry->returns == 0 && "Impossible.");

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the arguments.
			if (!_defaults || entry->parameters == (int)_children.size()) {
				// Emit the arguments from the children.
				if (!_children.empty())
					writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);
			} else {
				const DefaultTable::Entry* entry_ = _defaults->find((int)_children.size());
				if (entry_) { // Found a default entry.
					int cursor = (int)_children.size() - 1;
					for (int i = (int)entry_->defaults.size() - 1; i >= 0; --i) {
						const int val = entry_->defaults[i];
						if (val == DefaultTable::Entry::PLACEHOLDER) { // Is placeholder.
							if (cursor >= 0) {
								// Emit an argument from the children.
								writeChildren(bytes, context, Range(cursor), stk, onError);
								--cursor;
							} else {
								// Emit a zero.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0);
							}
						} else { // Is a default value.
							// Emit a default value.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)val);
						}
					}
				}
			}

			// Emit the specific instruction.
			const Asm::Types type = entry->type;
			emit(bytes, context, INSTRUCTIONS[(size_t)type]); DEC_COUNTER(stk, 2 * entry->parameters);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return abstract(name.c_str());
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

class NodeFunction : public Node {
private:
	std::string _name;
	const DefaultTable* _defaults = nullptr;

public:
	NodeFunction(const std::string &name) : _name(name) {
	}
	NodeFunction(const std::string &name, const DefaultTable* defaults) : _name(name), _defaults(defaults) {
	}
	virtual ~NodeFunction() override {
	}

	NODE_TYPE(Types::FUNCTION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				GBBASIC_ASSERT(id == _name && "Impossible.");
			})) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (!ctx.functions) { THROW_TABLE_IS_NOT_INITIALIZED(onError); }
			const FunctionTable::Entry* entry = ctx.functions->find(id);
			if (!entry) { THROW_INVALID_SYNTAX(onError); }
			if (!_defaults && entry->parameters != (int)_children.size()) { THROW_INVALID_SYNTAX(onError); }
			GBBASIC_ASSERT(entry->returns == 1 && "Impossible.");

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the arguments.
					if (!_defaults || entry->parameters == (int)_children.size()) {
						// Emit the arguments from the children.
						if (!_children.empty())
							writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);
					} else {
						const DefaultTable::Entry* entry_ = _defaults->find((int)_children.size());
						if (entry_) { // Found a default entry.
							int cursor = (int)_children.size() - 1;
							for (int i = (int)entry_->defaults.size() - 1; i >= 0; --i) {
								const int val = entry_->defaults[i];
								if (val == DefaultTable::Entry::PLACEHOLDER) { // Is placeholder.
									if (cursor >= 0) {
										// Emit an argument from the children.
										writeChildren(bytes, context, Range(cursor), stk, onError);
										--cursor;
									} else {
										// Emit a zero.
										Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
										args = fill(args, (UInt16)0);
									}
								} else { // Is a default value.
									// Emit a default value.
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)val);
								}
							}
						}
					}

					// Emit the specific instruction.
					const Asm::Types type = entry->type;
					emit(bytes, context, INSTRUCTIONS[(size_t)type]); DEC_COUNTER(stk, 2 * entry->parameters); INC_COUNTER(stk, 2);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return abstract(name.c_str());
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

class NodePalette : public Node {
public:
	NodePalette() {
	}
	virtual ~NodePalette() override {
	}

	NODE_TYPE(Types::PALETTE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "palette")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2 || _children.size() == 3 || _children.size() == 4) {
				// Do nothing.
			} else if (_children.size() > 4) {
				THROW_TOO_MANY_ARGUMENTS(onError);
			} else {
				THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Get palette color from assets.
			Colour col;
			bool fromAsset = false;
			if (_children.size() == 4) {
				// Check for feature compatibility.
				usingColoredFeature(ctx, onError);

				// Find the palette asset.
				constexpr const char* PALETTE_NAMES[] = {
					 "bg0:",  "bg1:",  "bg2:",  "bg3:",  "bg4:",  "bg5:",  "bg6:",  "bg7:",
					"obj0:", "obj1:", "obj2:", "obj3:", "obj4:", "obj5:", "obj6:", "obj7:"
				};
				const char* const* PALETTE_END = PALETTE_NAMES + GBBASIC_COUNTOF(PALETTE_NAMES);

				int page = -1;
				Destination dest(0);
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, (int)_children.size() - 1, true);
				if (dest.isLeft()) {
					if (tks.size() == 3) { /* Do nothing. */ }
					else { THROW_INVALID_ASSET_POINT(onError); }
					fromAsset = true;
				} else if (page == -1 && dest.isRight() && !dest.right().get().empty()) {
					if (tks.size() == 1) { /* Do nothing. */ }
					else { THROW_INVALID_ASSET_POINT(onError); }
					const std::string name = dest.right().get();
					const char* const* ptr = std::find_if(
						PALETTE_NAMES, PALETTE_END,
						[name] (const char* name_) -> bool {
							return Text::startsWith(name, name_, true);
						}
					);
					if (ptr == PALETTE_END) { THROW_INVALID_ASSET_POINT(onError); }
					const int pageIndex = (int)(ptr - PALETTE_NAMES);
					page = pageIndex;
					const size_t colonIdx = Text::indexOf(name, ':');
					if (colonIdx == std::string::npos) { THROW_INVALID_ASSET_POINT(onError); }
					const std::string substr = name.substr(colonIdx + 1);
					int sub = 0;
					if (!Text::fromString(substr, sub)) { THROW_INVALID_ASSET_POINT(onError); }
					dest = Left<int>(sub);
					fromAsset = true;
				}

				if (fromAsset) {
					const PaletteAssets &palettes = ctx.assets->palette;
					const PaletteAssets::Entry* paletteEntry = palettes.get(page);
					if (!paletteEntry) { THROW_INVALID_ASSET_POINT(onError); }
					const int idx = dest.left().get();
					if (!paletteEntry->data->get(idx, col)) { THROW_INVALID_ASSET_POINT(onError); }
				}
			}

			// Emit the right hand value.
			if (fromAsset) {
				writeRightHand(
					bytes, context, stk,
					[&] (void) -> void {
						// Emit the arguments.
						const UInt16 rgb = RGB8(col.r, col.g, col.b);
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
						args = fill(args, (UInt16)rgb);
						writeChildren(bytes, context, Range(2, 0), stk, onError);

						// Emit a `VM_PALETTE` instruction.
						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PALETTE]); DEC_COUNTER(stk, 2 * 4);
						args = fill(args, (UInt8)_children.size());
					}, 0, false,
					onError
				);
			} else {
				writeRightHand(
					bytes, context, stk,
					[&] (void) -> void {
						// Emit the arguments.
						writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

						// Emit a `VM_PALETTE` instruction.
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PALETTE]); DEC_COUNTER(stk, 2 * (int)_children.size());
						args = fill(args, (UInt8)_children.size());
					}, 0, false,
					onError
				);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PALETTE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PALETTE");
	}
	using Node::dump;
};

class NodeRgb : public Node {
public:
	NodeRgb() {
	}
	virtual ~NodeRgb() override {
	}

	NODE_TYPE(Types::RGB)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		typedef std::vector<int> Indices;

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "rgb")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			Token::Ptr strtk = nullptr;
			std::string str;
			if (_children.size() == 1) {
				if (!isString(context, 0, &str, &strtk)) {
					CHECK_FOR_STRING(onError, strtk);
				}
			} else {
				if (_children.size() < 3) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() == 3) {
					// Do nothing.
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			if (_children.size() == 1) {
				Colour col;
				if (!col.fromString(str)) {
					THROW_INVALID_COLOR(onError, strtk);
				}
				if (withDeclaring) {
					const UInt16 rgb = RGB8(col.r, col.g, col.b);
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)rgb);
				}
			} else /* if (_children.size() == 3) */ {
				// FEAT: OPTIMIZATION.
				// Use constants directly.
				const bool optimize = ctx.expression.optimize;
				int r = 0;
				int g = 0;
				int b = 0;
				if (optimize && isUInt8(context, 0, r, nullptr) && isUInt8(context, 1, g, nullptr) && isUInt8(context, 2, b, nullptr)) {
					const UInt16 rgb = RGB8((UInt8)r, (UInt8)g, (UInt8)b);
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)rgb);
				} else {
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit the arguments.
							writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

							// Emit a `VM_RGB` instruction.
							emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RGB]); DEC_COUNTER(stk, 2 * (int)_children.size()); INC_COUNTER(stk, 2);
						}, withDeclaring ? 0 : 1, false,
						onError
					);
				}
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RGB");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RGB");
	}
	using Node::dump;
};

class NodeHsv : public Node {
public:
	NodeHsv() {
	}
	virtual ~NodeHsv() override {
	}

	NODE_TYPE(Types::HSV)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		typedef std::vector<int> Indices;

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "hsv")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 3) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 3) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Extract the components.
			Token::Ptr tk0 = nullptr;
			Token::Ptr tk1 = nullptr;
			Token::Ptr tk2 = nullptr;
			int h = 0;
			int s = 0;
			int v = 0;
			if (!isInt16(context, 0, h, &tk0)) { THROW_TYPE_EXPECTED(onError, "Integer constant", tk0); }
			if (!isInt16(context, 1, s, &tk1)) { THROW_TYPE_EXPECTED(onError, "Integer constant", tk1); }
			if (!isInt16(context, 2, v, &tk2)) { THROW_TYPE_EXPECTED(onError, "Integer constant", tk2); }
			const float fh = (float)h;
			const float fs = s / 100.0f;
			const float fv = v / 100.0f;
			const Colour col = Colour::byHSV(fh, fs, fv, 255);

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			do {
				// FEAT: OPTIMIZATION.
				// Use constants directly.
				const bool optimize = ctx.expression.optimize;
				if (optimize) {
					const UInt16 rgb = RGB8((UInt8)col.r, (UInt8)col.g, (UInt8)col.b);
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)rgb);
				} else {
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit the arguments.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)col.b);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)col.g);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)col.b);

							// Emit a `VM_RGB` instruction.
							emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RGB]); DEC_COUNTER(stk, 2 * (int)_children.size()); INC_COUNTER(stk, 2);
						}, withDeclaring ? 0 : 1, false,
						onError
					);
				}
			} while (false);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("HSV");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "HSV");
	}
	using Node::dump;
};

class NodeRect : public Node {
private:
	std::string _name;

public:
	NodeRect(const std::string &name) : _name(name) {
	}
	virtual ~NodeRect() override {
	}

	NODE_TYPE(Types::RECT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				GBBASIC_ASSERT(id == _name && "Impossible.");
			})) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 3) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 4) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the arguments.
			writeChildren(bytes, context, Range(3, 0), stk, onError);

			// Emit a `VM_RECT` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RECT]); DEC_COUNTER(stk, 2 * 4);
			args = fill(args, (UInt8)(id == "rectfill" ? TRUE : FALSE));

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return abstract(name.c_str());
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		std::string name = _name;
		Text::toUpperCase(name);

		return dump(depth, name.c_str());
	}
	using Node::dump;
};

class NodeText : public Node {
public:
	NodeText() {
	}
	virtual ~NodeText() override {
	}

	NODE_TYPE(Types::TEXT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		replenishFormatted<NodeExpression>(context, 2);

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			bool newLine = true;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "text")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::OPERATOR, ";")) { newLine = false; }

			// Check the children.
			if (_children.size() < 3) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else {
				// Do nothing.
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the instruction to locate the cursor.
			{
				// Set the expression slot guard.
				VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

				// Emit the arguments.
				writeChildren(bytes, context, Range(1, 0), stk, onError);

				// Emit a `VM_GOTOXY` instruction.
				emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::GOTOXY]); DEC_COUNTER(stk, 2 * 2);
			}

			// FEAT: TEXT FORMAT.
			// Writing layout:
			//   argument evaluations
			//   the `VM_TEXT` instruction
			//     the argument count (C function argument)
			//     the new line mode (C function argument)
			//   the arguments from front to back
			//   the format text in string, with termination point
			// Emit a `VM_TEXT` instruction.
			writeFormatted(bytes, context, stk, Asm::Types::TEXT, 2, &newLine, onError);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("TEXT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "TEXT");
	}
	using Node::dump;
};

class NodeImageManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		TILE,
		MAP
	};

private:
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeImageManipulation() {
	}
	virtual ~NodeImageManipulation() override {
	}

	NODE_TYPE(Types::IMAGE_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			int argn = 0;
			bool read = false;
			bool data = false;
			int arge = 0;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "image")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			arge = (int)_children.size() - argn;
			if (!consume(Token::Types::KEYWORD, "with")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "tile")) { _type = OperationTypes::TILE; }
			else if (consume(Token::Types::KEYWORD, "map")) { _type = OperationTypes::MAP; }
			else { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "read")) read = true;
			else if (consume(Token::Types::KEYWORD, "data")) data = true;
			else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			switch (_type) {
			case OperationTypes::TILE: {
					// Determine the target layer.
					bool toMap = true; // Defaults to the map layer.
					if (argn == 6) {
						Token::Ptr tk = nullptr;
						int val = 0;
						if (!isUInt8(context, 5, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
						if (val == GRAPHICS_LAYER_MAP) {
							toMap = true;
						} else if (val == GRAPHICS_LAYER_WINDOW) {
							toMap = false;
						} else {
							THROW_INVALID_DESTINATION(onError);
						}
					}

					// Emit the image drawing instruction.
					UInt8 src = ASSET_SOURCE_FAR;
					if (read) src = ASSET_SOURCE_READ;
					else if (data) src = ASSET_SOURCE_DATA;
					if (read) {
						if (_children.size() <= 4) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 5 || _children.size() == 6) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						writeRoutine(
							bytes, context,
							Asm::Types::IMAGE, ASSET_SOURCE_READ, -1,
							[&] (Counter &stk) -> int {
								if (argn == 5) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)GRAPHICS_LAYER_MAP);
									writeChildren(bytes, context, Range(4, 0), stk, onError);
								} else /* if (arn == 6) */ {
									writeChildren(bytes, context, Range(5, 0), stk, onError);
								}

								return 6;
							},
							nullptr,
							onError
						);
					} else if (data) {
						if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
						Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
						constexpr const int M = 16;
						const int n = (int)Token::sizeOfIntegers(seq);
						if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
						if (n > 255) { THROW_TOO_MANY_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::IMAGE, ASSET_SOURCE_DATA, -1,
							[&] (Counter &stk) -> int {
								if (argn == 5) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)GRAPHICS_LAYER_MAP);
									writeChildren(bytes, context, Range(4, 0), stk, onError);
								} else /* if (arn == 6) */ {
									writeChildren(bytes, context, Range(5, 0), stk, onError);
								}

								return 6;
							},
							[&] (Counter &) -> void {
								for (const Token::Ptr &tk : seq)
									writeInteger(bytes, context, tk);
							},
							onError
						);
					} else if (byName_) {
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						const TilesAssets &tiles = ctx.assets->tiles;
						int pageIndex = -1;
						const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
						if (romLocation) {
							if (_children.size() <= 4) {
								THROW_TOO_FEW_ARGUMENTS(onError);
							} else if (_children.size() == 5 || _children.size() == 6) {
								// Do nothing.
							} else {
								THROW_TOO_MANY_ARGUMENTS(onError);
							}

							const int bank = romLocation->bank;
							const int address = romLocation->address;
							writeRoutine(
								bytes, context,
								Asm::Types::IMAGE, ASSET_SOURCE_FAR, -1,
								[&] (Counter &stk) -> int {
									if (argn == 5) {
										Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
										args = fill(args, (UInt16)GRAPHICS_LAYER_MAP);
										writeChildren(bytes, context, Range(4, 0), stk, onError);
									} else /* if (arn == 6) */ {
										writeChildren(bytes, context, Range(5, 0), stk, onError);
									}

									return 6;
								},
								[&] (Counter &) -> void {
									emit(bytes, context, (UInt8)bank);
									emit(bytes, context, (UInt16)address);
								},
								onError
							);
						} else if (tilesEntry) {
							if (_children.size() <= 5) {
								THROW_TOO_FEW_ARGUMENTS(onError);
							} else if (_children.size() == 6 || _children.size() == 7) {
								// Do nothing.
							} else {
								THROW_TOO_MANY_ARGUMENTS(onError);
							}

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

							writeRoutine(
								bytes, context,
								Asm::Types::IMAGE, ASSET_SOURCE_FAR, -1,
								[&] (Counter &stk) -> int {
									if (argn == 5) {
										Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
										args = fill(args, (UInt16)GRAPHICS_LAYER_MAP);
										writeChildren(bytes, context, Range(4, 0), stk, onError);
									} else /* if (arn == 6) */ {
										writeChildren(bytes, context, Range(5, 0), stk, onError);
									}

									return 6;
								},
								[&] (Counter &) -> void {
									const int offset = (int)bytes->peek();
									SourceLocation target(pageIndex);
									_scheduled.push_back(Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false));
									emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
									emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								},
								onError
							);
						} else {
							std::string fuzzyName;
							if (tiles.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
					} else /* From asset. */ {
						if (_children.size() <= 5) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 6 || _children.size() == 7) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						writeRoutine(
							bytes, context,
							Asm::Types::IMAGE, ASSET_SOURCE_FAR, -1,
							[&] (Counter &stk) -> int {
								if (argn == 5) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)GRAPHICS_LAYER_MAP);
									writeChildren(bytes, context, Range(4, 0), stk, onError);
								} else /* if (arn == 6) */ {
									writeChildren(bytes, context, Range(5, 0), stk, onError);
								}

								return 6;
							},
							[&] (Counter &) -> void {
								int page = -1;
								Destination dest(0);
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

								if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
								if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

								SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
								const int offset = (int)bytes->peek();
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_scheduled.push_back(Scheduled(target, offset, false));
							},
							onError
						);
					}

					// Turn on the map or window layer.
#if MAP_ON_WITH_IMAGE_ENABLED 
					do { // `MAP ON` or `WINDOW ON`.
						// Set the stack footprint guard.
						COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
						COUNTER_GUARD(ctx, stk);

						// Set the expression slot guard.
						VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

						// Emit the right hand value.
						writeRightHand(
							bytes, context, stk,
							[&] (void) -> void {
								// Emit the option value.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)TRUE);

								// Emit the option type.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)(toMap ? DEVICE_OPTION_MAP_ENABLED : DEVICE_OPTION_WINDOW_ENABLED));

								// Emit a `VM_OPTION` instruction.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
							}, 1, false,
							onError
						);

						// Check the stack footprint.
						CHECK_COUNTER(ctx, onError);
					} while (false);
#endif /* MAP_ON_WITH_IMAGE_ENABLED  */
				}

				break;
			case OperationTypes::MAP: {
					// Check the children.
					if (_children.size() <= 3) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (_children.size() == 4 || _children.size() == 5) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Determine the target layer.
					bool toMap = true;
					if (argn == 4) {
						Token::Ptr tk = nullptr;
						int val = 0;
						if (!isUInt8(context, 3, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
						if (val == GRAPHICS_LAYER_MAP) {
							toMap = true;
						} else if (val == GRAPHICS_LAYER_WINDOW) {
							toMap = false;
						} else {
							THROW_INVALID_DESTINATION(onError);
						}
					}

					// Find the map asset.
					int page = -1;
					Destination dest(0);
					Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, (int)_children.size() - 1, true);
					if (tks.size() == 1) { /* Do nothing. */ }
					else { THROW_INVALID_ASSET_POINT(onError); }
					if (page == -1 && dest.isRight()) {
						const std::string name = dest.right().get();
						int pageIndex = -1;
						const MapAssets &maps = ctx.assets->maps;
						const MapAssets::Entry* mapEntry = maps.find(name, &pageIndex); // By asset name.
						if (mapEntry) {
							page = pageIndex;
							dest = Left<int>(page);
						}
					}

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const MapAssets &maps = ctx.assets->maps;
					const MapAssets::Entry* mapEntry = maps.get(page);
					if (!mapEntry) {
						std::string fuzzyName;
						if (maps.fuzzy(name, nullptr, fuzzyName)) {
							THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
						}

						THROW_INVALID_ASSET_POINT(onError);
					}

					const Map::Ptr &map = mapEntry->data;
					const int width = map->width();
					const int height = map->height();

					// Find the tiles asset.
					const int tilesPage = mapEntry->ref;

					int maxCel = 0;
					if (mapEntry->optimize) {
						const Map::Range range = map->range();
						maxCel = range.second;
					} else {
						const TilesAssets &tiles = ctx.assets->tiles;
						const TilesAssets::Entry* tilesEntry = tiles.get(tilesPage);
						if (tilesEntry) {
							const int tileCount = (tilesEntry->data->width() / GBBASIC_TILE_SIZE) * (tilesEntry->data->height() / GBBASIC_TILE_SIZE);
							maxCel = tileCount - 1;
						}
					}
					if (maxCel < 0) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, tilesPage, true)) { THROW_INVALID_ASSET_POINT(onError); }

					// Fill the tiles.
					writeRoutine( // `FILL MAP(first, n) = #pg` or `FILL WINDOW(first, n) = #pg`.
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, (toMap ? GRAPHICS_LAYER_MAP : GRAPHICS_LAYER_WINDOW), 2,
						[&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)(maxCel + 1));
							writeChildren(bytes, context, Range(0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							SourceLocation target(tilesPage); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
						},
						onError
					);

					// Put the map or window.
					writeRoutine( // `MAP x, y` or `WINDOW x, y`.
						bytes, context,
						(toMap ? Asm::Types::MAP : Asm::Types::WINDOW), ASSET_SOURCE_IGNORED, -1,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(2, 1), stk, onError);

							return 2;
						},
						nullptr,
						onError
					);

					// Define the map.
					if (mapEntry->hasAttributes) {
						usingColoredFeature(ctx, onError); // Check for feature compatibility.

						do { // `OPTION VRAM_USAGE, VRAM_ATTRIBUTES`.
							// Set the stack footprint guard.
							COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
							COUNTER_GUARD(ctx, stk);

							// Set the expression slot guard.
							VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

							// Emit the right hand value.
							writeRightHand(
								bytes, context, stk,
								[&] (void) -> void {
									// Emit the option value.
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)DEVICE_VRAM_USAGE_ATTRIBUTES);

									// Emit the option type.
									args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)DEVICE_OPTION_VRAM_USAGE);

									// Emit a `VM_OPTION` instruction.
									args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
								}, 1, false,
								onError
							);

							// Check the stack footprint.
							CHECK_COUNTER(ctx, onError);
						} while (false);

						writeRoutine( // `DEF MAP(x, y, w, h, base_tile, pitch, offset) = #pg:1` or `DEF WINDOW(x, y, w, h, base_tile, pitch, offset) = #pg:1`.
							bytes, context,
							toMap ? Asm::Types::DEF_MAP : Asm::Types::DEF_WINDOW, ASSET_SOURCE_FAR, -1,
							[&] (Counter &stk) -> int {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
								args = fill<Int16, UInt16>(args, 0);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Base tile.
								args = fill(args, (UInt16)0);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Pitch.
								args = fill(args, (UInt16)width);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Height.
								args = fill(args, (UInt16)height);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Width.
								args = fill(args, (UInt16)width);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Y.
								args = fill(args, (UInt16)0);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // X.
								args = fill(args, (UInt16)0);

								return 7;
							},
							[&] (Counter &) -> void {
								SourceLocation target(page, 1); // `#pg`. By page number.
								const int offset = (int)bytes->peek();
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_scheduled.push_back(Scheduled(target, offset, false));
							},
							onError
						);
					}

					do { // `OPTION VRAM_USAGE, VRAM_TILES`.
						// Set the stack footprint guard.
						COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
						COUNTER_GUARD(ctx, stk);

						// Set the expression slot guard.
						VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

						// Emit the right hand value.
						writeRightHand(
							bytes, context, stk,
							[&] (void) -> void {
								// Emit the option value.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)DEVICE_VRAM_USAGE_TILES);

								// Emit the option type.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)DEVICE_OPTION_VRAM_USAGE);

								// Emit a `VM_OPTION` instruction.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
							}, 1, false,
							onError
						);

						// Check the stack footprint.
						CHECK_COUNTER(ctx, onError);
					} while (false);

					writeRoutine( // `DEF MAP(x, y, w, h, base_tile, pitch, offset) = #pg:0` or `DEF WINDOW(x, y, w, h, base_tile, pitch, offset) = #pg:0`.
						bytes, context,
						toMap ? Asm::Types::DEF_MAP : Asm::Types::DEF_WINDOW, ASSET_SOURCE_FAR, -1,
						[&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, 0);
							writeChildren(bytes, context, Range(0), stk, onError); // Base tile.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Pitch.
							args = fill(args, (UInt16)width);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Height.
							args = fill(args, (UInt16)height);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Width.
							args = fill(args, (UInt16)width);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Y.
							args = fill(args, (UInt16)0);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // X.
							args = fill(args, (UInt16)0);

							return 7;
						},
						[&] (Counter &) -> void {
							SourceLocation target(page); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
						},
						onError
					);

					// Turn on the map or window layer.
#if MAP_ON_WITH_IMAGE_ENABLED 
					do { // `MAP ON` or `WINDOW ON`.
						// Set the stack footprint guard.
						COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
						COUNTER_GUARD(ctx, stk);

						// Set the expression slot guard.
						VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

						// Emit the right hand value.
						writeRightHand(
							bytes, context, stk,
							[&] (void) -> void {
								// Emit the option value.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)TRUE);

								// Emit the option type.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)(toMap ? DEVICE_OPTION_MAP_ENABLED : DEVICE_OPTION_WINDOW_ENABLED));

								// Emit a `VM_OPTION` instruction.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
							}, 1, false,
							onError
						);

						// Check the stack footprint.
						CHECK_COUNTER(ctx, onError);
					} while (false);
#endif /* MAP_ON_WITH_IMAGE_ENABLED  */
				}

				break;
			default:
				GBBASIC_ASSERT(false && "Impossible.");

				break;
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::TILE: {
				for (int i = 0; i < (int)_scheduled.size(); ++i) {
					Scheduled &scheduled = _scheduled[i];
					if (!scheduled.pending())
						continue;

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					Pipeline::Resource::Array locations;
					if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
					if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
					const int bank = locations.front().bank;
					const int address = locations.front().address;
					const int size = locations.front().size;
					const int offset = scheduled.target.sub * 8 * 2;
					if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

					Byte* args = scheduled.args(bytes->pointer());
					args = fill(args, (UInt8)bank);
					args = fill(args, (UInt16)(address + offset));
				}
			}

			break;
		case OperationTypes::MAP: {
				// Process the tiles.
				Scheduled &scheduled0 = _scheduled.front();
				if (!scheduled0.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations0;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, scheduled0.target.page, locations0)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations0.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int bank0 = locations0.front().bank;
				const int address0 = locations0.front().address;
				const int size0 = locations0.front().size;
				const int offset0 = scheduled0.target.sub * 8 * 2;
				if (offset0 >= size0) { THROW_INVALID_ASSET_POINT(onError); }

				Byte* args = scheduled0.args(bytes->pointer());
				args = fill(args, (UInt8)bank0);
				args = fill(args, (UInt16)(address0 + offset0));

				// Process the attributes.
				if (_scheduled.size() == 3) {
					Scheduled &scheduled1 = _scheduled[1];
					if (!scheduled1.pending())
						return;

					Pipeline::Resource::Array locations1;
					if (!ctx.pipeline->lookup(AssetsBundle::Categories::MAP, scheduled1.target.page, locations1)) { THROW_INVALID_ASSET_POINT(onError); }
					if (scheduled1.target.sub < 0 || scheduled1.target.sub >= (int)locations1.size()) { THROW_INVALID_ASSET_POINT(onError); }
					const Pipeline::Resource &loc1 = locations1[scheduled1.target.sub];
					const int bank1 = loc1.bank;
					const int address1 = loc1.address;

					args = scheduled1.args(bytes->pointer());
					args = fill(args, (UInt8)bank1);
					args = fill(args, (UInt16)address1);
				}

				// Process the map.
				Scheduled &scheduled2 = _scheduled.back();
				if (!scheduled2.pending())
					return;

				Pipeline::Resource::Array locations2;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::MAP, scheduled2.target.page, locations2)) { THROW_INVALID_ASSET_POINT(onError); }
				if (scheduled2.target.sub < 0 || scheduled2.target.sub >= (int)locations2.size()) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc2 = locations2[scheduled2.target.sub];
				const int bank2 = loc2.bank;
				const int address2 = loc2.address;

				args = scheduled2.args(bytes->pointer());
				args = fill(args, (UInt8)bank2);
				args = fill(args, (UInt16)address2);
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("IMAGE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "IMAGE");
	}
	using Node::dump;
};

class NodeTileManipulation : public Node {
private:
	Scheduled _scheduled;

public:
	NodeTileManipulation() {
	}
	virtual ~NodeTileManipulation() override {
	}

	NODE_TYPE(Types::TILE_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool read = false;
			bool data = false;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "fill")
					action = ResourceManipulations::FILL;
				else if (id == "get")
					action = ResourceManipulations::GET;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "tile" && !consume(Token::Types::KEYWORD, "tile")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "len")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::LEN;
			}
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "read")) read = true;
			else if (consume(Token::Types::KEYWORD, "data")) data = true;
			else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			UInt8 src = ASSET_SOURCE_FAR;
			if (read) src = ASSET_SOURCE_READ;
			else if (data) src = ASSET_SOURCE_DATA;
			switch (action) {
			case ResourceManipulations::FILL:
				// The fill functions for map and window are identical.
				if (read) {
					writeRoutine(bytes, context, Asm::Types::FILL_TILE, ASSET_SOURCE_READ, GRAPHICS_LAYER_MAP, 2, nullptr, nullptr, onError);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					constexpr const int M = 16;
					const int n = (int)Token::sizeOfIntegers(seq);
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
					const Token::Ptr tk = _children[1]->onlyToken();
					if (tk && tk->is(Token::Types::INTEGER)) {
						if ((int)tk->data() * M != n) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_DATA, GRAPHICS_LAYER_MAP, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					const TilesAssets &tiles = ctx.assets->tiles;
					int pageIndex = -1;
					const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
					if (romLocation) {
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_MAP, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							},
							onError
						);
					} else if (tilesEntry) {
						if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
						if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_MAP, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								const int offset = (int)bytes->peek();
								SourceLocation target(pageIndex);
								_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							},
							onError
						);
					} else {
						std::string fuzzyName;
						if (tiles.fuzzy(name, nullptr, fuzzyName)) {
							THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
						}

						THROW_INVALID_ASSET_POINT(onError);
					}
				} else /* From asset. */ {
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_MAP, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
							if (tks.size() == 1) { /* Do nothing. */ }
							else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
						},
						onError
					);
				}

				break;
			case ResourceManipulations::LEN: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const TilesAssets &tiles = ctx.assets->tiles;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						tiles.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (tiles.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
					}
					if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

					const int tilesIndex = page;
					const TilesAssets::Entry* tilesEntry = tiles.get(tilesIndex);
					if (!tilesEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, tilesIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = (tilesEntry->data->width() / GBBASIC_TILE_SIZE) * (tilesEntry->data->height() / GBBASIC_TILE_SIZE);

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
		Pipeline::Resource::Array locations;
		if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
		if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
		const int bank = locations.front().bank;
		const int address = locations.front().address;
		const int size = locations.front().size;
		const int offset = _scheduled.target.sub * 8 * 2;
		if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

		Byte* args = _scheduled.args(bytes->pointer());
		args = fill(args, (UInt8)bank);
		args = fill(args, (UInt16)(address + offset));
	}

	virtual Abstract abstract(void) const override {
		return abstract("TILE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "TILE");
	}
	using Node::dump;
};

class NodeMapManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		FILL,
		DEF
	};

private:
	Scheduled _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeMapManipulation() {
	}
	virtual ~NodeMapManipulation() override {
	}

	NODE_TYPE(Types::MAP_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool read = false;
			bool data = false;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "fill")
					action = ResourceManipulations::FILL;
				else if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "get")
					action = ResourceManipulations::GET;
				else if (id == "set")
					action = ResourceManipulations::SET;
				else if (id == "map")
					action = ResourceManipulations::PUT;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "map" && !consume(Token::Types::KEYWORD, "map")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "width")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_WIDTH;
			} else if (consume(Token::Types::KEYWORD, "height")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_HEIGHT;
			}
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "read")) read = true;
			else if (consume(Token::Types::KEYWORD, "data")) data = true;
			else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			UInt8 src = ASSET_SOURCE_FAR;
			if (read) src = ASSET_SOURCE_READ;
			else if (data) src = ASSET_SOURCE_DATA;
			switch (action) {
			case ResourceManipulations::FILL:
				// The fill functions for map and window are identical.
				if (read) {
					writeRoutine(bytes, context, Asm::Types::FILL_TILE, ASSET_SOURCE_READ, GRAPHICS_LAYER_MAP, 2, nullptr, nullptr, onError);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					constexpr const int M = 16;
					const int n = (int)Token::sizeOfIntegers(seq);
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
					const Token::Ptr tk = _children[1]->onlyToken();
					if (tk && tk->is(Token::Types::INTEGER)) {
						if ((int)tk->data() * M != n) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_DATA, GRAPHICS_LAYER_MAP, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
							writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					const TilesAssets &tiles = ctx.assets->tiles;
					int pageIndex = -1;
					const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
					if (romLocation) {
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_MAP, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							},
							onError
						);
					} else if (tilesEntry) {
						if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
						if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_MAP, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								const int offset = (int)bytes->peek();
								SourceLocation target(pageIndex);
								_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_type = OperationTypes::FILL;
							},
							onError
						);
					} else {
						std::string fuzzyName;
						if (tiles.fuzzy(name, nullptr, fuzzyName)) {
							THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
						}

						THROW_INVALID_ASSET_POINT(onError);
					}
				} else /* From asset. */ {
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_MAP, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
							if (tks.size() == 1) { /* Do nothing. */ }
							else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
							_type = OperationTypes::FILL;
						},
						onError
					);
				}

				break;
			case ResourceManipulations::DEF: {
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					int pitch = std::numeric_limits<int>::min();
					if (byName_) {
						const MapAssets &maps = ctx.assets->maps;
						const MapAssets::Entry* mapEntry = maps.find(name, nullptr); // By asset name.
						if (mapEntry)
							pitch = mapEntry->data->width();
					}
					if (argn == 4) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, GRAPHICS_AUTO_OFFSET); // Let the VM determine.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Base tile.
							args = fill(args, (UInt16)0);
							if (pitch == std::numeric_limits<int>::min()) {
								writeChildren(bytes, context, Range(2), stk, onError); // Pitch.
							} else {
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Pitch.
								args = fill(args, (UInt16)pitch);
							}
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					} else if (argn == 5) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, GRAPHICS_AUTO_OFFSET); // Let the VM determine.
							writeChildren(bytes, context, Range(4), stk, onError); // Base tile.
							if (pitch == std::numeric_limits<int>::min()) {
								writeChildren(bytes, context, Range(2), stk, onError); // Pitch.
							} else {
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Pitch.
								args = fill(args, (UInt16)pitch);
							}
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					} else if (argn == 6) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, GRAPHICS_AUTO_OFFSET); // Let the VM determine.
							writeChildren(bytes, context, Range(4), stk, onError); // Base tile.
							writeChildren(bytes, context, Range(5), stk, onError); // Pitch.
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					} else if (argn == 7) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(6), stk, onError); // Offset.
							writeChildren(bytes, context, Range(4), stk, onError); // Base tile.
							writeChildren(bytes, context, Range(5), stk, onError); // Pitch.
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					}
					if (data) {
						argi = [&] (Counter &) -> void {
							if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
							Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						};
					} else if (byName_) {
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						const MapAssets &maps = ctx.assets->maps;
						int pageIndex = -1;
						const MapAssets::Entry* mapEntry = maps.find(name, &pageIndex); // By asset name.
						if (romLocation) {
							const int bank = romLocation->bank;
							const int address = romLocation->address;
							argi = [&, bank, address] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							};
						} else if (mapEntry) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

							argi = [&] (Counter &) -> void {
								const int offset = (int)bytes->peek();
								SourceLocation target(pageIndex);
								_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_type = OperationTypes::DEF;
							};
						} else {
							std::string fuzzyName;
							if (maps.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
					}
					if (read || data || byName_) {
						if (argn == 4) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 4, argf, argi, onError);
						} else if (argn == 5) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 5, argf, argi, onError);
						} else if (argn == 6) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 6, argf, argi, onError);
						} else if (argn == 7) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 7, argf, argi, onError);
						}
					} else /* From asset. */ {
						argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
							if (tks.empty()) { THROW_INVALID_ASSET_POINT(onError); }
							if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and layer.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
							_type = OperationTypes::DEF;
						};
						if (argn == 4) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 5, argf, argi, onError);
						} else if (argn == 5) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 6, argf, argi, onError);
						} else if (argn == 6) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 7, argf, argi, onError);
						} else if (argn == 7) {
							writeRoutine(bytes, context, Asm::Types::DEF_MAP, src, 8, argf, argi, onError);
						}
					}
				}

				break;
			case ResourceManipulations::GET:
				writeFunction(bytes, context, Asm::Types::MGET, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::SET:
				writeRoutine(bytes, context, Asm::Types::MSET, ASSET_SOURCE_IGNORED, 3, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::GET_WIDTH: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const MapAssets &maps = ctx.assets->maps;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						maps.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (maps.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int mapIndex = page;
					const MapAssets::Entry* mapEntry = maps.get(mapIndex);
					if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, mapIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = mapEntry->data->width();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_HEIGHT: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const MapAssets &maps = ctx.assets->maps;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						maps.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (maps.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int mapIndex = page;
					const MapAssets::Entry* mapEntry = maps.get(mapIndex);
					if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, mapIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = mapEntry->data->height();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::PUT:
				writeRoutine(bytes, context, Asm::Types::MAP, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		switch (_type) {
		case OperationTypes::FILL: {
				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int bank = locations.front().bank;
				const int address = locations.front().address;
				const int size = locations.front().size;
				const int offset = _scheduled.target.sub * 8 * 2;
				if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

				Byte* args = _scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)(address + offset));
			}

			break;
		case OperationTypes::DEF: {
				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::MAP, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (_scheduled.target.sub < 0 || _scheduled.target.sub >= (int)locations.size()) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[_scheduled.target.sub];
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = _scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("MAP");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "MAP");
	}
	using Node::dump;
};

class NodeWindowManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		FILL,
		DEF
	};

private:
	Scheduled _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeWindowManipulation() {
	}
	virtual ~NodeWindowManipulation() override {
	}

	NODE_TYPE(Types::WINDOW_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool read = false;
			bool data = false;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "fill")
					action = ResourceManipulations::FILL;
				else if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "get")
					action = ResourceManipulations::GET;
				else if (id == "set")
					action = ResourceManipulations::SET;
				else if (id == "window")
					action = ResourceManipulations::PUT;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "window" && !consume(Token::Types::KEYWORD, "window")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "width")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_WIDTH;
			} else if (consume(Token::Types::KEYWORD, "height")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_HEIGHT;
			}
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "read")) read = true;
			else if (consume(Token::Types::KEYWORD, "data")) data = true;
			else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			UInt8 src = ASSET_SOURCE_FAR;
			if (read) src = ASSET_SOURCE_READ;
			else if (data) src = ASSET_SOURCE_DATA;
			switch (action) {
			case ResourceManipulations::FILL:
				if (read) {
					writeRoutine(bytes, context, Asm::Types::FILL_TILE, ASSET_SOURCE_READ, GRAPHICS_LAYER_WINDOW, 2, nullptr, nullptr, onError);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					constexpr const int M = 16;
					const int n = (int)Token::sizeOfIntegers(seq);
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
					const Token::Ptr tk = _children[1]->onlyToken();
					if (tk && tk->is(Token::Types::INTEGER)) {
						if ((int)tk->data() * M != n) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_DATA, GRAPHICS_LAYER_WINDOW, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					const TilesAssets &tiles = ctx.assets->tiles;
					int pageIndex = -1;
					const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
					if (romLocation) {
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_WINDOW, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							},
							onError
						);
					} else if (tilesEntry) {
						if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
						if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_WINDOW, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								const int offset = (int)bytes->peek();
								SourceLocation target(pageIndex);
								_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_type = OperationTypes::FILL;
							},
							onError
						);
					} else {
						std::string fuzzyName;
						if (tiles.fuzzy(name, nullptr, fuzzyName)) {
							THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
						}

						THROW_INVALID_ASSET_POINT(onError);
					}
				} else /* From asset. */ {
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_WINDOW, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
							if (tks.size() == 1) { /* Do nothing. */ }
							else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
							_type = OperationTypes::FILL;
						},
						onError
					);
				}

				break;
			case ResourceManipulations::DEF: {
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					int pitch = std::numeric_limits<int>::min();
					if (byName_) {
						const MapAssets &maps = ctx.assets->maps;
						const MapAssets::Entry* mapEntry = maps.find(name, nullptr); // By asset name.
						if (mapEntry)
							pitch = mapEntry->data->width();
					}
					if (argn == 4) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, GRAPHICS_AUTO_OFFSET); // Let the VM determine.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Base tile.
							args = fill(args, (UInt16)0);
							if (pitch == std::numeric_limits<int>::min()) {
								writeChildren(bytes, context, Range(2), stk, onError); // Pitch.
							} else {
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Pitch.
								args = fill(args, (UInt16)pitch);
							}
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					} else if (argn == 5) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, GRAPHICS_AUTO_OFFSET); // Let the VM determine.
							writeChildren(bytes, context, Range(4), stk, onError); // Base tile.
							if (pitch == std::numeric_limits<int>::min()) {
								writeChildren(bytes, context, Range(2), stk, onError); // Pitch.
							} else {
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Pitch.
								args = fill(args, (UInt16)pitch);
							}
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					} else if (argn == 6) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Offset.
							args = fill<Int16, UInt16>(args, GRAPHICS_AUTO_OFFSET); // Let the VM determine.
							writeChildren(bytes, context, Range(4), stk, onError); // Base tile.
							writeChildren(bytes, context, Range(5), stk, onError); // Pitch.
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					} else if (argn == 7) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(6), stk, onError); // Offset.
							writeChildren(bytes, context, Range(4), stk, onError); // Base tile.
							writeChildren(bytes, context, Range(5), stk, onError); // Pitch.
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.

							return 7;
						};
					}
					if (data) {
						argi = [&] (Counter &) -> void {
							if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
							Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						};
					} else if (byName_) {
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						const MapAssets &maps = ctx.assets->maps;
						int pageIndex = -1;
						const MapAssets::Entry* mapEntry = maps.find(name, &pageIndex); // By asset name.
						if (romLocation) {
							const int bank = romLocation->bank;
							const int address = romLocation->address;
							argi = [&, bank, address] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							};
						} else if (mapEntry) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

							argi = [&] (Counter &) -> void {
								const int offset = (int)bytes->peek();
								SourceLocation target(pageIndex);
								_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_type = OperationTypes::DEF;
							};
						} else {
							std::string fuzzyName;
							if (maps.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
					}
					if (read || data || byName_) {
						if (argn == 4) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 4, argf, argi, onError);
						} else if (argn == 5) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 5, argf, argi, onError);
						} else if (argn == 6) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 6, argf, argi, onError);
						} else if (argn == 7) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 7, argf, argi, onError);
						}
					} else /* From asset. */ {
						argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
							if (tks.empty()) { THROW_INVALID_ASSET_POINT(onError); }
							if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and layer.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
							_type = OperationTypes::DEF;
						};
						if (argn == 4) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 5, argf, argi, onError);
						} else if (argn == 5) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 6, argf, argi, onError);
						} else if (argn == 6) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 7, argf, argi, onError);
						} else if (argn == 7) {
							writeRoutine(bytes, context, Asm::Types::DEF_WINDOW, src, 8, argf, argi, onError);
						}
					}
				}

				break;
			case ResourceManipulations::GET:
				writeFunction(bytes, context, Asm::Types::WGET, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::SET:
				writeRoutine(bytes, context, Asm::Types::WSET, ASSET_SOURCE_IGNORED, 3, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::GET_WIDTH: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const MapAssets &maps = ctx.assets->maps;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						maps.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (maps.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int mapIndex = page;
					const MapAssets::Entry* mapEntry = maps.get(mapIndex);
					if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, mapIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = mapEntry->data->width();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_HEIGHT: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const MapAssets &maps = ctx.assets->maps;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						maps.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (maps.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int mapIndex = page;
					const MapAssets::Entry* mapEntry = maps.get(mapIndex);
					if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, mapIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = mapEntry->data->height();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::PUT:
				writeRoutine(bytes, context, Asm::Types::WINDOW, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		switch (_type) {
		case OperationTypes::FILL: {
				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int bank = locations.front().bank;
				const int address = locations.front().address;
				const int size = locations.front().size;
				const int offset = _scheduled.target.sub * 8 * 2;
				if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

				Byte* args = _scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)(address + offset));
			}

			break;
		case OperationTypes::DEF: {
				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::MAP, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (_scheduled.target.sub < 0 || _scheduled.target.sub >= (int)locations.size()) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[_scheduled.target.sub];
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = _scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("WINDOW");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "WINDOW");
	}
	using Node::dump;
};

class NodeSpriteManipulation : public Node {
private:
	Scheduled _scheduled;

public:
	NodeSpriteManipulation() {
	}
	virtual ~NodeSpriteManipulation() override {
	}

	NODE_TYPE(Types::SPRITE_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			bool prop = false;
			int argn = 0;
			bool read = false;
			bool data = false;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "fill")
					action = ResourceManipulations::FILL;
				else if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "get")
					action = ResourceManipulations::GET;
				else if (id == "set")
					action = ResourceManipulations::SET;
				else if (id == "sprite")
					action = ResourceManipulations::PUT;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "sprite" && !consume(Token::Types::KEYWORD, "sprite")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "property")) {
				prop = true;
				if (!(action == ResourceManipulations::GET || action == ResourceManipulations::SET)) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			} else {
				if (action == ResourceManipulations::GET || action == ResourceManipulations::SET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			}
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "read")) read = true;
			else if (consume(Token::Types::KEYWORD, "data")) data = true;
			else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::FILL:
				if (read) {
					writeRoutine(bytes, context, Asm::Types::FILL_TILE, ASSET_SOURCE_READ, GRAPHICS_LAYER_SPRITE, 2, nullptr, nullptr, onError);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					constexpr const int M = 16;
					const int n = (int)Token::sizeOfIntegers(seq);
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
					const Token::Ptr tk = _children[1]->onlyToken();
					if (tk && tk->is(Token::Types::INTEGER)) {
						if ((int)tk->data() * M != n) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_DATA, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					const TilesAssets &tiles = ctx.assets->tiles;
					int pageIndex = -1;
					const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
					if (romLocation) {
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							},
							onError
						);
					} else if (tilesEntry) {
						if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
						if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

						writeRoutine(
							bytes, context,
							Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								const int offset = (int)bytes->peek();
								SourceLocation target(pageIndex);
								_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							},
							onError
						);
					} else {
						std::string fuzzyName;
						if (tiles.fuzzy(name, nullptr, fuzzyName)) {
							THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
						}

						THROW_INVALID_ASSET_POINT(onError);
					}
				} else /* From asset. */ {
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
							if (tks.size() == 1) { /* Do nothing. */ }
							else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
						},
						onError
					);
				}

				break;
			case ResourceManipulations::DEF:
				writeRoutine(bytes, context, Asm::Types::DEF_SPRITE, ASSET_SOURCE_STACK, 2, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::GET:
				if (prop)
					writeFunction(bytes, context, Asm::Types::GET_SPRITE_PROP, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);
				else
					writeFunction(bytes, context, Asm::Types::SGET, ASSET_SOURCE_IGNORED, 1, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::SET:
				if (prop)
					writeRoutine(bytes, context, Asm::Types::SET_SPRITE_PROP, ASSET_SOURCE_IGNORED, 3, nullptr, nullptr, onError);
				else
					writeRoutine(bytes, context, Asm::Types::SSET, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::PUT:
				writeRoutine(bytes, context, Asm::Types::SPRITE, ASSET_SOURCE_IGNORED, 3, nullptr, nullptr, onError);

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
		Pipeline::Resource::Array locations;
		if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
		if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
		const int bank = locations.front().bank;
		const int address = locations.front().address;
		const int size = locations.front().size;
		const int offset = _scheduled.target.sub * 8 * 2;
		if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

		Byte* args = _scheduled.args(bytes->pointer());
		args = fill(args, (UInt8)bank);
		args = fill(args, (UInt16)(address + offset));
	}

	virtual Abstract abstract(void) const override {
		return abstract("SPRITE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SPRITE");
	}
	using Node::dump;
};

class NodePlay : public Node {
private:
	Scheduled _scheduled;

public:
	NodePlay() {
	}
	virtual ~NodePlay() override {
	}

	NODE_TYPE(Types::PLAY)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "play")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			bool byName = false;
			bool byAddress = false;
			bool byAsset = false;
			int page = -1;
			int bank = 0;
			int address = 0;
			std::string musicName;
			switch (_children.size()) {
			case 0:
				THROW_TOO_FEW_ARGUMENTS(onError);
			case 1: {
					Token::Ptr tk = onlyTokenInOnlyChild();
					if (tk && tk->is(Token::Types::STRING)) {
						byName = true;
						musicName = (std::string)tk->data();
					} else /* From asset. */ {
						byAsset = true;
					}
				}

				break;
			case 2: {
					Token::Ptr tk0 = _children.front()->onlyToken();
					Token::Ptr tk1 = _children.back()->onlyToken();
					byAddress = true;
					if (tk0 && tk1) {
						bank = (int)tk0->data();
						address = (int)tk1->data();
					}
				}

				break;
			default:
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the native music pointer in the ROM.
			if (byName) {
				if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
				const RomLocation* romLocation = ctx.symbols->find(musicName);
				const MusicAssets &music = ctx.assets->music;
				int pageIndex = -1;
				const MusicAssets::Entry* musicEntry = music.find(musicName, &pageIndex); // By asset name.
				if (romLocation) {
					bank = romLocation->bank;
					address = romLocation->address;
				} else if (musicEntry) {
					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MUSIC, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }
					page = pageIndex;
				} else {
					std::string fuzzyName;
					if (music.fuzzy(musicName, nullptr, fuzzyName)) {
						THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
					}

					THROW_INVALID_ASSET_POINT(onError);
				}
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit a `VM_PLAY` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PLAY]);
			if (byName || byAddress) {
				if (bank) {
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)bank);
				} else {
					SourceLocation target(page);
					_scheduled = Scheduled(target, bytes->pointer(), args, false);
				}
			} else /* if (byAsset) */ {
				if (page == -1) {
					Destination dest(0);
					Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 0);
					if (tks.size() == 1) { /* Do nothing. */ }
					else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
				}

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MUSIC, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

				SourceLocation target(page);
				_scheduled = Scheduled(target, bytes->pointer(), args, false);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
		Pipeline::Resource::Array locations;
		if (!ctx.pipeline->lookup(AssetsBundle::Categories::MUSIC, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
		if (locations.size() != 6) { THROW_INVALID_ASSET_POINT(onError); }
		const int bank = locations.back().bank;
		const int address = locations.back().address;

		Byte* args = _scheduled.args(bytes->pointer());
		args = fill(args, (UInt16)address);
		args = fill(args, (UInt8)bank);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PLAY");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PLAY");
	}
	using Node::dump;
};

class NodeSound : public Node {
private:
	enum class OperationTypes {
		NONE,
		SOUND
	};

private:
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeSound() {
	}
	virtual ~NodeSound() override {
	}

	NODE_TYPE(Types::SOUND)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "sound")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			SourceLocation target;
			int bank = 0;
			int address = 0;
			int priority = AUDIO_SFX_PRIORITY_MINIMAL;
			Bytes::Ptr args_(Bytes::create());
			if (_children.empty()) {
				if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
				const RomLocation* romLocation = ctx.symbols->find(BEEP_ENTRY_NAME);
				if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
				bank = romLocation->bank;
				address = romLocation->address;

				priority = AUDIO_SFX_PRIORITY_NORMAL;
			} else if (_children.size() == 1) {
				int page = -1;
				Destination dest(0);
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true);
				if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
				if (dest.isLeft())
					target = SourceLocation(page); // `#pg`. By page number.
				else
					target = SourceLocation(page, dest.right().get()); // By asset name.
				do {
					const std::string &soundName = target.label;
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation_ = ctx.symbols->find(soundName);
					const SfxAssets &sfx = ctx.assets->sfx;
					int pageIndex = -1;
					const SfxAssets::Entry* sfxEntry = sfx.find(soundName, &pageIndex); // By asset name.
					if (romLocation_) {
						bank = romLocation_->bank;
						address = romLocation_->address;
					} else if (sfxEntry) {
						romLocation_ = nullptr;
						page = pageIndex;
						if (page != -1) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SFX, page, true)) { THROW_INVALID_ASSET_POINT(onError); }
							target.page = page;
						}
					} else {
						if (page != -1) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SFX, page, true)) {
								target.page = page;

								break;
							}
						}
						if (page == -1) {
							std::string fuzzyName;
							if (sfx.fuzzy(soundName, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}
						}

						THROW_INVALID_ASSET_POINT(onError);
					}
				} while (false);

				priority = AUDIO_SFX_PRIORITY_NORMAL;
			} else if (_children.size() == 2) {
				int page = -1;
				Destination dest(0);
				Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true);
				if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
				if (dest.isLeft())
					target = SourceLocation(page); // `#pg`. By page number.
				else
					target = SourceLocation(page, dest.right().get()); // By asset name.
				do {
					const std::string &soundName = target.label;
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation_ = ctx.symbols->find(soundName);
					const SfxAssets &sfx = ctx.assets->sfx;
					int pageIndex = -1;
					const SfxAssets::Entry* sfxEntry = sfx.find(soundName, &pageIndex); // By asset name.
					if (romLocation_) {
						bank = romLocation_->bank;
						address = romLocation_->address;
					} else if (sfxEntry) {
						romLocation_ = nullptr;
						page = pageIndex;
						if (page != -1) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SFX, page, true)) { THROW_INVALID_ASSET_POINT(onError); }
							target.page = page;
						}
					} else {
						if (page != -1) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SFX, page, true)) {
								target.page = page;

								break;
							}
						}
						if (page == -1) {
							std::string fuzzyName;
							if (sfx.fuzzy(soundName, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}
						}

						THROW_INVALID_ASSET_POINT(onError);
					}
				} while (false);

				Token::Ptr tk = nullptr;
				int data = 0;
				if (!isUInt8(context, 1, data, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
				priority = Math::clamp(data, (int)std::numeric_limits<UInt8>::min(), (int)std::numeric_limits<UInt8>::max());
			} else if (_children.size() == 3) {
				Token::Ptr tk0 = _children[0]->onlyToken();
				Token::Ptr tk1 = _children[1]->onlyToken();
				if (tk0 && tk1) {
					bank = (int)tk0->data();
					address = (int)tk1->data();
				}

				Token::Ptr tk = nullptr;
				int data = 0;
				if (!isUInt8(context, 2, data, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
				priority = Math::clamp(data, (int)std::numeric_limits<UInt8>::min(), (int)std::numeric_limits<UInt8>::max());
			} else if (_children.size() <= 255) {
				for (int i = 0; i < (int)_children.size(); ++i) {
					Token::Ptr tk = nullptr;
					int data = 0;
					if (!isUInt8(context, i, data, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
					if (i == (int)_children.size() - 1)
						priority = Math::clamp(data, (int)std::numeric_limits<UInt8>::min(), (int)std::numeric_limits<UInt8>::max());
					else
						args_->writeUInt8((UInt8)data);
				}
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit a `VM_SOUND` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SOUND]);
			args = fill(args, (UInt8)args_->count());
			args = fill(args, (UInt8)priority);
			if (bank) {
				args = fill(args, (UInt16)address);
				args = fill(args, (UInt8)bank);
			} else {
				_type = OperationTypes::SOUND;
				_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
			}
			for (int i = 0; i < (int)args_->count(); ++i) {
				emit(bytes, context, (Byte)args_->get(i));
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::SOUND: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::SFX, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations.front();
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt16)address);
				args = fill(args, (UInt8)bank);
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("SOUND");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SOUND");
	}
	using Node::dump;
};

class NodeBeep : public Node {
public:
	NodeBeep() {
	}
	virtual ~NodeBeep() override {
	}

	NODE_TYPE(Types::BEEP)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "beep")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			int bank = 0;
			int address = 0;
			int priority = AUDIO_SFX_PRIORITY_MINIMAL;
			Bytes::Ptr args_(Bytes::create());
			if (_children.empty()) {
				if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
				const RomLocation* romLocation = ctx.symbols->find(BEEP_ENTRY_NAME);
				if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
				bank = romLocation->bank;
				address = romLocation->address;
				priority = AUDIO_SFX_PRIORITY_NORMAL;
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit a `VM_SOUND` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SOUND]);
			args = fill(args, (UInt8)args_->count());
			args = fill(args, (UInt8)priority);
			args = fill(args, (UInt16)address);
			args = fill(args, (UInt8)bank);
			for (int i = 0; i < (int)args_->count(); ++i) {
				emit(bytes, context, (Byte)args_->get(i));
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("BEEP");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "BEEP");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Input functions
*/

class NodeTouch : public Node { // FEAT: GBB EXTENSION.
public:
	NodeTouch() {
	}
	virtual ~NodeTouch() override {
	}

	NODE_TYPE(Types::TOUCH)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			EventTypes type = EventTypes::NONE;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "touch")) { type = EventTypes::TOUCH; }
			else if (consume(Token::Types::KEYWORD, "touchd")) { type = EventTypes::TOUCH_DOWN; }
			else if (consume(Token::Types::KEYWORD, "touchu")) { type = EventTypes::TOUCH_UP; }
			else { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else if (_children.size() == 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Check for feature compatibility.
			usingExtensionFeature(ctx, onError);

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_TOUCH`, `VM_TOUCHD`, or `VM_TOUCHU` instruction.
					Asm::Types y = Asm::Types::TOUCH;
					switch (type) {
					case EventTypes::TOUCH:        y = Asm::Types::TOUCH;  break;
					case EventTypes::TOUCH_DOWN:   y = Asm::Types::TOUCHD; break;
					case EventTypes::TOUCH_UP:     y = Asm::Types::TOUCHU; break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)y]); INC_COUNTER(stk, 2);
					if (_children.empty()) {
						args = fill(args, (Int16)0);
						args = fill(args, (Int16)0);
						args = fill(args, (UInt8)FALSE);
					} else {
						for (int i = (int)_children.size() - 1; i >= 0; --i) {
							const Ptr &child = _children[i];
							Token::Ptr idtk = nullptr;
							std::string id;
							idtk = child->onlyToken();
							if (!idtk) { THROW_INVALID_SYNTAX(onError); }
							id = (std::string)idtk->data();

							// Find the left hand ID in RAM.
							std::string fuzzyName;
							const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
							if (ramLocation) {
								const RamLocation inRam = *ramLocation;
								top().inRam = inRam;
							} else { // Declaration.
#if DECLARE_WITH_TOUCH_ENABLED
								const TextLocation &txtLoc = idtk->begin();
								if (!allocateHeap(ctx, ctx.heapSize, WORD_SIZE, id, RamLocation::Usages::TOUCH, txtLoc)) {
									if (allocateHeap(ctx, ctx.heapSize * 2, WORD_SIZE, id, RamLocation::Usages::TOUCH, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
									else { THROW_HEAP_OVERFLOW(onError, false); }
								}
#else /* DECLARE_WITH_TOUCH_ENABLED */
								if (!fuzzyName.empty()) {
									THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
								}

								THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
#endif /* DECLARE_WITH_TOUCH_ENABLED */
							}

							// Fill the parameter.
							args = fill(args, (Int16)top().inRam.address);
						}
						args = fill(args, (UInt8)TRUE);
					}
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("TOUCH");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "TOUCH");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** File functions
*/

class NodeFile : public NodeFunction {
public:
	NodeFile(const std::string &name) : NodeFunction(name) {
	}
	virtual ~NodeFile() override {
	}

	NODE_TYPE(Types::FILE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		validate(context, onError);

		NodeFunction::generate(bytes, context, onError);
	}

private:
	bool validate(Context::Stack &context, Error::Handler onError) const {
		Context &ctx = context.top();

		if (ctx.sramType == 0x00) { // No SRAM.
			THROW_USING_FILE_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED(onError);

			return false;
		}

		return true;
	}
};

/* ===========================================================================} */

/*
** {===========================================================================
** Serial functions
*/

class NodeSerial : public Node {
public:
	NodeSerial() {
	}
	virtual ~NodeSerial() override {
	}

	NODE_TYPE(Types::SERIAL)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "serial")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the query type.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)DEVICE_QUERY_SERIAL_STATUS);

					// Emit a `VM_QUERY` instruction.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::QUERY]); DEC_COUNTER(stk, 2); INC_COUNTER(stk, 2);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SERIAL");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SERIAL");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Memory operations
*/

class NodeFiller : public Node {
public:
	NodeFiller() {
	}
	virtual ~NodeFiller() override {
	}

	NODE_TYPE(Types::FILLER)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "filler")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Emit placeholders.
			int rest = 0;
			if (!_children.empty()) {
				Token::Ptr simpleTk = onlyTokenInOnlyChild();
				if (!(simpleTk && simpleTk->is(Token::Types::NUMBER))) { THROW_INVALID_SYNTAX(onError); }
				rest = (int)(Int)simpleTk->data();
			}

			writePlaceholder(bytes, context, rest);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("FILLER");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "FILLER");
	}
	using Node::dump;
};

class NodeMemcpy : public Node {
private:
	enum class OperationTypes {
		NONE,
		TILE,
		MAP
	};

private:
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeMemcpy() {
	}
	virtual ~NodeMemcpy() override {
	}

	NODE_TYPE(Types::MEMCPY)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			int argn = 0;
			bool read = false;
			bool data = false;
			int arge = 0;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "memcpy")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "=")) {
				arge = (int)_children.size() - argn;
				if (consume(Token::Types::KEYWORD, "with")) {
					if (consume(Token::Types::KEYWORD, "tile")) { _type = OperationTypes::TILE; }
					else if (consume(Token::Types::KEYWORD, "map")) { _type = OperationTypes::MAP; }
					else { THROW_INVALID_SYNTAX(onError); }
				} else {
					if (consume(Token::Types::KEYWORD, "read")) read = true;
					else if (consume(Token::Types::KEYWORD, "data")) data = true;
					else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
				}
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			}

			// Determine the manipulation.
			switch (_type) {
			case OperationTypes::NONE: {
					UInt8 src = ASSET_SOURCE_FAR;
					if (read) src = ASSET_SOURCE_READ;
					else if (data) src = ASSET_SOURCE_DATA;
					if (read) {
						// Check the children.
						if (argn <= 1) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (argn == 2) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						// Emit the instruction.
						do { // `MEMCPY(dst, n) = READ`.
							// Set the stack footprint guard.
							VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
							COUNTER_GUARD(ctx, stk);

							// Emit the arguments.
							writeChildren(bytes, context, Range(1), stk, onError); // `n`.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Address.
							args = fill(args, (UInt16)0);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Bank.
							args = fill<Int16, UInt16>(args, (Int16)0);
							writeChildren(bytes, context, Range(0), stk, onError); // `dst`.

							// Emit a `VM_MEMCPY` instruction.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMCPY]); DEC_COUNTER(stk, 2 * 5);
							args = fill(args, (Int8)src);

							// Check the stack footprint.
							CHECK_COUNTER(ctx, onError);
						} while (false);
					} else if (data) {
						// Check the children.
						if (argn <= 1) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (argn == 2) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						// Emit the instruction.
						do { // `MEMCPY(dst, n) = DATA ...`.
							// Set the stack footprint guard.
							VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
							COUNTER_GUARD(ctx, stk);

							// Emit the arguments.
							writeChildren(bytes, context, Range(1), stk, onError); // `n`.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Address.
							args = fill(args, (UInt16)0);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Bank.
							args = fill<Int16, UInt16>(args, (Int16)0);
							writeChildren(bytes, context, Range(0), stk, onError); // `dst`.

							// Emit a `VM_MEMCPY` instruction.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMCPY]); DEC_COUNTER(stk, 2 * 5);
							args = fill(args, (Int8)src);

							// Check the stack footprint.
							CHECK_COUNTER(ctx, onError);
						} while (false);
					} else if (byName_) {
						// Check the children.
						if (argn <= 1) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (argn == 2 || argn == 3) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						// Emit the instruction.
						do { // `MEMCPY(dst, n[, offset]) = "{builtin}"`.
							// Get the arguments.
							if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
							const RomLocation* romLocation = ctx.symbols->find(name);
							if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
							const int bank = romLocation->bank;
							const int address = romLocation->address;

							// Set the stack footprint guard.
							VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
							COUNTER_GUARD(ctx, stk);

							// Emit the arguments.
							if (argn == 3) {
								writeChildren(bytes, context, Range(2), stk, onError); // `offset`.
							} else {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // `offset`.
								args = fill(args, (Int16)0);
							}
							writeChildren(bytes, context, Range(1), stk, onError); // `n`.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Address.
							args = fill(args, (UInt16)address);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Bank.
							args = fill<Int16, UInt16>(args, (Int16)bank);
							writeChildren(bytes, context, Range(0), stk, onError); // `dst`.

							// Emit a `VM_MEMCPY` instruction.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMCPY]); DEC_COUNTER(stk, 2 * 5);
							args = fill(args, (Int8)src);

							// Check the stack footprint.
							CHECK_COUNTER(ctx, onError);
						} while (false);
					} else { // From address.
						// Check the children.
						if (_children.size() <= 3) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 4) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						// Emit the instruction.
						do { // `MEMCPY(dst, bank, ptr, n)`.
							// Set the stack footprint guard.
							VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
							COUNTER_GUARD(ctx, stk);

							// Emit the arguments.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // `offset`.
							args = fill(args, (Int16)0);
							writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError); // `n`, `ptr`, `bank`, `dst`.

							// Emit a `VM_MEMCPY` instruction.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMCPY]); DEC_COUNTER(stk, 2 * 5);
							args = fill(args, (Int8)src);

							// Check the stack footprint.
							CHECK_COUNTER(ctx, onError);
						} while (false);
					}
				}

				break;
			case OperationTypes::TILE: {
					// Check the children.
					if (argn == 0) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (argn == 1 || argn == 2 || argn == 3) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Emit the instruction.
					do { // `MEMCPY(dst[, n][, offset]) = WITH TILE #pg|name`.
						// Get the arguments.
						int page = -1;
						Destination dest(0);
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, argn, true);
						if (tks.size() == 1) { /* Do nothing. */ }
						if (page == -1 && dest.isRight()) {
							const std::string name = dest.right().get();
							int pageIndex = -1;
							const TilesAssets &tiles = ctx.assets->tiles;
							const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
							if (tilesEntry) {
								page = pageIndex;
								dest = Left<int>(page);
							} else {
								std::string fuzzyName;
								if (tiles.fuzzy(name, nullptr, fuzzyName)) {
									THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
								}

								THROW_INVALID_ASSET_POINT(onError);
							}
						}

						if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
						if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

						int len = 0;
						if (argn == 1) {
							const TilesAssets &tiles = ctx.assets->tiles;
							const TilesAssets::Entry* tilesEntry = tiles.get(page);
							if (!tilesEntry) { THROW_INVALID_ASSET_POINT(onError); }

							const int tileCount = (tilesEntry->data->width() / GBBASIC_TILE_SIZE) * (tilesEntry->data->height() / GBBASIC_TILE_SIZE);
							len = tileCount * 8 * 2;
						}

						// Set the stack footprint guard.
						VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
						COUNTER_GUARD(ctx, stk);

						// Emit the arguments.
						SourceLocation target(page, tks.size() == 1 ? 0 : dest.left().get()); // `#pg:n`. By page number and index.
						if (argn == 3) {
							writeChildren(bytes, context, Range(2), stk, onError); // `offset`.
						} else {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // `offset`.
							args = fill(args, (Int16)0);
						}
						if (argn >= 2) {
							writeChildren(bytes, context, Range(1), stk, onError); // `n`.
						} else {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // `n`.
							args = fill(args, (UInt16)len);
						}
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Address.
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
						args = fill(args, (UInt16)COMPILER_PLACEHOLDER);
						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Bank.
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
						args = fill<Int16, UInt16>(args, (Int16)COMPILER_PLACEHOLDER);
						writeChildren(bytes, context, Range(0), stk, onError); // `dst`.

						// Emit a `VM_MEMCPY` instruction.
						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMCPY]); DEC_COUNTER(stk, 2 * 5);
						args = fill(args, (Int8)ASSET_SOURCE_FAR);

						// Check the stack footprint.
						CHECK_COUNTER(ctx, onError);
					} while (false);
				}

				break;
			case OperationTypes::MAP: {
					// Check the children.
					if (argn == 0) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (argn == 1 || argn == 2 || argn == 3) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Emit the instruction.
					do { // `MEMCPY(dst[, n][, offset]) = WITH MAP #pg|#pg:n|name`.
						// Get the arguments.
						int page = -1;
						Destination dest(0);
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, argn, true);
						if (tks.empty()) { THROW_INVALID_ASSET_POINT(onError); }
						if (page == -1 && dest.isRight()) {
							const std::string name = dest.right().get();
							int pageIndex = -1;
							const MapAssets &maps = ctx.assets->maps;
							const MapAssets::Entry* mapEntry = maps.find(name, &pageIndex); // By asset name.
							if (mapEntry) {
								page = pageIndex;
								dest = Left<int>(page);
							} else {
								std::string fuzzyName;
								if (maps.fuzzy(name, nullptr, fuzzyName)) {
									THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
								}

								THROW_INVALID_ASSET_POINT(onError);
							}
						}

						if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
						if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::MAP, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

						int len = 0;
						if (argn == 1) {
							const MapAssets &map = ctx.assets->maps;
							const MapAssets::Entry* mapEntry = map.get(page);
							if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

							const int tileCount = mapEntry->data->width() * mapEntry->data->height();
							len = tileCount;
						}

						// Set the stack footprint guard.
						VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
						COUNTER_GUARD(ctx, stk);

						// Emit the arguments.
						SourceLocation target(page, tks.size() == 1 ? 0 : dest.left().get()); // `#pg:n`. By page number and index.
						if (argn == 3) {
							writeChildren(bytes, context, Range(2), stk, onError); // `offset`.
						} else {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // `offset`.
							args = fill(args, (Int16)0);
						}
						if (argn >= 2) {
							writeChildren(bytes, context, Range(1), stk, onError); // `n`.
						} else {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // `n`.
							args = fill(args, (UInt16)len);
						}
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Address.
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
						args = fill(args, (UInt16)COMPILER_PLACEHOLDER);
						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Bank.
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
						args = fill<Int16, UInt16>(args, (Int16)COMPILER_PLACEHOLDER);
						writeChildren(bytes, context, Range(0), stk, onError); // `dst`.

						// Emit a `VM_MEMCPY` instruction.
						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMCPY]); DEC_COUNTER(stk, 2 * 5);
						args = fill(args, (Int8)ASSET_SOURCE_FAR);

						// Check the stack footprint.
						CHECK_COUNTER(ctx, onError);
					} while (false);
				}

				break;
			default:
				GBBASIC_ASSERT(false && "Impossible.");

				break;
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::TILE: {
				GBBASIC_ASSERT(_scheduled.size() == 2 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int bank = locations.front().bank;
				const int address = locations.front().address;
				const int size = locations.front().size;
				const int offset = scheduled.target.sub * 8 * 2;
				if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

				for (int i = 0; i < (int)_scheduled.size(); ++i) {
					scheduled = _scheduled[i];
					Byte* args = scheduled.args(bytes->pointer());
					if (i == 0)
						args = fill(args, (UInt16)(address + offset));
					else
						args = fill<Int16, UInt16>(args, (Int16)bank);
				}
			}

			break;
		case OperationTypes::MAP: {
				GBBASIC_ASSERT(_scheduled.size() == 2 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::MAP, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (scheduled.target.sub < 0 || scheduled.target.sub >= (int)locations.size()) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[scheduled.target.sub];
				const int bank = loc.bank;
				const int address = loc.address;

				for (int i = 0; i < (int)_scheduled.size(); ++i) {
					scheduled = _scheduled[i];
					Byte* args = scheduled.args(bytes->pointer());
					if (i == 0)
						args = fill(args, (UInt16)address);
					else
						args = fill<Int16, UInt16>(args, (Int16)bank);
				}
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("MEMCPY");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "MEMCPY");
	}
	using Node::dump;
};

class NodeMemset : public Node {
public:
	NodeMemset() {
	}
	virtual ~NodeMemset() override {
	}

	NODE_TYPE(Types::MEMSET)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "memset")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 2) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 3) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the arguments.
			writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

			// Emit a `VM_MEMSET` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMSET]); DEC_COUNTER(stk, 2 * 3);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("MEMSET");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "MEMSET");
	}
	using Node::dump;
};

class NodeMemadd : public Node {
public:
	NodeMemadd() {
	}
	virtual ~NodeMemadd() override {
	}

	NODE_TYPE(Types::MEMADD)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "memadd")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 2) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 3) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the arguments.
			writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

			// Emit a `VM_MEMADD` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::MEMADD]); DEC_COUNTER(stk, 2 * 3);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("MEMADD");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "MEMADD");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Object operations and manipulators
*/

class NodeNew : public Node {
public:
	NodeNew() {
	}
	virtual ~NodeNew() override {
	}

	NODE_TYPE(Types::NEW)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "new")) { THROW_INVALID_SYNTAX(onError); }
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Emit the specific instruction to new something.
			if (id == "actor") {
				const bool withDeclaring = ctx.declaration.declaring != -1;
				if (!withDeclaring) { THROW_MEMORY_LEAK(onError); }
				writeFunction(bytes, context, Asm::Types::NEW_ACTOR, ASSET_SOURCE_IGNORED, 0, nullptr, nullptr, onError);
			} else {
				THROW_UNKNOWN_TYPE(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("NEW");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "NEW");
	}
	using Node::dump;
};

class NodeWidth : public Node {
public:
	NodeWidth() {
	}
	virtual ~NodeWidth() override {
	}

	NODE_TYPE(Types::WIDTH)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "width")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the width of GUI text.
			int page = -1;
			Destination dest(0);
			Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true);
			if (tks.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
			if (dest.isRight()) {
				const std::string name = dest.right().get();
				const FontAssets &fonts = ctx.assets->fonts;
				int pageIndex = -1;
				const FontAssets::Entry* fontEntry = fonts.find(name, &pageIndex); // By asset name.
				if (fontEntry) {
					page = pageIndex;
				} else {
					std::string fuzzyName;
					if (fonts.fuzzy(name, nullptr, fuzzyName)) {
						THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
					}

					THROW_INVALID_ASSET_POINT(onError);
				}
			}

			Token::Ptr tk = nullptr;
			std::string str;
			if (!isString(context, 1, &str, &tk)) {
				CHECK_FOR_STRING(onError, tk);
			}

			int ret = 0;
			FontAssets &fonts = ctx.assets->fonts;
			FontAssets::Entry* font = fonts.get(page);
			if (!font) { THROW_INVALID_ASSET_POINT(onError); }
			const glyph_option_t opt(
				font->isTwoBitsPerPixel,
				font->preferFullWord,
				font->preferFullWordForNonAscii,
				font->inverted
			);
			str = Text::replace(str, "\\r", "\r");
			str = Text::replace(str, "\\n", "\n");
			str = Text::replace(str, "\\f", "\f");
			const std::wstring wstr = Unicode::toWide(str);
			const wchar_t* wptr = wstr.c_str();
			while (*wptr) {
				wchar_t cp = *wptr++;
				if (!cp)
					break;
				if (cp == GLYPH_ESCAPE_PLACEHOLDER) {
					const wchar_t cp_ = *wptr++;
					if (!cp_)
						break;
					switch (cp_) {
					case GLYPH_ESCAPE_INT: // Fall through.
					case GLYPH_ESCAPE_HEX: // Fall through.
					case GLYPH_ESCAPE_CHAR:
						THROW_NOT_SUPPORTED(onError, nullptr);
					case GLYPH_ESCAPE_PERCENT: {
							const GlyphTable::Entry glyph(cp);
							int width = 0;
							if (!FontAssets::measure(*font, glyph, &width, nullptr)) {
								THROW_INVALID_GLYPH(onError);
							}
							ret += width;
							cp = cp_;
						}

						break;
					}
				} else if (cp == GLYPH_ESCAPE_SPECIAL) {
					const wchar_t cp_ = *wptr++;
					if (!cp_)
						break;
					switch (cp_) {
					case GLYPH_ESCAPE_UNICODE: {
							std::wstring wstr;
							wptr = escapeUnicode(wptr, wstr);

							if (wstr.length() != 1) {
								THROW_INVALID_GLYPH(onError);
							}

							const GlyphTable::Entry glyph(wstr.front());
							int width = 0;
							if (!FontAssets::measure(*font, glyph, &width, nullptr)) {
								THROW_INVALID_GLYPH(onError);
							}
							ret += width;

							continue;
						}
					case GLYPH_ESCAPE_STACK:
						THROW_NOT_SUPPORTED(onError, nullptr);
					case GLYPH_ESCAPE_BACKSLASH: {
							const GlyphTable::Entry glyph(cp);
							int width = 0;
							if (!FontAssets::measure(*font, glyph, &width, nullptr)) {
								THROW_INVALID_GLYPH(onError);
							}
							ret += width;
							cp = cp_;
						}

						break;
					}
				} else if (cp == '\r') {
					THROW_NOT_SUPPORTED(onError, nullptr);
				} else if (cp == '\n') {
					THROW_NOT_SUPPORTED(onError, nullptr);
				} else if (cp == '\f') {
					THROW_NOT_SUPPORTED(onError, nullptr);
				}

				const GlyphTable::Entry glyph(cp);
				int width = 0;
				if (!FontAssets::measure(*font, glyph, &width, nullptr)) {
					THROW_INVALID_GLYPH(onError);
				}
				ret += width;
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET_CONST` instruction to set the data.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
					args = fill(args, (Int16)ret);
					args = fill(args, (Int16)ARG0);
				}, 0, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("WIDTH");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "WIDTH");
	}
	using Node::dump;
};

class NodeHeight : public Node {
public:
	NodeHeight() {
	}
	virtual ~NodeHeight() override {
	}

	NODE_TYPE(Types::HEIGHT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "height")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Get the height of GUI text.
			int page = -1;
			Destination dest(0);
			Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true);
			if (tks.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
			if (dest.isRight()) {
				const std::string name = dest.right().get();
				const FontAssets &fonts = ctx.assets->fonts;
				int pageIndex = -1;
				const FontAssets::Entry* fontEntry = fonts.find(name, &pageIndex); // By asset name.
				if (fontEntry) {
					page = pageIndex;
				} else {
					std::string fuzzyName;
					if (fonts.fuzzy(name, nullptr, fuzzyName)) {
						THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
					}

					THROW_INVALID_ASSET_POINT(onError);
				}
			}

			Token::Ptr tk = nullptr;
			std::string str;
			if (!isString(context, 1, &str, &tk)) {
				CHECK_FOR_STRING(onError, tk);
			}

			int ret = 0;
			FontAssets &fonts = ctx.assets->fonts;
			FontAssets::Entry* font = fonts.get(page);
			if (!font) { THROW_INVALID_ASSET_POINT(onError); }
			const glyph_option_t opt(
				font->isTwoBitsPerPixel,
				font->preferFullWord,
				font->preferFullWordForNonAscii,
				font->inverted
			);
			str = Text::replace(str, "\\r", "\r");
			str = Text::replace(str, "\\n", "\n");
			str = Text::replace(str, "\\f", "\f");
			const std::wstring wstr = Unicode::toWide(str);
			const wchar_t* wptr = wstr.c_str();
			while (*wptr) {
				wchar_t cp = *wptr++;
				if (!cp)
					break;
				if (cp == GLYPH_ESCAPE_PLACEHOLDER) {
					const wchar_t cp_ = *wptr++;
					if (!cp_)
						break;
					switch (cp_) {
					case GLYPH_ESCAPE_INT: // Fall through.
					case GLYPH_ESCAPE_HEX: // Fall through.
					case GLYPH_ESCAPE_CHAR:
						THROW_NOT_SUPPORTED(onError, nullptr);
					case GLYPH_ESCAPE_PERCENT: {
							const GlyphTable::Entry glyph(cp);
							int height = 0;
							if (!FontAssets::measure(*font, glyph, nullptr, &height)) {
								THROW_INVALID_GLYPH(onError);
							}
							ret = Math::max(ret, height);
							cp = cp_;
						}

						break;
					}
				} else if (cp == GLYPH_ESCAPE_SPECIAL) {
					const wchar_t cp_ = *wptr++;
					if (!cp_)
						break;
					switch (cp_) {
					case GLYPH_ESCAPE_UNICODE: {
							std::wstring wstr;
							wptr = escapeUnicode(wptr, wstr);

							if (wstr.length() != 1) {
								THROW_INVALID_GLYPH(onError);
							}

							const GlyphTable::Entry glyph(wstr.front());
							int height = 0;
							if (!FontAssets::measure(*font, glyph, nullptr, &height)) {
								THROW_INVALID_GLYPH(onError);
							}
							ret = Math::max(ret, height);

							continue;
						}
					case GLYPH_ESCAPE_STACK:
						THROW_NOT_SUPPORTED(onError, nullptr);
					case GLYPH_ESCAPE_BACKSLASH: {
							const GlyphTable::Entry glyph(cp);
							int height = 0;
							if (!FontAssets::measure(*font, glyph, nullptr, &height)) {
								THROW_INVALID_GLYPH(onError);
							}
							ret = Math::max(ret, height);
							cp = cp_;
						}

						break;
					}
				} else if (cp == '\r') {
					THROW_NOT_SUPPORTED(onError, nullptr);
				} else if (cp == '\n') {
					THROW_NOT_SUPPORTED(onError, nullptr);
				} else if (cp == '\f') {
					THROW_NOT_SUPPORTED(onError, nullptr);
				}

				const GlyphTable::Entry glyph(cp);
				int height = 0;
				if (!FontAssets::measure(*font, glyph, nullptr, &height)) {
					THROW_INVALID_GLYPH(onError);
				}
				ret = Math::max(ret, height);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit a `VM_SET_CONST` instruction to set the data.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
					args = fill(args, (Int16)ret);
					args = fill(args, (Int16)ARG0);
				}, 0, true,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("HEIGHT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "HEIGHT");
	}
	using Node::dump;
};

class NodeIs : public Node {
public:
	NodeIs() {
	}
	virtual ~NodeIs() override {
	}

	NODE_TYPE(Types::IS)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr tkid = nullptr;
			Token::Ptr tktype = nullptr;
			int type = 0;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "is")) { THROW_INVALID_SYNTAX(onError); }
			if (!(tktype = consume(Token::Types::KEYWORD, ANYTHING))) {
				THROW_INVALID_SYNTAX(onError);
			} else {
				const std::string typeName = (std::string)tktype->data();
				if (typeName == "actor") { type = OBJECT_TYPE_ACTOR; }
				else if (typeName == "projectile") { type = OBJECT_TYPE_PROJECTILE; }
				else { THROW_UNKNOWN_TYPE(onError, tktype); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the argument from the child.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit a `VM_OBJECT_IS` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OBJECT_IS]); DEC_COUNTER(stk, 2); INC_COUNTER(stk, 2);
					args = fill(args, (UInt8)type);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("IS");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "IS");
	}
	using Node::dump;
};

class NodeViewport : public Node {
public:
	NodeViewport() {
	}
	virtual ~NodeViewport() override {
	}

	NODE_TYPE(Types::VIEWPORT)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "viewport")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit a `VM_VIEWPORT` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::VIEWPORT]);
			for (int i = (int)_children.size() - 1; i >= 0; --i) {
				const Ptr &child = _children[i];
				Token::Ptr idtk = nullptr;
				std::string id;
				idtk = child->onlyToken();
				if (!idtk) { THROW_INVALID_SYNTAX(onError); }
				id = (std::string)idtk->data();

				// Find the left hand ID in RAM.
				std::string fuzzyName;
				const RamLocation* ramLocation = ctx.findPageAndGlobal(id, fuzzyName);
				if (ramLocation) {
					const RamLocation inRam = *ramLocation;
					top().inRam = inRam;
				} else { // Declaration.
#if DECLARE_WITH_VIEWPORT_ENABLED
					const TextLocation &txtLoc = idtk->begin();
					if (!allocateHeap(ctx, ctx.heapSize, WORD_SIZE, id, RamLocation::Usages::VIEWPORT, txtLoc)) {
						if (allocateHeap(ctx, ctx.heapSize * 2, WORD_SIZE, id, RamLocation::Usages::VIEWPORT, txtLoc)) { THROW_HEAP_OVERFLOW(onError, true); }
						else { THROW_HEAP_OVERFLOW(onError, false); }
					}
#else /* DECLARE_WITH_VIEWPORT_ENABLED */
					if (!fuzzyName.empty()) {
						THROW_ID_HAS_NOT_BEEN_DECLARED_DID_YOU_MEAN(onError, idtk, fuzzyName);
					}

					THROW_ID_HAS_NOT_BEEN_DECLARED(onError, idtk);
#endif /* DECLARE_WITH_VIEWPORT_ENABLED */
				}

				// Fill the parameter.
				args = fill(args, (Int16)top().inRam.address);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("VIEWPORT");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "VIEWPORT");
	}
	using Node::dump;
};

class NodeSceneManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		DEF,
		LOAD
	};

private:
	Scheduled _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeSceneManipulation() {
	}
	virtual ~NodeSceneManipulation() override {
	}

	NODE_TYPE(Types::SCENE_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool read = false;
			bool data = false;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "load")
					action = ResourceManipulations::LOAD;
				else if (id == "get")
					action = ResourceManipulations::GET;
				else if (id == "set")
					action = ResourceManipulations::SET;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "scene" && !consume(Token::Types::KEYWORD, "scene")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "property")) {
				if (!(action == ResourceManipulations::GET || action == ResourceManipulations::SET)) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			} else if (consume(Token::Types::KEYWORD, "width")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_WIDTH;
			} else if (consume(Token::Types::KEYWORD, "height")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_HEIGHT;
			} else {
				if (action == ResourceManipulations::GET || action == ResourceManipulations::SET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			}
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "read")) read = true;
			else if (consume(Token::Types::KEYWORD, "data")) data = true;
			else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) byName_ = true;
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			UInt8 src = ASSET_SOURCE_FAR;
			if (read) src = ASSET_SOURCE_READ;
			else if (data) src = ASSET_SOURCE_DATA;
			switch (action) {
			case ResourceManipulations::DEF: {
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					if (argn == 0) {
						Token::Ptr simpleTk = onlyTokenInOnlyChild();
						if (!(simpleTk && simpleTk->is(Token::Types::IDENTIFIER) && simpleTk->text() == "nothing")) { THROW_INVALID_SYNTAX(onError); }

						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);

							return 3;
						};
					} else if (argn == 2) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 3;
						};
					} else if (argn == 3) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(2, 0), stk, onError);

							return 3;
						};
					}
					if (data) {
						argi = [&] (Counter &) -> void {
							if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
							Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						};
					} else if (byName_) {
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						const SceneAssets &scenes = ctx.assets->scenes;
						int pageIndex = -1;
						const SceneAssets::Entry* sceneEntry = scenes.find(name, &pageIndex); // By asset name.
						if (romLocation) {
							const int bank = romLocation->bank;
							const int address = romLocation->address;
							argi = [&, bank, address] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							};
						} else if (sceneEntry) {
							byName_ = false;
						} else {
							std::string fuzzyName;
							if (scenes.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
					}
					if (argn == 0) {
						writeRoutine(bytes, context, Asm::Types::DEF_SCENE, ASSET_SOURCE_IGNORED, 1, argf, nullptr, onError);
					} else if (read || data || byName_) {
						if (argn == 2) {
							writeRoutine(bytes, context, Asm::Types::DEF_SCENE, src, 2, argf, argi, onError);
						} else if (argn == 3) {
							writeRoutine(bytes, context, Asm::Types::DEF_SCENE, src, 3, argf, argi, onError);
						}
					} else /* From asset. */ {
						argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const SceneAssets &scenes = ctx.assets->scenes;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								scenes.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else { THROW_INVALID_ASSET_POINT(onError); }
							}

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SCENE, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get());
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled = Scheduled(target, offset, false);
							_type = OperationTypes::DEF;
						};
						if (argn == 2) {
							writeRoutine(bytes, context, Asm::Types::DEF_SCENE, src, 3, argf, argi, onError);
						} else if (argn == 3) {
							writeRoutine(bytes, context, Asm::Types::DEF_SCENE, src, 4, argf, argi, onError);
						}
					}
				}

				break;
			case ResourceManipulations::LOAD: {
					Token::Ptr simpleTk = onlyTokenInOnlyChild();
					const bool withNothing = (simpleTk && simpleTk->is(Token::Types::IDENTIFIER) && simpleTk->text() == "nothing");
					if (byName_) {
						const SceneAssets &scenes = ctx.assets->scenes;
						const int index = scenes.indexOf(name);
						if (index >= 0)
							byName_ = false;
					}
					if (read || data || byName_) {
						THROW_NOT_SUPPORTED(onError, nullptr);
					}
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					if (withNothing && argn != 0) { THROW_INVALID_SYNTAX(onError); }
					if (argn == 0) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Clear objects.
							args = fill(args, (UInt16)TRUE);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Sprite base tile.
							args = fill(args, (UInt16)0);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Map base tile.
							args = fill(args, (UInt16)0);

							return 3;
						};
					} else if (argn == 1) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Clear objects.
							args = fill(args, (UInt16)TRUE);
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Sprite base tile.
							args = fill(args, (UInt16)0);
							writeChildren(bytes, context, Range(0), stk, onError); // Map base tile.

							return 3;
						};
					} else if (argn == 2) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Clear objects.
							args = fill(args, (UInt16)TRUE);
							writeChildren(bytes, context, Range(1, 0), stk, onError); // Sprite base tile, map base tile.

							return 3;
						};
					} else if (argn == 3) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(2, 0), stk, onError); // Clear objects, sprite base tile, map base tile.

							return 3;
						};
					}
					if (withNothing) {
						argi = [&] (Counter &) -> void {
							emit(bytes, context, (UInt8)0);     // The tiles count.
							emit(bytes, context, (UInt8)0);     // The tiles bank.
							emit(bytes, context, (UInt16)0);    // The tiles address.
							emit(bytes, context, (UInt8)FALSE); // Is 8x16 sprite.
							emit(bytes, context, (UInt8)0);     // The scene's bank.
							emit(bytes, context, (UInt16)0);    // The scene's address.
							emit(bytes, context, (UInt8)0);     // The scene's width.
							emit(bytes, context, (UInt8)0);     // The scene's height.
						};
					} else {
						argi = [&] (Counter &) -> void {
							// Prepare.
							int page = -1;
							const SceneAssets &scenes = ctx.assets->scenes;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								scenes.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Destination dest(0);
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (scenes.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }

							const int sceneIndex = page;
							const SceneAssets::Entry* sceneEntry = scenes.get(sceneIndex);
							if (!sceneEntry) { THROW_INVALID_ASSET_POINT(onError); }

							const MapAssets &maps = ctx.assets->maps;
							const int mapIndex = sceneEntry->refMap;
							const MapAssets::Entry* mapEntry = maps.get(mapIndex);
							if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

							const int tilesIndex = mapEntry->ref;

							// Touch the tiles asset, since it's not touched elsewhere.
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, tilesIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

							// Emit the undetermined arguments.
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SCENE, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);          // The tiles count.
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);          // The tiles bank.
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);         // The tiles address.
							emit(bytes, context, (UInt8)BOOLEAN(COMPILER_PLACEHOLDER)); // Is 8x16 sprite.
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);          // The scene's bank.
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);         // The scene's address.
							_scheduled = Scheduled(target, offset, false);
							_type = OperationTypes::LOAD;

							// Emit the determined arguments.
							const Scene::Ptr &scenePtr = sceneEntry->data;
							emit(bytes, context, (UInt8)scenePtr->width());             // The scene's width.
							emit(bytes, context, (UInt8)scenePtr->height());            // The scene's height.
						};
					}
					do { /* From asset. */
						if (argn == 0) {
							writeRoutine(bytes, context, Asm::Types::LOAD_SCENE, ASSET_SOURCE_IGNORED, 1, argf, argi, onError);
						} else if (argn == 1) {
							writeRoutine(bytes, context, Asm::Types::LOAD_SCENE, ASSET_SOURCE_IGNORED, 2, argf, argi, onError);
						} else if (argn == 2) {
							writeRoutine(bytes, context, Asm::Types::LOAD_SCENE, ASSET_SOURCE_IGNORED, 3, argf, argi, onError);
						} else if (argn == 3) {
							writeRoutine(bytes, context, Asm::Types::LOAD_SCENE, ASSET_SOURCE_IGNORED, 4, argf, argi, onError);
						}
					} while (false);
				}

				break;
			case ResourceManipulations::GET:
				if (_children.size() == 3 || _children.size() == 1) {
					writeFunction(
						bytes, context,
						Asm::Types::GET_SCENE_PROP, ASSET_SOURCE_IGNORED, -1,
						[&] (Counter &stk) -> int {
							if (_children.size() == 3) {
								writeChildren(bytes, context, Range(2, 0), stk, onError);
							} else if (_children.size() == 1) {
								writeChildren(bytes, context, Range(0), stk, onError);
								const int n = 3 - (int)_children.size();
								for (int i = 0; i < n; ++i) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)FALSE);
								}
							}

							return 3;
						},
						nullptr,
						onError
					);
				} else {
					THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
				}

				break;
			case ResourceManipulations::SET:
				if (_children.size() == 4 || _children.size() == 2) {
					writeRoutine(
						bytes, context,
						Asm::Types::SET_SCENE_PROP, ASSET_SOURCE_IGNORED, -1,
						[&] (Counter &stk) -> int {
							if (_children.size() == 4) {
								writeChildren(bytes, context, Range(3, 0), stk, onError);
							} else if (_children.size() == 2) {
								writeChildren(bytes, context, Range(1, 0), stk, onError);
								const int n = 4 - (int)_children.size();
								for (int i = 0; i < n; ++i) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)FALSE);
								}
							}

							return 4;
						},
						nullptr,
						onError
					);
				} else {
					THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
				}

				break;
			case ResourceManipulations::GET_WIDTH: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const SceneAssets &scenes = ctx.assets->scenes;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						scenes.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (scenes.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int sceneIndex = page;
					const SceneAssets::Entry* sceneEntry = scenes.get(sceneIndex);
					if (!sceneEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SCENE, sceneIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = sceneEntry->data->width();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_HEIGHT: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const SceneAssets &scenes = ctx.assets->scenes;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						scenes.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (scenes.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int sceneIndex = page;
					const SceneAssets::Entry* sceneEntry = scenes.get(sceneIndex);
					if (!sceneEntry) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::SCENE, sceneIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = sceneEntry->data->height();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		switch (_type) {
		case OperationTypes::DEF: {
				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::SCENE, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() < 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int bank = locations.back().bank;
				const int address = locations.back().address;

				Byte* args = _scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		case OperationTypes::LOAD: {
				const MapAssets &maps = ctx.assets->maps;
				const ActorAssets &actors = ctx.assets->actors;
				const SceneAssets &scenes = ctx.assets->scenes;
				const int sceneIndex = _scheduled.target.page;
				const SceneAssets::Entry* sceneEntry = scenes.get(sceneIndex);
				if (!sceneEntry) { THROW_INVALID_ASSET_POINT(onError); }

				const int mapIndex = sceneEntry->refMap;
				const MapAssets::Entry* mapEntry = maps.get(mapIndex);
				if (!mapEntry) { THROW_INVALID_ASSET_POINT(onError); }

				const int tilesIndex = mapEntry->ref;
				Pipeline::Resource::Array tilesLocations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, tilesIndex, tilesLocations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (tilesLocations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int tilesCount = tilesLocations.back().size / 16;
				const int tilesBank = tilesLocations.back().bank;
				const int tilesAddress = tilesLocations.back().address;

				bool is8x16Sprite = false;
				if (sceneEntry->data->hasActors()) {
					const SceneAssets::Entry::Ref refActors_ = sceneEntry->getRefActors(nullptr);
					for (int i = 0; i < (int)refActors_.size(); ++i) {
						const int actorIndex = refActors_[i];
						const ActorAssets::Entry* actorEntry = actors.get(actorIndex);
						if (!actorEntry) { THROW_INVALID_ASSET_POINT(onError); }
						if (i == 0) {
							is8x16Sprite = actorEntry->data->is8x16();
						} else {
							if (is8x16Sprite != actorEntry->data->is8x16()) {
								THROW_INVALID_ASSET_POINT(onError);
							}
						}
					}
				}

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::SCENE, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() < 1) { THROW_INVALID_ASSET_POINT(onError); }
				const int bank = locations.back().bank;
				const int address = locations.back().address;

				Byte* args = _scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)tilesCount);            // The tiles count.
				args = fill(args, (UInt8)tilesBank);             // The tiles bank.
				args = fill(args, (UInt16)tilesAddress);         // The tiles address.
				args = fill(args, (UInt8)BOOLEAN(is8x16Sprite)); // Is 8x16 sprite.
				args = fill(args, (UInt8)bank);                  // The scene's bank.
				args = fill(args, (UInt16)address);              // The scene's address.
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("SCENE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SCENE");
	}
	using Node::dump;
};

class NodeActorManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		FILL,
		DEF,
		SET_ACTOR_PROP,
		THREAD,
		ON
	};

private:
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeActorManipulation() {
	}
	virtual ~NodeActorManipulation() override {
	}

	NODE_TYPE(Types::ACTOR_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool read = false;
			bool data = false;
			int arge = 0;
			int motion = 0;
			EventTypes event = EventTypes::NONE;
			bool byName_ = false;
			std::string name;
			Token::Ptr tk1st = firstTokenInThisOrChildren();
			if (tk1st) state.inCode = SourceLocation(tk1st->begin().page);
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "fill")
					action = ResourceManipulations::FILL;
				else if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "del")
					action = ResourceManipulations::DEL;
				else if (id == "get")
					action = ResourceManipulations::GET;
				else if (id == "set")
					action = ResourceManipulations::SET;
				else if (id == "find")
					action = ResourceManipulations::FIND;
				else if (id == "move")
					action = ResourceManipulations::PUT;
				else if (id == "stop")
					action = ResourceManipulations::STOP;
				else if (id == "control")
					action = ResourceManipulations::CONTROL;
				else if (id == "play")
					action = ResourceManipulations::PLAY;
				else if (id == "start")
					action = ResourceManipulations::START;
				else if (id == "join")
					action = ResourceManipulations::JOIN;
				else if (id == "kill")
					action = ResourceManipulations::KILL;
				else if (id == "wait")
					action = ResourceManipulations::WAIT;
				else if (id == "on")
					action = ResourceManipulations::ON;
				else if (id == "off")
					action = ResourceManipulations::OFF;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "actor" && !consume(Token::Types::KEYWORD, "actor")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "property")) {
				if (!(action == ResourceManipulations::GET || action == ResourceManipulations::SET)) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			} else if (consume(Token::Types::KEYWORD, "len")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::LEN;
			} else if (consume(Token::Types::KEYWORD, "width")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_WIDTH;
			} else if (consume(Token::Types::KEYWORD, "height")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_HEIGHT;
			} else {
				if (action == ResourceManipulations::GET || action == ResourceManipulations::SET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			}
			if (action == ResourceManipulations::FILL) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
				else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
				else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::DEF) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
				else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
				else if ((_children.size() - argn == 3) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::DEL) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
			} else if (action == ResourceManipulations::FIND) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
			} else if (action == ResourceManipulations::PUT) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				arge = (int)_children.size() - argn;
				if (consume(Token::Types::KEYWORD, "with")) { motion |= ACTOR_MOTION_IN_DIRECTION; }
				else if (consume(Token::Types::KEYWORD, "to")) { motion |= ACTOR_MOTION_TO_POINT; }
				// else if (arge == 2 || arge == 3) { motion |= ACTOR_MOTION_IN_DIRECTION; } // `move actor(...) dx, dy` without `with`.
				else if (arge == 0) { motion |= ACTOR_MOTION_STOP; }
				else { THROW_INVALID_SYNTAX(onError); }
			} else if (action == ResourceManipulations::STOP) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				motion |= ACTOR_MOTION_STOP;
			} else if (action == ResourceManipulations::CONTROL) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::PLAY) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::START) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::JOIN) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::KILL) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::ON) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "hits")) { event = EventTypes::HITS; }
				else { THROW_INVALID_OPERATION(onError, idtk); }
				if (consume(Token::Types::KEYWORD, "start")) { /* Do nothing. */ }
				else { THROW_INVALID_OPERATION(onError, idtk); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::OFF) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "hits")) { event = EventTypes::HITS; }
				else { THROW_INVALID_OPERATION(onError, idtk); }
			} else {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (expectAssign(action)) {
					if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
				else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
				else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
				else if ((_children.size() - argn == 2) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; arge = 1; }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::FILL:
				if (byName_) {
					const ActorAssets &actors = ctx.assets->actors;
					const int index = actors.indexOf(name);
					if (index >= 0)
						byName_ = false;
				}
				if (read) {
					writeRoutine(bytes, context, Asm::Types::FILL_TILE, ASSET_SOURCE_READ, GRAPHICS_LAYER_SPRITE, 2, nullptr, nullptr, onError);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					constexpr const int M = 16;
					const int n = (int)Token::sizeOfIntegers(seq);
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
					const Token::Ptr tk = _children[1]->onlyToken();
					if (tk && tk->is(Token::Types::INTEGER)) {
						if ((int)tk->data() * M != n) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_DATA, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
					const int bank = romLocation->bank;
					const int address = romLocation->address;
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							emit(bytes, context, (UInt8)bank);
							emit(bytes, context, (UInt16)address);
						},
						onError
					);
				} else /* From asset. */ {
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const ActorAssets &actors = ctx.assets->actors;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								actors.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (actors.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							const ActorAssets::Entry* entry = actors.get(page);
							if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
							if (!entry->asActor) { THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::ACTOR, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
							_type = OperationTypes::FILL;
						},
						onError
					);
				}

				break;
			case ResourceManipulations::DEF: {
					UInt8 src = ASSET_SOURCE_FAR;
					if (read) src = ASSET_SOURCE_READ;
					else if (data) src = ASSET_SOURCE_DATA;
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					if (argn == 3) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);
							writeChildren(bytes, context, Range(2, 0), stk, onError);

							return 4;
						};
					} else if (argn == 4) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(3, 0), stk, onError);

							return 4;
						};
					}
					if (data) {
						argi = [&] (Counter &) -> void {
							if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
							Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						};
					} else if (byName_) {
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						argi = [&, bank, address] (Counter &) -> void {
							emit(bytes, context, (UInt8)bank);
							emit(bytes, context, (UInt16)address);
						};
					}
					if (read || data || byName_) {
						if (argn == 3) {
							writeRoutine(bytes, context, Asm::Types::DEF_ACTOR, src, 4, argf, argi, onError);
						} else if (argn == 4) {
							writeRoutine(bytes, context, Asm::Types::DEF_ACTOR, src, 5, argf, argi, onError);
						}
					} else /* From asset. */ {
						argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const ActorAssets &actors = ctx.assets->actors;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								actors.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (actors.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							const ActorAssets::Entry* entry = actors.get(page);
							if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
							if (!entry->asActor) { THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::ACTOR, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
							_type = OperationTypes::DEF;
						};
						if (argn == 3) {
							writeRoutine(bytes, context, Asm::Types::DEF_ACTOR, src, 4, argf, argi, onError);
						} else if (argn == 4) {
							writeRoutine(bytes, context, Asm::Types::DEF_ACTOR, src, 5, argf, argi, onError);
						}
					}
				}

				break;
			case ResourceManipulations::DEL:
				if (argn == 0) { // Delete all actors.
					writeRoutine(
						bytes, context,
						Asm::Types::DEL_ACTOR, ASSET_SOURCE_IGNORED, 0,
						[&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)NULL);

							return 1;
						},
						nullptr,
						onError
					);
				} else /* if (argn == 1) */ { // Delete one particular actor.
					writeRoutine(bytes, context, Asm::Types::DEL_ACTOR, ASSET_SOURCE_IGNORED, 1, nullptr, nullptr, onError);
				}

				break;
			case ResourceManipulations::GET:
				writeFunction(bytes, context, Asm::Types::GET_ACTOR_PROP, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::SET:
				if (read) {
					writeRoutine(
						bytes, context,
						Asm::Types::SET_ACTOR_PROP, ASSET_SOURCE_READ, 2,
						[&] (Counter &stk) -> int {
							if (arge)
								writeChildren(bytes, context, Range(1 + arge, 1 + 1), stk, onError);
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2 + arge;
						},
						nullptr,
						onError
					);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					Token::Ptr tk = nullptr;
					int val = 0;
					int m = -1;
					if (isUInt8(context, 1, val, &tk)) {
						switch (val) {
						// These magic numbers are associated with the data layout defined by GBDK's metasprite structure.
						case PROPERTY_FRAMES:       m = 2;       break;
						case PROPERTY_ANIMATIONS:   m = 6 - 2;   break;
						case PROPERTY_ANIMATION:    m = 6 - 2;   break;
						}
					}
					const int n = (int)Token::sizeOfIntegers(seq);
					if (m > 0 && n < m) { THROW_TOO_FEW_ARGUMENTS(onError); }
					writeRoutine(
						bytes, context,
						Asm::Types::SET_ACTOR_PROP, ASSET_SOURCE_DATA, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					Token::Ptr tk = nullptr;
					int data = 0;
					const bool forFrame = isUInt8(context, 1, data, &tk) && data == PROPERTY_FRAMES;
					if (forFrame) {
						if (_children.size() != 4) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
					const int bank = romLocation->bank;
					const int address = romLocation->address;
					writeRoutine(
						bytes, context,
						Asm::Types::SET_ACTOR_PROP, ASSET_SOURCE_FAR, 2,
						[&] (Counter &stk) -> int {
							if (arge)
								writeChildren(bytes, context, Range(1 + arge, 1 + 1), stk, onError);
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2 + arge;
						},
						[&] (Counter &) -> void {
							emit(bytes, context, (UInt8)bank);
							emit(bytes, context, (UInt16)address);
						},
						onError
					);
				} else /* From asset. */ {
					Token::Ptr tk = nullptr;
					int data = 0;
					const bool forFrame = isUInt8(context, 1, data, &tk) && data == PROPERTY_FRAMES;
					if (forFrame) {
						if (_children.size() != 4) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					} else {
						if (_children.size() < 3) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 3 || _children.size() == 4 || _children.size() == 6) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}
					}
					if (forFrame) {
						Generator_Int_Counter argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(2, 0), stk, onError);

							return 3;
						};
						Generator_Void_Counter argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const ActorAssets &actors = ctx.assets->actors;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								actors.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (actors.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							const ActorAssets::Entry* entry = actors.get(page);
							if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
							if (!entry->asActor) { THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::ACTOR, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
							_type = OperationTypes::SET_ACTOR_PROP;
						};
						writeRoutine(bytes, context, Asm::Types::SET_ACTOR_PROP, ASSET_SOURCE_FAR, 3, argf, argi, onError);
					} else {
						writeRoutine(bytes, context, Asm::Types::SET_ACTOR_PROP, ASSET_SOURCE_STACK, -1, nullptr, nullptr, onError);
					}
				}

				break;
			case ResourceManipulations::LEN: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const ActorAssets &actors = ctx.assets->actors;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						actors.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (actors.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int actorIndex = page;
					const ActorAssets::Entry* entry = actors.get(actorIndex);
					if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
					if (!entry->asActor) { THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::ACTOR, actorIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = entry->data->count();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_WIDTH: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const ActorAssets &actors = ctx.assets->actors;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						actors.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (actors.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int actorIndex = page;
					const ActorAssets::Entry* entry = actors.get(actorIndex);
					if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
					if (!entry->asActor) { THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::ACTOR, actorIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int actorFrame = dest.left().get();
					const Actor::Ptr &actorPtr = entry->data;
					const Actor::Frame* actorFrame_ = actorPtr->get(actorFrame);
					if (!actorFrame_) { THROW_INVALID_ASSET_POINT(onError); }
					const int ret = actorFrame_->width();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_HEIGHT: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const ActorAssets &actors = ctx.assets->actors;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						actors.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (actors.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int actorIndex = page;
					const ActorAssets::Entry* entry = actors.get(actorIndex);
					if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
					if (!entry->asActor) { THROW_ASSET_IS_DEFINED_AS_A_PROJECTILE_BUT_USED_AS_AN_ACTOR(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::ACTOR, actorIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int actorFrame = dest.left().get();
					const Actor::Ptr &actorPtr = entry->data;
					const Actor::Frame* actorFrame_ = actorPtr->get(actorFrame);
					if (!actorFrame_) { THROW_INVALID_ASSET_POINT(onError); }
					const int ret = actorFrame_->height();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::FIND: {
					UInt8 filterType = ACTOR_FILTER_BY_BEHAVIOUR;
					UInt8 filterTmp = 0;
					int page = -1;
					Destination dest(0);
					Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true /* for page number (`#PgNo`) */);
					if (tks.size() == 1) {
						const ActorAssets &actors = ctx.assets->actors;
						if (dest.isLeft()) {
							if (page == -1) {
								const int val = dest.left().get();
								if (val == ACTOR_TEMPLATE_ANY) {
									filterType = ACTOR_FILTER_BY_TEMPLATE;
									filterTmp = (UInt8)dest.left().get(); // By template wildcard (`any_template`).
								} else {
									filterType = ACTOR_FILTER_BY_BEHAVIOUR;
									filterTmp = (UInt8)dest.left().get(); // By behaviour.
								}
							} else {
								if (page < 0 || page >= actors.count()) { THROW_INVALID_ASSET_POINT(onError); }
								filterType = ACTOR_FILTER_BY_TEMPLATE;
								filterTmp = (UInt8)page; // By page number.
							}
						} else if (dest.isRight()) {
							const std::string name = dest.right().get();
							const int idx = actors.indexOf(name);
							if (idx == -1) { THROW_INVALID_ASSET_POINT(onError); }
							filterType = ACTOR_FILTER_BY_TEMPLATE;
							filterTmp = (UInt8)idx; // By asset name.
						} else {
							THROW_INVALID_ASSET_POINT(onError);
						}
					}
					if (argn == 1) {
						writeFunction(
							bytes, context,
							Asm::Types::FIND_ACTOR, filterType, -1,
							[&] (Counter &stk) -> int {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0);
								if (filterType == ACTOR_FILTER_BY_BEHAVIOUR) {
									writeChildren(bytes, context, Range(0), stk, onError);
								} else {
									args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)filterTmp);
								}

								return 2;
							},
							nullptr,
							onError
						);
					} else /* if (argn == 2) */ {
						writeFunction(
							bytes, context,
							Asm::Types::FIND_ACTOR, filterType, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1), stk, onError);
								if (filterType == ACTOR_FILTER_BY_BEHAVIOUR) {
									writeChildren(bytes, context, Range(0), stk, onError);
								} else {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)filterTmp);
								}

								return 2;
							},
							nullptr,
							onError
						);
					}
				}

				break;
			case ResourceManipulations::PUT:
				if (_children.empty()) {
					switch (motion) {
					case ACTOR_MOTION_IN_DIRECTION:
						THROW_TOO_FEW_ARGUMENTS(onError);

						break;
					case ACTOR_MOTION_TO_POINT:
						THROW_TOO_FEW_ARGUMENTS(onError);

						break;
					case ACTOR_MOTION_STOP:
						writeRoutine(
							bytes, context,
							Asm::Types::MOVE_ACTOR, motion, -1,
							[&] (Counter &stk) -> int {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)NULL); // Stop all.

								return 1;
							},
							nullptr,
							onError
						);

						break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
				} else if (argn == 1) {
					switch (motion) {
					case ACTOR_MOTION_IN_DIRECTION:
						if (arge < 2) { THROW_TOO_FEW_ARGUMENTS(onError); }
						else if (arge > 3) { THROW_TOO_MANY_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::MOVE_ACTOR, motion, -1,
							[&] (Counter &stk) -> int {
								if (arge == 2) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)CONTROLLER_MOVABLE_FLAG_NONE); // Flags for movement checking.
								}
								writeChildren(bytes, context, Range((int)_children.size() - 1, 1), stk, onError);
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Wait for.
								writeChildren(bytes, context, Range(0), stk, onError);

								return 5;
							},
							nullptr,
							onError
						);

						break;
					case ACTOR_MOTION_TO_POINT:
						if (arge < 2) { THROW_TOO_FEW_ARGUMENTS(onError); }
						else if (arge > 3) { THROW_TOO_MANY_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::MOVE_ACTOR, motion, -1,
							[&] (Counter &stk) -> int {
								if (arge == 2) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)CONTROLLER_MOVABLE_FLAG_NONE); // Flags for movement checking.
								}
								writeChildren(bytes, context, Range((int)_children.size() - 1, 1), stk, onError);
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)TRUE); // Wait.
								writeChildren(bytes, context, Range(0), stk, onError);

								return 5;
							},
							nullptr,
							onError
						);

						break;
					case ACTOR_MOTION_STOP:
						if (arge > 0) { THROW_TOO_MANY_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::MOVE_ACTOR, motion, -1,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(0), stk, onError);

								return 1;
							},
							nullptr,
							onError
						);

						break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
				} else if (argn == 2) {
					switch (motion) {
					case ACTOR_MOTION_IN_DIRECTION:
						if (arge < 2) { THROW_TOO_FEW_ARGUMENTS(onError); }
						else if (arge > 3) { THROW_TOO_MANY_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::MOVE_ACTOR, motion, -1,
							[&] (Counter &stk) -> int {
								if (arge == 2) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)CONTROLLER_MOVABLE_FLAG_NONE); // Flags for movement checking.
								}
								writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

								return 5;
							},
							nullptr,
							onError
						);

						break;
					case ACTOR_MOTION_TO_POINT:
						if (arge < 2) { THROW_TOO_FEW_ARGUMENTS(onError); }
						else if (arge > 3) { THROW_TOO_MANY_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::MOVE_ACTOR, motion, -1,
							[&] (Counter &stk) -> int {
								if (arge == 2) {
									Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
									args = fill(args, (UInt16)CONTROLLER_MOVABLE_FLAG_NONE); // Flags for movement checking.
								}
								writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

								return 5;
							},
							nullptr,
							onError
						);

						break;
					case ACTOR_MOTION_STOP:
						THROW_INVALID_SYNTAX(onError);

						break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				break;
			case ResourceManipulations::STOP:
				if (_children.empty()) {
					writeRoutine(
						bytes, context,
						Asm::Types::MOVE_ACTOR, motion, -1,
						[&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)NULL); // Stop all.

							return 1;
						},
						nullptr,
						onError
					);
				} else if (argn == 1) {
					writeRoutine(
						bytes, context,
						Asm::Types::MOVE_ACTOR, motion, -1,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(0), stk, onError);

							return 1;
						},
						nullptr,
						onError
					);
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				break;
			case ResourceManipulations::CONTROL:
				writeRoutine(
					bytes, context,
					Asm::Types::SET_ACTOR_PROP, ASSET_SOURCE_STACK, 2,
					[&] (Counter &stk) -> int {
						writeChildren(bytes, context, Range(1), stk, onError);
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
						args = fill(args, (UInt16)PROPERTY_BEHAVIOUR);
						writeChildren(bytes, context, Range(0), stk, onError);

						return 3;
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::PLAY:
				writeRoutine(bytes, context, Asm::Types::PLAY_ACTOR, ASSET_SOURCE_IGNORED, -1, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::START: {
					int page = -1;
					Destination dest(0);
					if (_children.size() < 2) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (_children.size() == 2) {
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 1, false);
						if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					SourceLocation target;
					if (dest.isLeft())
						target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
					else
						target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
					const RomLocation* romLocation = ctx.find(target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					writeRoutine(
						bytes, context,
						Asm::Types::THREAD_ACTOR, ACTOR_THREADING_BEGIN, -1,
						[&] (Counter &stk) -> int {
							if (romLocation) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)address);
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)romLocation->bank);
							} else {
								_type = OperationTypes::THREAD;

								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
							}

							writeChildren(bytes, context, Range(0), stk, onError);

							return 3;
						},
						nullptr,
						onError
					);
				}

				break;
			case ResourceManipulations::JOIN:
				writeRoutine(
					bytes, context,
					Asm::Types::THREAD_ACTOR, ACTOR_THREADING_JOIN, -1,
					[&] (Counter &stk) -> int {
						writeChildren(bytes, context, Range(0), stk, onError);

						return 1;
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::KILL:
				writeRoutine(
					bytes, context,
					Asm::Types::THREAD_ACTOR, ACTOR_THREADING_TERMINATE, -1,
					[&] (Counter &stk) -> int {
						writeChildren(bytes, context, Range(0), stk, onError);

						return 1;
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::WAIT:
				writeRoutine(
					bytes, context,
					Asm::Types::THREAD_ACTOR, ACTOR_THREADING_WAIT, -1,
					[&] (Counter &stk) -> int {
						writeChildren(bytes, context, Range(0), stk, onError);

						return 1;
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::ON: {
					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Check the children.
					int page = -1;
					Destination dest(0);
					if (_children.size() < 2) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (_children.size() == 2) {
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 1, false);
						if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Determine the actor options.
					const int actorHandlerOptions = ACTOR_HANDLER_HITS;

					// Emit the argument from the child.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit a `VM_ON_ACTOR` instruction.
					_type = OperationTypes::ON;
					SourceLocation target;
					if (dest.isLeft())
						target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
					else
						target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
					const RomLocation* romLocation = ctx.find(target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_ACTOR]); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)actorHandlerOptions);
					if (romLocation) {
						args = fill(args, (UInt16)address);
						args = fill(args, (UInt8)romLocation->bank);
					} else {
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
					}
				}

				break;
			case ResourceManipulations::OFF: {
					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Determine the scene options.
					const int actorHandlerOptions = ACTOR_HANDLER_HITS;

					// Emit the argument from the child.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit a `VM_ON_ACTOR` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_ACTOR]); DEC_COUNTER(stk, 2);
					args = fill(args, (UInt8)actorHandlerOptions);
					args = fill(args, (UInt16)0);
					args = fill(args, (UInt8)0);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::FILL: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::ACTOR, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 3) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[0];
				const int bank = loc.bank;
				const int address = loc.address;
				const int size = locations.front().size;
				const int offset = scheduled.target.sub * 8 * 2;
				if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)(address + offset));
			}

			break;
		case OperationTypes::DEF: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::ACTOR, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 3) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[2];
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		case OperationTypes::SET_ACTOR_PROP: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::ACTOR, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 3) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[1];
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		case OperationTypes::THREAD: {
				GBBASIC_ASSERT(_scheduled.size() == 2 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				for (int i = 0; i < (int)_scheduled.size(); ++i) {
					scheduled = _scheduled[i];
					const RomLocation* romLocation = ctx.find(scheduled.target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					if (romLocation) {
						Byte* args = scheduled.args(bytes->pointer());
						if (i == 0)
							args = fill(args, (UInt16)address);
						else
							args = fill(args, (UInt16)romLocation->bank);
					} else {
						THROW_INVALID_PROGRAM_POINT(onError);
					}
				}
			}

			break;
		case OperationTypes::ON: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				const RomLocation* romLocation = ctx.find(scheduled.target);
				const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
				if (romLocation) {
					Byte* args = scheduled.args(bytes->pointer());
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					THROW_INVALID_PROGRAM_POINT(onError);
				}
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("ACTOR");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ACTOR");
	}
	using Node::dump;
};

class NodeEmoteManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		ACTOR
	};

private:
	Scheduled _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeEmoteManipulation() {
	}
	virtual ~NodeEmoteManipulation() override {
	}

	NODE_TYPE(Types::EMOTE_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled = Scheduled();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			int argn = 0;
			bool read = false;
			bool data = false;
			int arge = 0;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "emote")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "with")) {
				if (!consume(Token::Types::KEYWORD, "actor")) { THROW_INVALID_SYNTAX(onError); }
				_type = OperationTypes::ACTOR;
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
			else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
			else if (isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }

			// Determine the manipulation.
			UInt8 src = ASSET_SOURCE_FAR;
			if (read) src = ASSET_SOURCE_READ;
			else if (data) src = ASSET_SOURCE_DATA;
			Generator_Int_Counter argf = nullptr;
			Generator_Void_Counter argi = nullptr;
			switch (_type) {
			case OperationTypes::NONE: { // `EMOTE(x, y, base_tile = 0, mirrored = false[, pal]) = ...`.
					if (argn < 2) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (argn >= 2 && argn <= 5) {
						// Do nothing.
					} else if (argn > 5) {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}
					if (argn == 2) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)NULL); // Actor.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)FALSE); // Mirrored.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Base tile.
							writeChildren(bytes, context, Range(1, 0), stk, onError); // X, y.

							return 6;
						};
					} else if (argn == 3) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)NULL); // Actor.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)FALSE); // Mirrored.
							writeChildren(bytes, context, Range(2, 0), stk, onError); // X, y, base tile.

							return 6;
						};
					} else if (argn == 4) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)NULL); // Actor.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, base tile, mirrored.

							return 6;
						};
					} else if (argn == 5) {
						usingColoredFeature(ctx, onError); // Check for feature compatibility.

						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)NULL); // Actor.
							writeChildren(bytes, context, Range(4, 0), stk, onError); // X, y, base tile, mirrored, palette.

							return 6;
						};
					}
				}

				break;
			case OperationTypes::ACTOR: { // `EMOTE(dx = 0, dy = 0, base_tile = 0, mirrored = false[, pal]) WITH ACTOR(id) = ...`.
					if (argn < 1) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (argn >= 1 && argn <= 6) {
						// Do nothing.
					} else if (argn > 6) {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}
					if (argn == 1) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(0), stk, onError); // Actor.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)TRUE); // Mirrored.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Base tile.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Dy.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Dx.

							return 6;
						};
					} else if (argn == 2) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1), stk, onError); // Actor.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)TRUE); // Mirrored.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Base tile.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Dy.
							writeChildren(bytes, context, Range(0), stk, onError); // Dx.

							return 6;
						};
					} else if (argn == 3) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(2), stk, onError); // Actor.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)TRUE); // Mirrored.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Base tile.
							writeChildren(bytes, context, Range(1, 0), stk, onError); // Dx, dy.

							return 6;
						};
					} else if (argn == 4) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(3), stk, onError); // Actor.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)TRUE); // Mirrored.
							writeChildren(bytes, context, Range(2, 0), stk, onError); // Dx, dy, base tile.

							return 6;
						};
					} else if (argn == 5) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(4), stk, onError); // Actor.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0); // Palette.
							writeChildren(bytes, context, Range(3, 0), stk, onError); // Dx, dy, base tile, mirrored.

							return 6;
						};
					} else if (argn == 6) {
						usingColoredFeature(ctx, onError); // Check for feature compatibility.

						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(5, 0), stk, onError); // X, y, base tile, mirrored, actor, palette.

							return 6;
						};
					}
				}

				break;
			default:
				GBBASIC_ASSERT(false && "Impossible.");

				break;
			}

			if (read) {
				writeRoutine(bytes, context, Asm::Types::EMOTE, ASSET_SOURCE_READ, -1, argf, nullptr, onError);
			} else if (data) {
				if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
				Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
				constexpr const int N = 64;
				const int n = (int)Token::sizeOfIntegers(seq);
				if (n < N) { THROW_TOO_FEW_ARGUMENTS(onError); }
				else if (n > N) { THROW_TOO_MANY_ARGUMENTS(onError); }
				argi = [&, seq] (Counter &) -> void {
					for (const Token::Ptr &tk : seq)
						writeInteger(bytes, context, tk);
				};
				writeRoutine(bytes, context, Asm::Types::EMOTE, ASSET_SOURCE_DATA, -1, argf, argi, onError);
			} else if (byName_) {
				if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
				const RomLocation* romLocation = ctx.symbols->find(name);
				const TilesAssets &tiles = ctx.assets->tiles;
				int pageIndex = -1;
				const TilesAssets::Entry* tilesEntry = tiles.find(name, &pageIndex); // By asset name.
				if (romLocation) {
					const int bank = romLocation->bank;
					const int address = romLocation->address;
					argi = [&, bank, address] (Counter &) -> void {
						emit(bytes, context, (UInt8)bank);
						emit(bytes, context, (UInt16)address);
					};
					writeRoutine(bytes, context, Asm::Types::EMOTE, ASSET_SOURCE_FAR, -1, argf, argi, onError);
				} else if (tilesEntry) {
					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, pageIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					argi = [&] (Counter &) -> void {
						const int offset = (int)bytes->peek();
						SourceLocation target(pageIndex);
						_scheduled = Scheduled(target, bytes->pointer(), bytes->pointer() + offset, false);
						emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
						emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
					};
					writeRoutine(bytes, context, Asm::Types::EMOTE, ASSET_SOURCE_FAR, -1, argf, argi, onError);
				} else {
					std::string fuzzyName;
					if (tiles.fuzzy(name, nullptr, fuzzyName)) {
						THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
					}

					THROW_INVALID_ASSET_POINT(onError);
				}
			} else /* From asset. */ {
				argi = [&] (Counter &) -> void {
					int page = -1;
					Destination dest(0);
					Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
					if (tks.size() == 1) { /* Do nothing. */ }
					else if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

					SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
					const int offset = (int)bytes->peek();
					emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
					emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
					_scheduled = Scheduled(target, offset, false);
				};
				writeRoutine(bytes, context, Asm::Types::EMOTE, ASSET_SOURCE_FAR, -1, argf, argi, onError);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (!_scheduled.pending())
			return;

		if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
		Pipeline::Resource::Array locations;
		if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, _scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
		if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
		const int bank = locations.front().bank;
		const int address = locations.front().address;
		const int size = locations.front().size;
		const int offset = _scheduled.target.sub * 8 * 2;
		if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

		Byte* args = _scheduled.args(bytes->pointer());
		args = fill(args, (UInt8)bank);
		args = fill(args, (UInt16)(address + offset));
	}

	virtual Abstract abstract(void) const override {
		return abstract("EMOTE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "EMOTE");
	}
	using Node::dump;
};

class NodeProjectileManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		FILL,
		DEF,
		SET_PROJECTILE_PROP
	};

private:
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeProjectileManipulation() {
	}
	virtual ~NodeProjectileManipulation() override {
	}

	NODE_TYPE(Types::PROJECTILE_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			bool property = false;
			int argn = 0;
			bool read = false;
			bool data = false;
			int arge = 0;
			int motion = 0;
			bool byName_ = false;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "fill")
					action = ResourceManipulations::FILL;
				else if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "get")
					action = ResourceManipulations::GET;
				else if (id == "set")
					action = ResourceManipulations::SET;
				else if (id == "start")
					action = ResourceManipulations::START;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "projectile" && !consume(Token::Types::KEYWORD, "projectile")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "property")) {
				if (!(action == ResourceManipulations::DEF || action == ResourceManipulations::GET || action == ResourceManipulations::SET)) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				property = true;
			} else if (consume(Token::Types::KEYWORD, "len")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::LEN;
			} else if (consume(Token::Types::KEYWORD, "width")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_WIDTH;
			} else if (consume(Token::Types::KEYWORD, "height")) {
				if (action != ResourceManipulations::GET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
				action = ResourceManipulations::GET_HEIGHT;
			} else {
				if (action == ResourceManipulations::GET || action == ResourceManipulations::SET) {
					THROW_INVALID_OPERATION(onError, idtk);
				}
			}
			if (action == ResourceManipulations::FILL) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
				else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
				else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::DEF) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				if (property) {
					if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
					else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
					else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
					else if ((_children.size() - argn == 2) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; arge = 1; }
					if (consume(Token::Types::OPERATOR, "(")) {
						if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
					}
				} else {
					if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
					else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
					else if ((_children.size() - argn == 3) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
					if (consume(Token::Types::OPERATOR, "(")) {
						if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
					}
				}
			} else if (action == ResourceManipulations::START) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				arge = (int)_children.size() - argn;
				if (consume(Token::Types::KEYWORD, "with")) {
					if (!consume(Token::Types::KEYWORD, "actor")) { THROW_INVALID_SYNTAX(onError); }
					motion |= PROJECTILE_START_WITH_ACTOR;
					if (consume(Token::Types::OPERATOR, "(")) {
						if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
					}
				} else if (arge == 0) {
					motion |= PROJECTILE_START_INDEPENDENTLY;
				} else {
					THROW_INVALID_SYNTAX(onError);
				}
			} else {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (expectAssign(action)) {
					if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
				else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
				else if ((_children.size() - argn == 1) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; }
				else if ((_children.size() - argn == 2) && isString(context, (int)_children.size() - 1, &name, nullptr)) { byName_ = true; arge = 1; }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::FILL:
				if (byName_) {
					const ActorAssets &actors = ctx.assets->actors;
					const int index = actors.indexOf(name);
					if (index >= 0)
						byName_ = false;
				}
				if (read) {
					writeRoutine(bytes, context, Asm::Types::FILL_TILE, ASSET_SOURCE_READ, GRAPHICS_LAYER_SPRITE, 2, nullptr, nullptr, onError);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					constexpr const int M = 16;
					const int n = (int)Token::sizeOfIntegers(seq);
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }
					const Token::Ptr tk = _children[1]->onlyToken();
					if (tk && tk->is(Token::Types::INTEGER)) {
						if ((int)tk->data() * M != n) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_DATA, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
					const int bank = romLocation->bank;
					const int address = romLocation->address;
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							emit(bytes, context, (UInt8)bank);
							emit(bytes, context, (UInt16)address);
						},
						onError
					);
				} else /* From asset. */ {
					writeRoutine(
						bytes, context,
						Asm::Types::FILL_TILE, ASSET_SOURCE_FAR, GRAPHICS_LAYER_SPRITE, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const ActorAssets &actors = ctx.assets->actors;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								actors.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, 2);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (actors.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							const ActorAssets::Entry* entry = actors.get(page);
							if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
							if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
							_type = OperationTypes::FILL;
						},
						onError
					);
				}

				break;
			case ResourceManipulations::DEF:
				if (property) {
					if (read) {
						writeRoutine(
							bytes, context,
							Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_READ, 2,
							[&] (Counter &stk) -> int {
								if (arge)
									writeChildren(bytes, context, Range(1 + arge, 1 + 1), stk, onError);
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2 + arge;
							},
							nullptr,
							onError
						);
					} else if (data) {
						if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
						Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
						Token::Ptr tk = nullptr;
						int val = 0;
						int m = -1;
						if (isUInt8(context, 1, val, &tk)) {
							switch (val) {
							// These magic numbers are associated with the data layout defined by GBDK's metasprite structure.
							case PROPERTY_FRAMES:       m = 2;       break;
							case PROPERTY_ANIMATIONS:   m = 6 - 2;   break;
							case PROPERTY_ANIMATION:    m = 6 - 2;   break;
							}
						}
						const int n = (int)Token::sizeOfIntegers(seq);
						if (m > 0 && n < m) { THROW_TOO_FEW_ARGUMENTS(onError); }
						writeRoutine(
							bytes, context,
							Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_DATA, 2,
							[&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2;
							},
							[&] (Counter &) -> void {
								for (const Token::Ptr &tk : seq)
									writeInteger(bytes, context, tk);
							},
							onError
						);
					} else if (byName_) {
						Token::Ptr tk = nullptr;
						int data = 0;
						const bool forFrame = isUInt8(context, 1, data, &tk) && data == PROPERTY_FRAMES;
						if (forFrame) {
							if (_children.size() != 4) {
								THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
							}
						}
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						writeRoutine(
							bytes, context,
							Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_FAR, 2,
							[&] (Counter &stk) -> int {
								if (arge)
									writeChildren(bytes, context, Range(1 + arge, 1 + 1), stk, onError);
								writeChildren(bytes, context, Range(1, 0), stk, onError);

								return 2 + arge;
							},
							[&] (Counter &) -> void {
								emit(bytes, context, (UInt8)bank);
								emit(bytes, context, (UInt16)address);
							},
							onError
						);
					} else /* From asset. */ {
						Token::Ptr tk = nullptr;
						int data = 0;
						const bool forFrame = isUInt8(context, 1, data, &tk) && data == PROPERTY_FRAMES;
						if (forFrame) {
							if (_children.size() != 4) {
								THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
							}
						}
						if (forFrame) {
							Generator_Int_Counter argf = [&] (Counter &stk) -> int {
								writeChildren(bytes, context, Range(2, 0), stk, onError);

								return 3;
							};
							Generator_Void_Counter argi = [&] (Counter &) -> void {
								int page = -1;
								Destination dest(0);
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else { THROW_INVALID_ASSET_POINT(onError); }

								const ActorAssets &actors = ctx.assets->actors;
								const ActorAssets::Entry* entry = actors.get(page);
								if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
								if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

								if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
								if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

								SourceLocation target(page); // `#pg`. By page number.
								const int offset = (int)bytes->peek();
								emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
								emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
								_scheduled.push_back(Scheduled(target, offset, false));
								_type = OperationTypes::SET_PROJECTILE_PROP;
							};
							writeRoutine(bytes, context, Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_FAR, 3, argf, argi, onError);
						} else {
							writeRoutine(bytes, context, Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_STACK, -1, nullptr, nullptr, onError);
						}
					}
				} else {
					UInt8 src = ASSET_SOURCE_FAR;
					if (read) src = ASSET_SOURCE_READ;
					else if (data) src = ASSET_SOURCE_DATA;
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					if (argn == 1) {
						argf = [&] (Counter &stk) -> int {
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)0);
							writeChildren(bytes, context, Range(0), stk, onError);

							return 2;
						};
					} else if (argn == 2) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						};
					}
					if (data) {
						argi = [&] (Counter &) -> void {
							if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
							Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						};
					} else if (byName_) {
						if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
						const RomLocation* romLocation = ctx.symbols->find(name);
						if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
						const int bank = romLocation->bank;
						const int address = romLocation->address;
						argi = [&, bank, address] (Counter &) -> void {
							emit(bytes, context, (UInt8)bank);
							emit(bytes, context, (UInt16)address);
						};
					}
					if (read || data || byName_) {
						writeRoutine(bytes, context, Asm::Types::DEF_PROJECTILE, src, 3, argf, argi, onError);
					} else /* From asset. */ {
						argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const ActorAssets &actors = ctx.assets->actors;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								actors.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (actors.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							const ActorAssets::Entry* entry = actors.get(page);
							if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
							if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
							_type = OperationTypes::DEF;
						};
						writeRoutine(bytes, context, Asm::Types::DEF_PROJECTILE, src, 3, argf, argi, onError);
					}
				}

				break;
			case ResourceManipulations::GET:
				writeFunction(bytes, context, Asm::Types::GET_PROJECTILE_PROP, ASSET_SOURCE_IGNORED, 2, nullptr, nullptr, onError);

				break;
			case ResourceManipulations::SET:
				if (read) {
					writeRoutine(
						bytes, context,
						Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_READ, 2,
						[&] (Counter &stk) -> int {
							if (arge)
								writeChildren(bytes, context, Range(1 + arge, 1 + 1), stk, onError);
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2 + arge;
						},
						nullptr,
						onError
					);
				} else if (data) {
					if (2 >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
					Token::Array seq = flatOnlyTokens(Range(2, (int)_children.size() - 1));
					Token::Ptr tk = nullptr;
					int val = 0;
					int m = -1;
					if (isUInt8(context, 1, val, &tk)) {
						switch (val) {
						// These magic numbers are associated with the data layout defined by GBDK's metasprite structure.
						case PROPERTY_FRAMES:       m = 2;       break;
						case PROPERTY_ANIMATIONS:   m = 6 - 2;   break;
						case PROPERTY_ANIMATION:    m = 6 - 2;   break;
						}
					}
					const int n = (int)Token::sizeOfIntegers(seq);
					if (m > 0 && n < m) { THROW_TOO_FEW_ARGUMENTS(onError); }
					writeRoutine(
						bytes, context,
						Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_DATA, 2,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2;
						},
						[&] (Counter &) -> void {
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						},
						onError
					);
				} else if (byName_) {
					Token::Ptr tk = nullptr;
					int data = 0;
					const bool forFrame = isUInt8(context, 1, data, &tk) && data == PROPERTY_FRAMES;
					if (forFrame) {
						if (_children.size() != 4) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					}
					if (!ctx.symbols) { THROW_INVALID_ASSET_POINT(onError); }
					const RomLocation* romLocation = ctx.symbols->find(name);
					if (!romLocation) { THROW_INVALID_ASSET_POINT(onError); }
					const int bank = romLocation->bank;
					const int address = romLocation->address;
					writeRoutine(
						bytes, context,
						Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_FAR, 2,
						[&] (Counter &stk) -> int {
							if (arge)
								writeChildren(bytes, context, Range(1 + arge, 1 + 1), stk, onError);
							writeChildren(bytes, context, Range(1, 0), stk, onError);

							return 2 + arge;
						},
						[&] (Counter &) -> void {
							emit(bytes, context, (UInt8)bank);
							emit(bytes, context, (UInt16)address);
						},
						onError
					);
				} else /* From asset. */ {
					Token::Ptr tk = nullptr;
					int data = 0;
					const bool forFrame = isUInt8(context, 1, data, &tk) && data == PROPERTY_FRAMES;
					if (forFrame) {
						if (_children.size() != 4) {
							THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
						}
					} else {
						if (_children.size() < 3) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 3 || _children.size() == 4 || _children.size() == 6) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}
					}
					if (forFrame) {
						Generator_Int_Counter argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(2, 0), stk, onError);

							return 3;
						};
						Generator_Void_Counter argi = [&] (Counter &) -> void {
							int page = -1;
							Destination dest(0);
							const ActorAssets &actors = ctx.assets->actors;
							page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
								actors.indexOf(name) : // By asset name.
								-1;
							if (page == -1) {
								Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
								if (tks.size() == 1) { /* Do nothing. */ }
								else {
									std::string fuzzyName;
									if (actors.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							const ActorAssets::Entry* entry = actors.get(page);
							if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
							if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page); // `#pg`. By page number.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
							_type = OperationTypes::SET_PROJECTILE_PROP;
						};
						writeRoutine(bytes, context, Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_FAR, 3, argf, argi, onError);
					} else {
						writeRoutine(bytes, context, Asm::Types::SET_PROJECTILE_PROP, ASSET_SOURCE_STACK, -1, nullptr, nullptr, onError);
					}
				}

				break;
			case ResourceManipulations::LEN: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const ActorAssets &actors = ctx.assets->actors;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						actors.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (actors.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int actorIndex = page;
					const ActorAssets::Entry* entry = actors.get(actorIndex);
					if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
					if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, actorIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int ret = entry->data->count();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_WIDTH: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const ActorAssets &actors = ctx.assets->actors;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						actors.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (actors.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int actorIndex = page;
					const ActorAssets::Entry* entry = actors.get(actorIndex);
					if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
					if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, actorIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int actorFrame = dest.left().get();
					const Actor::Ptr &actorPtr = entry->data;
					const Actor::Frame* actorFrame_ = actorPtr->get(actorFrame);
					if (!actorFrame_) { THROW_INVALID_ASSET_POINT(onError); }
					const int ret = actorFrame_->width();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::GET_HEIGHT: {
					// Get data from asset.
					int page = -1;
					Destination dest(0);
					const ActorAssets &actors = ctx.assets->actors;
					page = isString(context, (int)_children.size() - 1, &name, nullptr) ?
						actors.indexOf(name) : // By asset name.
						-1;
					if (page == -1) {
						Token::Array tks = flatNumericDestinationTokens(context, page, &dest, (int)_children.size() - 1);
						if (tks.empty()) {
							std::string fuzzyName;
							if (actors.fuzzy(name, nullptr, fuzzyName)) {
								THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
							}

							THROW_INVALID_ASSET_POINT(onError);
						}
						if (!dest.isLeft()) { THROW_INVALID_ASSET_POINT(onError); }
					}

					const int actorIndex = page;
					const ActorAssets::Entry* entry = actors.get(actorIndex);
					if (!entry) { THROW_INVALID_ASSET_POINT(onError); }
					if (entry->asActor) { THROW_ASSET_IS_DEFINED_AS_AN_ACTOR_BUT_USED_AS_A_PROJECTILE(onError); }

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::PROJECTILE, actorIndex, true)) { THROW_INVALID_ASSET_POINT(onError); }

					const int actorFrame = dest.left().get();
					const Actor::Ptr &actorPtr = entry->data;
					const Actor::Frame* actorFrame_ = actorPtr->get(actorFrame);
					if (!actorFrame_) { THROW_INVALID_ASSET_POINT(onError); }
					const int ret = actorFrame_->height();

					// Set the stack footprint guard.
					COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit a `VM_SET_CONST` instruction to set the data.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SET_CONST]);
							args = fill(args, (Int16)ret);
							args = fill(args, (Int16)ARG0);
						}, 0, true,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::START: {
					Generator_Int_Counter argf = nullptr;
					if (motion == PROJECTILE_START_INDEPENDENTLY) {
						if (_children.size() < 3) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 3) {
							// Do nothing.
						} else if (_children.size() == 4) {
							// Do nothing.
						} else if (_children.size() == 5) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						argf = [&] (Counter &stk) -> int {
							if (_children.size() == 3) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Flags.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Angle.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // Type, x, y.

								return 5;
							} else if (_children.size() == 4) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Flags.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // Type, x, y, angle.

								return 5;
							} else /* if (_children.size() == 5) */ {
								writeChildren(bytes, context, Range(4, 0), stk, onError); // Type, x, y, angle, flags.

								return 5;
							}
						};
					} else /* if (motion == PROJECTILE_START_WITH_ACTOR) */ {
						if (_children.size() < 2) {
							THROW_TOO_FEW_ARGUMENTS(onError);
						} else if (_children.size() == 2) {
							// Do nothing.
						} else if (_children.size() == 3) {
							// Do nothing.
						} else if (_children.size() == 4) {
							// Do nothing.
						} else if (_children.size() == 5) {
							// Do nothing.
						} else if (_children.size() == 6) {
							// Do nothing.
						} else {
							THROW_TOO_MANY_ARGUMENTS(onError);
						}

						argf = [&] (Counter &stk) -> int {
							if (_children.size() == 2) {
								writeChildren(bytes, context, Range(1), stk, onError); // Actor.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Flags.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Angle.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Dy.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Dx.
								writeChildren(bytes, context, Range(0), stk, onError); // Type.

								return 6;
							} else if (_children.size() == 3) {
								writeChildren(bytes, context, Range(2), stk, onError); // Actor.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Flags.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Angle.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Dy.
								writeChildren(bytes, context, Range(1, 0), stk, onError); // Type, dx.

								return 6;
							} else if (_children.size() == 4) {
								writeChildren(bytes, context, Range(3), stk, onError); // Actor.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Flags.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Angle.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // Type, dx, dy.

								return 6;
							} else if (_children.size() == 5) {
								writeChildren(bytes, context, Range(4), stk, onError); // Actor.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Flags.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // Type, dx, dy, angle.

								return 6;
							} else /* if (_children.size() == 6) */ {
								writeChildren(bytes, context, Range(5, 0), stk, onError); // Type, dx, dy, angle, flags, actor.

								return 6;
							}
						};
					}

					writeFunction(bytes, context, Asm::Types::START_PROJECTILE, motion, -1, argf, nullptr, onError);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::FILL: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::PROJECTILE, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 3) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[0];
				const int bank = loc.bank;
				const int address = loc.address;
				const int size = locations.front().size;
				const int offset = scheduled.target.sub * 8 * 2;
				if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)(address + offset));
			}

			break;
		case OperationTypes::DEF: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::PROJECTILE, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 3) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[2];
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		case OperationTypes::SET_PROJECTILE_PROP: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
				Pipeline::Resource::Array locations;
				if (!ctx.pipeline->lookup(AssetsBundle::Categories::PROJECTILE, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
				if (locations.size() != 3) { THROW_INVALID_ASSET_POINT(onError); }
				const Pipeline::Resource &loc = locations[1];
				const int bank = loc.bank;
				const int address = loc.address;

				Byte* args = scheduled.args(bytes->pointer());
				args = fill(args, (UInt8)bank);
				args = fill(args, (UInt16)address);
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("PROJECTILE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PROJECTILE");
	}
	using Node::dump;
};

class NodeTriggerManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		ON
	};

private:
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;

public:
	NodeTriggerManipulation() {
	}
	virtual ~NodeTriggerManipulation() override {
	}

	NODE_TYPE(Types::TRIGGER_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = OperationTypes::NONE;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool read = false;
			bool data = false;
			int arge = 0;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "dim")
					action = ResourceManipulations::DIM;
				else if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "on")
					action = ResourceManipulations::ON;
				else if (id == "off")
					action = ResourceManipulations::OFF;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (/* id != "trigger" && */ !consume(Token::Types::KEYWORD, "trigger")) { THROW_INVALID_SYNTAX(onError); }
			if (action == ResourceManipulations::DIM) {
				if (!consume(Token::Types::OPERATOR, "[")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "]")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
			} else if (action == ResourceManipulations::DEF) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::KEYWORD, "read")) { read = true; arge = (int)_children.size() - argn; }
				else if (consume(Token::Types::KEYWORD, "data")) { data = true; arge = (int)_children.size() - argn; }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::ON) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::KEYWORD, "start")) { /* Do nothing. */ }
				else { THROW_INVALID_OPERATION(onError, idtk); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::OFF) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::DIM: {
					// Check the children.
					if (_children.empty()) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (_children.size() == 1) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Emit the right hand value.
					const bool withDeclaring = ctx.declaration.declaring != -1;
					writeRightHand(
						bytes, context, stk,
						[&] (void) -> void {
							// Emit the option value.
							writeChildren(bytes, context, Range(0), stk, onError);

							// Emit the option type.
							Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
							args = fill(args, (UInt16)DEVICE_OPTION_ACTIVE_TRIGGERS);

							// Emit a `VM_OPTION` instruction.
							args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
						}, withDeclaring ? 0 : 1, false,
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::DEF: {
					UInt8 src = ASSET_SOURCE_STACK;
					if (read) src = ASSET_SOURCE_READ;
					else if (data) src = ASSET_SOURCE_DATA;
					Generator_Int_Counter argf = nullptr;
					Generator_Void_Counter argi = nullptr;
					if (argn == 1) {
						// Do nothing.
					} else {
						THROW_INVALID_SYNTAX(onError);
					}
					if (data) {
						argi = [&] (Counter &) -> void {
							if (argn >= (int)_children.size() - 1) { THROW_TOO_FEW_ARGUMENTS(onError); }
							Token::Array seq = flatOnlyTokens(Range(argn, (int)_children.size() - 1));
							const int n = (int)Token::sizeOfIntegers(seq);
							if (n < 4) { THROW_TOO_FEW_ARGUMENTS(onError); }
							else if (n > 4) { THROW_TOO_MANY_ARGUMENTS(onError); }
							for (const Token::Ptr &tk : seq)
								writeInteger(bytes, context, tk);
						};
					}
					if (read || data) {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(0), stk, onError);

							return 1;
						};
						writeRoutine(bytes, context, Asm::Types::DEF_TRIGGER, src, -1, argf, argi, onError);
					} else {
						argf = [&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(4, 0), stk, onError);

							return 5;
						};
						writeRoutine(bytes, context, Asm::Types::DEF_TRIGGER, src, 5, argf, argi, onError);
					}
				}

				break;
			case ResourceManipulations::ON: {
					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Check the children.
					int page = -1;
					Destination dest(0);
					if (_children.size() < 3) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (_children.size() == 3) {
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 2, false);
						if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Emit the arguments.
					writeChildren(bytes, context, Range(1, 0), stk, onError); INC_COUNTER(stk, 2 * 2);

					// Emit a `VM_ON_TRIGGER` instruction.
					_type = OperationTypes::ON;
					SourceLocation target;
					if (dest.isLeft())
						target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
					else
						target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
					const RomLocation* romLocation = ctx.find(target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_TRIGGER]); DEC_COUNTER(stk, 2 * 2);
					if (romLocation) {
						args = fill(args, (UInt16)address);
						args = fill(args, (UInt8)romLocation->bank);
					} else {
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
					}
				}

				break;
			case ResourceManipulations::OFF: {
					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Emit the arguments.
					writeChildren(bytes, context, Range(1, 0), stk, onError); INC_COUNTER(stk, 2 * 2);

					// Emit a `VM_ON_TRIGGER` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_TRIGGER]); DEC_COUNTER(stk, 2 * 2);
					args = fill(args, (UInt16)0);
					args = fill(args, (UInt8)0);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::ON: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				const RomLocation* romLocation = ctx.find(scheduled.target);
				const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
				if (romLocation) {
					Byte* args = scheduled.args(bytes->pointer());
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					THROW_INVALID_PROGRAM_POINT(onError);
				}
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("TRIGGER");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "TRIGGER");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** GUI manipulations
*/

class NodeWidgetManipulation : public Node {
public:
	NodeWidgetManipulation() {
	}
	virtual ~NodeWidgetManipulation() override {
	}

	NODE_TYPE(Types::WIDGET_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "def")
					action = ResourceManipulations::DEF;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "widget" && !consume(Token::Types::KEYWORD, "widget")) { THROW_INVALID_SYNTAX(onError); }
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::DEF: {
					if (argn == 0) {
						Token::Ptr simpleTk = onlyTokenInOnlyChild();
						if (!(simpleTk && simpleTk->is(Token::Types::IDENTIFIER) && simpleTk->text() == "nothing")) { THROW_INVALID_SYNTAX(onError); }
					} else {
						THROW_INVALID_SYNTAX(onError);
					}
					writeRoutine(bytes, context, Asm::Types::DEF_SCENE, GUI_WIDGET_TYPE_NONE, 0, nullptr, nullptr, onError);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("WIDGET");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "WIDGET");
	}
	using Node::dump;
};

class NodeLabelManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		DEF,
		PUT
	};

private:
	int _font = -1;
	Font::Codepoints _codepoints;
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;
	intptr_t _offset0 = 0;
	intptr_t _offset1 = 0;

public:
	NodeLabelManipulation() {
	}
	virtual ~NodeLabelManipulation() override {
	}

	NODE_TYPE(Types::LABEL_MANIPULATION)

	virtual void options(const IDictionary::Ptr &options) override {
		if ((bool)options->get("put"))
			_type = OperationTypes::PUT;
		else
			_type = OperationTypes::DEF;
	}

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const int offset = _type == OperationTypes::PUT ? 1 : 0;

		if (_type == OperationTypes::PUT)
			replenishFormatted<NodeExpression>(context, offset);

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_font = -1;
			_codepoints.clear();
			_scheduled.clear();
			_offset0 = 0;
			_offset1 = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			bool newLine = true;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "label")
					action = ResourceManipulations::PUT;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "label" && !consume(Token::Types::KEYWORD, "label")) { THROW_INVALID_SYNTAX(onError); }
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::OPERATOR, ";")) { newLine = false; }

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::DEF:
				if (argn != 4 && argn != 5) {
					THROW_INVALID_SYNTAX(onError);
				}
				if (_children.size() <= 4) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() >= 5 && _children.size() <= 10) {
					// Do nothing.
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				writeRoutine( // `DEF LABEL(x, y, w, h, base_tile = 0) = layer, margin_x = 0, margin_y = 0, blit_interval = 10, x_offset = 0`.
					bytes, context,
					Asm::Types::DEF_WIDGET, GUI_WIDGET_TYPE_LABEL, -1,
					[&] (Counter &stk) -> int {
						if (argn == 4) {
							if (_children.size() == 5) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GUI_BLIT_INTERVAL); // Interval.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin x.
								writeChildren(bytes, context, Range(4), stk, onError); // Layer.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							} else if (_children.size() == 6) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GUI_BLIT_INTERVAL); // Interval.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								writeChildren(bytes, context, Range(5, 4), stk, onError); // Layer, margin x.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							} else if (_children.size() == 7) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GUI_BLIT_INTERVAL); // Interval.
								writeChildren(bytes, context, Range(6, 4), stk, onError); // Layer, margin x, margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							} else if (_children.size() == 8) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								writeChildren(bytes, context, Range(7, 4), stk, onError); // Layer, margin x, margin y, interval.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							} else /* if (_children.size() == 9) */ {
								writeChildren(bytes, context, Range(8, 4), stk, onError); // Layer, margin x, margin y, interval, x offset.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							}

							return 10;
						} else /* if (argn == 5) */ {
							if (_children.size() == 6) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GUI_BLIT_INTERVAL); // Interval.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin x.
								writeChildren(bytes, context, Range(5, 0), stk, onError); // X, y, width, height, base tile, layer.
							} else if (_children.size() == 7) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GUI_BLIT_INTERVAL); // Interval.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								writeChildren(bytes, context, Range(6, 0), stk, onError); // X, y, width, height, base tile, layer, margin x.
							} else if (_children.size() == 8) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GUI_BLIT_INTERVAL); // Interval.
								writeChildren(bytes, context, Range(7, 0), stk, onError); // X, y, width, height, base tile, layer, margin x, margin y.
							} else if (_children.size() == 9) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // X offset.
								writeChildren(bytes, context, Range(8, 0), stk, onError); // X, y, width, height, base tile, layer, margin x, margin y, interval.
							} else /* if (_children.size() == 10) */ {
								writeChildren(bytes, context, Range(9, 0), stk, onError); // X, y, width, height, base tile, layer, margin x, margin y, interval, x offset.
							}

							return 10;
						}
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::PUT: {
					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Collect the glyphs.
					Font::Codepoints codepoints;
					do {
						// Prepare.
						FontAssets &fonts = ctx.assets->fonts;
						Token::Ptr tk = nullptr;
						std::string str;
						if (fonts.empty()) {
							THROW_INVALID_ASSET_POINT(onError);
						}

						int page = -1;
						Destination dest(0);
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true);
						if (tks.size() == 1) { /* Do nothing. */ }
						else { THROW_INVALID_ASSET_POINT(onError); }

						if (dest.isLeft()) {
							_font = page;
						} else {
							const std::string name = dest.right().get();
							const FontAssets &fonts = ctx.assets->fonts;
							int pageIndex = -1;
							const FontAssets::Entry* fontEntry = fonts.find(name, &pageIndex); // By asset name.
							if (fontEntry) {
								page = pageIndex;
							} else {
								std::string fuzzyName;
								if (fonts.fuzzy(name, nullptr, fuzzyName)) {
									THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
								}

								THROW_INVALID_ASSET_POINT(onError);
							}
							_font = page;
						}
						if (_font < 0 || _font >= fonts.count()) {
							THROW_ASSET_PAGE_OUT_OF_BOUNDS(onError);
						}
						if (!isString(context, offset, &str, &tk)) {
							CHECK_FOR_STRING(onError, tk);
						}

						FontAssets::Entry* font = fonts.get(_font);
						if (!font) { THROW_INVALID_ASSET_POINT(onError); }

						// Parse the string.
						Font::Codepoints toBake;
						bool invalid = false;
						const bool hasEsc = analyzeString(str, codepoints, toBake, &invalid);
						if (invalid) { THROW_INVALID_EXPRESSION(onError, tk); }

						// Touch it only if there's escape.
						if (hasEsc) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::FONT, page, true)) { THROW_INVALID_ASSET_POINT(onError); }
						}

						// Collect the glyphs.
						for (Font::Codepoint cp : toBake) {
							GlyphTable::Entry* existing = font->glyphs.find(cp);
							if (existing) {
								++existing->refCount;

								continue;
							}

							const GlyphTable::Entry glyph(cp, 1);
							font->glyphs.add(glyph);
						}
						font->glyphs.sort();
					} while (false);

					// FEAT: TEXT FORMAT.
					// Writing layout:
					//   argument evaluations
					//   the `VM_LABEL` instruction
					//     the baked font address (C function argument)
					//     the baked font bank (C function argument)
					//     the argument count (C function argument)
					//     the new line mode (C function argument)
					//   the arguments from front to back
					//   the format text in glyphs, with termination point
					// Emit a `VM_LABEL` instruction.
					writeFormatted( // `LABEL #pg, ...` or
						            // `LABEL #pg, fmt[, ...]`.
						bytes, context,
						stk,
						Asm::Types::LABEL, offset,
						[&] (Byte* &args) -> void {
							const int size = Math::max((int)_children.size() - offset, 0);
							_offset0 = prefill<UInt16>(bytes, args);
							_offset1 = prefill<UInt8>(bytes, args);
							args = fill(args, (UInt8)(size - 1));
							args = fill(args, (UInt8)BOOLEAN(newLine));
						},
						[&] (void) -> void {
							int i = 0;
							while (i < codepoints.count()) {
								const Font::Codepoint cp = codepoints[i];
								if (cp == GLYPH_ESCAPE_PLACEHOLDER) {
									if (++i >= codepoints.count())
										continue;

									const Font::Codepoint cp_ = codepoints[i];
									switch (cp_) {
									case GLYPH_ESCAPE_INT: // Fall through.
									case GLYPH_ESCAPE_HEX: // Fall through.
									case GLYPH_ESCAPE_CHAR: {
											++i;
											const glyph_t g0((UInt16)cp);
											emit<glyph_t>(bytes, context, g0); // Emit an escape '%'.
											const glyph_t g1((UInt16)cp_);
											emit<glyph_t>(bytes, context, g1); // Emit an escape pattern character.
										}

										continue;
									case GLYPH_ESCAPE_PERCENT:
										++i;
										// Dealed as a regular character below.

										break;
									}
								} else if (cp == GLYPH_ESCAPE_SPECIAL) {
									if (++i >= codepoints.count())
										continue;

									const Font::Codepoint cp_ = codepoints[i];
									switch (cp_) {
									case GLYPH_ESCAPE_UNICODE: // Fall through.
									case GLYPH_ESCAPE_STACK: // Fall through.
									case GLYPH_ESCAPE_BACKSLASH:
										++i;
										// Dealed as a regular character below.

										break;
									}
								} else if (cp == GLYPH_ESCAPE_RETURN) {
									++i;
									_codepoints.add(cp);
									_scheduled.push_back(Scheduled((int)bytes->peek()));
									const glyph_t g_((UInt16)cp);
									emit<glyph_t>(bytes, context, g_); // Emit an escape '\r'.

									continue;
								} else if (cp == GLYPH_ESCAPE_NEW_LINE) {
									++i;
									_codepoints.add(cp);
									_scheduled.push_back(Scheduled((int)bytes->peek()));
									const glyph_t g_((UInt16)cp);
									emit<glyph_t>(bytes, context, g_); // Emit an escape '\n'.

									continue;
								} else if (cp == GLYPH_ESCAPE_NEW_PAGE) {
									++i;
									_codepoints.add(cp);
									_scheduled.push_back(Scheduled((int)bytes->peek()));
									const glyph_t g_((UInt16)cp);
									emit<glyph_t>(bytes, context, g_); // Emit an escape '\f'.

									continue;
								} else if (cp == ' ') {
									++i;
									_codepoints.add(cp);
									_scheduled.push_back(Scheduled((int)bytes->peek()));
									const glyph_t g;
									emit<glyph_t>(bytes, context, g); // Emit a space character.

									continue;
								} else {
									++i;
								}

								_codepoints.add(cp);
								_scheduled.push_back(Scheduled((int)bytes->peek()));
								const glyph_t g;
								emit<glyph_t>(bytes, context, g); // Emit a regular character.
							}
							_codepoints.add(GLYPH_TERMINATION);
							_scheduled.push_back(Scheduled((int)bytes->peek()));
							const glyph_t g;
							emit<glyph_t>(bytes, context, g); // Emit the termination character.
						},
						onError
					);

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		switch (_type) {
		case OperationTypes::DEF:
			// Do nothing.

			break;
		case OperationTypes::PUT: {
				// Prepare.
				const FontAssets &fonts = ctx.assets->fonts;
				if (fonts.empty())
					return;
				if (_font < 0 || _font >= fonts.count())
					return;

				// Fill the address of the font.
				const FontAssets::Entry* font = fonts.get(_font);
				if (!font) { THROW_INVALID_ASSET_POINT(onError); }
				fill(bytes, _offset0, (UInt16)font->address); // Fill the bank and address.
				fill(bytes, _offset1, (UInt8)font->bank);

				// Throw warning for unknown glyph(s).
				Text::Array unknownGlyphs;

				const GlyphTable &glyphs = font->glyphs;
				for (const GlyphTable::Entry &glyph : glyphs.entries) {
					if (!glyph.unknown) // Is a known glyph.
						continue;

					if (glyph.refCount == 0) // Only count referenced glyphs, this will omit unknown arbitrary glyphs.
						continue;

					if (isEscape(glyph.codepoint)) // Only count non-escape glyphs.
						continue;

					const Font::Codepoint cp = glyph.codepoint;
					std::wstring wstr;
					wstr.push_back((wchar_t)cp);
					const std::string str = Unicode::fromWide(wstr);

					unknownGlyphs.push_back(str);
				}

				if (!unknownGlyphs.empty()) {
					THROW_UNKNOWN_GLYPHS_IN_FONT_ASSET(onError, unknownGlyphs);
				}

				// Fill the content.
				auto backtrack = [] (int* growing, glyph_t* spcGlyph) -> void {
					if (spcGlyph)
						spcGlyph->advance = (UInt16)(*growing);
					*growing = 0;
				};

				int growing = 0;
				glyph_t* spcGlyph = nullptr;
				int i = 0;
				while (i < (int)_scheduled.size()) {
					const Font::Codepoint cp = _codepoints[i];
					Scheduled &scheduled = _scheduled[i];
					if (!scheduled.pending())
						continue;

					if (cp == GLYPH_ESCAPE_RETURN) {
						++i;
						backtrack(&growing, spcGlyph);

						continue;
					} else if (cp == GLYPH_ESCAPE_NEW_LINE) {
						++i;
						backtrack(&growing, spcGlyph);

						continue;
					} else if (cp == GLYPH_ESCAPE_NEW_PAGE) {
						++i;
						backtrack(&growing, spcGlyph);

						continue;
					} else if (cp == ' ') {
						++i;
						const GlyphTable::Entry* entry = font->glyphs.find(cp);
						GBBASIC_ASSERT(entry && "Impossible.");
						Byte* args = scheduled.args(bytes->pointer());
						glyph_t* g = (glyph_t*)args;
						*g = glyph_t((UInt8)GLYPH_SPACE, (UInt16)0, (UInt8)entry->size() /* in pixels */); // Fill the space glyph.
						backtrack(&growing, spcGlyph);
						spcGlyph = g;

						continue;
					} else if (cp == GLYPH_TERMINATION) {
						GBBASIC_ASSERT(i == (int)_scheduled.size() - 1 && "Impossible.");

						if (spcGlyph) {
							backtrack(&growing, spcGlyph);
							spcGlyph = nullptr;
						}

						break;
					}

					++i;
					const GlyphTable::Entry* entry = font->glyphs.find(cp);
					GBBASIC_ASSERT(entry && "Impossible.");
					Byte* args = scheduled.args(bytes->pointer());
					glyph_t* g = (glyph_t*)args;
					*g = glyph_t((UInt8)entry->bank, (UInt16)entry->address, (UInt8)entry->size() /* in pixels */); // Fill the glyph.
					if (font->preferFullWordForNonAscii) {
						GBBASIC_ASSERT(font->preferFullWord && "Impossible.");
						growing += entry->width;
					} else if (font->preferFullWord) {
						if (cp <= 255)
							growing += entry->width;
					}
				}
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("LABEL");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "LABEL");
	}
	using Node::dump;
};

class NodeProgressBarManipulation : public Node {
public:
	NodeProgressBarManipulation() {
	}
	virtual ~NodeProgressBarManipulation() override {
	}

	NODE_TYPE(Types::PROGRESSBAR_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "progressbar")
					action = ResourceManipulations::PUT;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "progressbar" && !consume(Token::Types::KEYWORD, "progressbar")) { THROW_INVALID_SYNTAX(onError); }
			if (expectBrackets(action)) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			if (expectAssign(action)) {
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::DEF:
				if (argn != 3 && argn != 4) {
					THROW_INVALID_SYNTAX(onError);
				}
				if (_children.size() <= 3) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() >= 4 && _children.size() <= 9) {
					// Do nothing.
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				writeRoutine( // `DEF PROGRESSBAR(x, y, w, base_tile = 0) = layer, margin_x = 0, margin_y = 0, palette_b = BLACK, palette_c = GRAY`.
					bytes, context,
					Asm::Types::DEF_WIDGET, GUI_WIDGET_TYPE_PROGRESSBAR, -1,
					[&] (Counter &stk) -> int {
						if (argn == 3) {
							if (_children.size() == 4) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin x.
								writeChildren(bytes, context, Range(3), stk, onError); // Layer.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // X, y, width.
							} else if (_children.size() == 5) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								writeChildren(bytes, context, Range(4, 3), stk, onError); // Layer, margin x.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // X, y, width.
							} else if (_children.size() == 6) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								writeChildren(bytes, context, Range(5, 3), stk, onError); // Layer, margin x, margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // X, y, width.
							} else if (_children.size() == 7) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								writeChildren(bytes, context, Range(6, 3), stk, onError); // Layer, margin x, margin y, palette b.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // X, y, width.
							} else /* if (_children.size() == 8) */ {
								writeChildren(bytes, context, Range(7, 3), stk, onError); // Layer, margin x, margin y, palette b, palette c.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(2, 0), stk, onError); // X, y, width.
							}

							return 9;
						} else /* if (argn == 4) */ {
							if (_children.size() == 5) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin x.
								writeChildren(bytes, context, Range(4, 0), stk, onError); // X, y, width, base tile, layer.
							} else if (_children.size() == 6) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								writeChildren(bytes, context, Range(5, 0), stk, onError); // X, y, width, base tile, layer, margin x.
							} else if (_children.size() == 7) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								writeChildren(bytes, context, Range(6, 0), stk, onError); // X, y, width, base tile, layer, margin x, margin y.
							} else if (_children.size() == 8) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								writeChildren(bytes, context, Range(7, 0), stk, onError); // X, y, width, base tile, layer, margin x, margin y, palette b.
							} else /* if (_children.size() == 9) */ {
								writeChildren(bytes, context, Range(8, 0), stk, onError); // X, y, width, base tile, layer, margin x, margin y, palette b, palette c.
							}

							return 9;
						}
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::PUT:
				if (_children.empty()) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() == 1 || _children.size() == 8 || _children.size() == 9 || _children.size() == 10) {
					// Do nothing.
				} else if (_children.size() >= 11) {
					THROW_TOO_MANY_ARGUMENTS(onError);
				} else {
					THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError);
				}

				if (_children.size() == 1) {
					writeRoutine( // `PROGRESSBAR val`.
						bytes, context,
						Asm::Types::PROGRESSBAR, 1, -1,
						[&] (Counter &stk) -> int {
							writeChildren(bytes, context, Range(0), stk, onError);

							return 1;
						},
						nullptr,
						onError
					);
				} else {
					writeRoutine( // `PROGRESSBAR val, x, y, width, base tile, layer, margin x, margin y, palette_b = BLACK, palette_c = GRAY`.
						bytes, context,
						Asm::Types::PROGRESSBAR, 10, -1,
						[&] (Counter &stk) -> int {
							if (_children.size() == 8) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_BLACK); // Palette b.
								writeChildren(bytes, context, Range(7, 0), stk, onError); // Val, x, y, width, base tile, layer, margin x, margin y.
							} else if (_children.size() == 9) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)GRAPHICS_PALETTE_GRAY); // Palette c.
								writeChildren(bytes, context, Range(8, 0), stk, onError); // Val, x, y, width, base tile, layer, margin x, margin y, palette b.
							} else /* if (_children.size() == 10) */ {
								writeChildren(bytes, context, Range(9, 0), stk, onError); // Val, x, y, width, base tile, layer, margin x, margin y, palette b, palette c.
							}

							return 10;
						},
						nullptr,
						onError
					);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("PROGRESSBAR");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "PROGRESSBAR");
	}
	using Node::dump;
};

class NodeMenuManipulation : public Node {
private:
	enum class OperationTypes {
		NONE,
		PUT,
		ON
	};

private:
	int _font = -1;
	Font::Codepoints _codepoints;
	Scheduled::Array _scheduled;
	OperationTypes _type = OperationTypes::NONE;
	intptr_t _offset0 = 0;
	intptr_t _offset1 = 0;

public:
	NodeMenuManipulation() {
	}
	virtual ~NodeMenuManipulation() override {
	}

	NODE_TYPE(Types::MENU_MANIPULATION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_font = -1;
			_codepoints.clear();
			_scheduled.clear();
			_type = OperationTypes::NONE;
			_offset0 = 0;
			_offset1 = 0;

			// Consume the tokens.
			Token::Ptr idtk = nullptr;
			std::string id;
			ResourceManipulations action = ResourceManipulations::NONE;
			int argn = 0;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume([&] (Token::Ptr tk) -> void {
				idtk = tk;
				id = (std::string)tk->data();
				if (id == "def")
					action = ResourceManipulations::DEF;
				else if (id == "menu")
					action = ResourceManipulations::PUT;
				else if (id == "on")
					action = ResourceManipulations::ON;
				else if (id == "off")
					action = ResourceManipulations::OFF;
			})) { THROW_INVALID_OPERATION(onError, idtk); }
			if (id != "menu" && !consume(Token::Types::KEYWORD, "menu")) { THROW_INVALID_SYNTAX(onError); }
			if (action == ResourceManipulations::DEF) {
				if (!consume(Token::Types::OPERATOR, "(")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (!consume(Token::Types::OPERATOR, "=")) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::PUT) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::ON) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
				if (consume(Token::Types::KEYWORD, "start")) { /* Do nothing. */ }
				else { THROW_INVALID_OPERATION(onError, idtk); }
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
			} else if (action == ResourceManipulations::OFF) {
				if (consume(Token::Types::OPERATOR, "(")) {
					if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					argn = (int)tk->data();
				})) { THROW_INVALID_SYNTAX(onError); }
			}

			// Determine the manipulation.
			switch (action) {
			case ResourceManipulations::DEF:
				if (argn != 4 && argn != 5) {
					THROW_INVALID_SYNTAX(onError);
				}
				if (_children.size() <= 4) {
					THROW_TOO_FEW_ARGUMENTS(onError);
				} else if (_children.size() >= 5 && _children.size() <= 8) {
					// Do nothing.
				} else {
					THROW_TOO_MANY_ARGUMENTS(onError);
				}

				writeRoutine( // `DEF MENU(x, y, w, h, base_tile = 0) = layer, margin_x = 0, margin_y = 0`.
					bytes, context,
					Asm::Types::DEF_WIDGET, GUI_WIDGET_TYPE_MENU, -1,
					[&] (Counter &stk) -> int {
						if (argn == 4) {
							if (_children.size() == 5) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin x.
								writeChildren(bytes, context, Range(4), stk, onError); // Layer.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							} else if (_children.size() == 6) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								writeChildren(bytes, context, Range(5, 4), stk, onError); // Layer, margin x.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							} else /* if (_children.size() == 7) */ {
								writeChildren(bytes, context, Range(6, 4), stk, onError); // Layer, margin x, margin y.
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Base tile.
								writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
							}

							return 8;
						} else /* if (argn == 5) */ {
							if (_children.size() == 6) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin x.
								writeChildren(bytes, context, Range(5, 0), stk, onError); // X, y, width, height, base tile, layer.
							} else if (_children.size() == 7) {
								Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
								args = fill(args, (UInt16)0); // Margin y.
								writeChildren(bytes, context, Range(6, 0), stk, onError); // X, y, width, height, base tile, layer, margin x.
							} else /* if (_children.size() == 8) */ {
								writeChildren(bytes, context, Range(7, 0), stk, onError); // X, y, width, height, base tile, layer, margin x, margin y.
							}

							return 8;
						}
					},
					nullptr,
					onError
				);

				break;
			case ResourceManipulations::PUT:
				if (_children.size() == 1) {
					// Prepare.
					Token::Ptr simpleTk = onlyTokenInOnlyChild();
					if (!(simpleTk && simpleTk->is(Token::Types::IDENTIFIER) && simpleTk->text() == "nothing")) { THROW_INVALID_SYNTAX(onError); }

					// Emit a `VM_MENU` instruction.
					writeRoutine( // `MENU NOTHING`.
						bytes, context,
						Asm::Types::MENU,
						[&] (Byte* &args) -> void {
							args = fill(args, (UInt16)NULL);
							args = fill(args, (UInt8)0);
							args = fill(args, (UInt8)0);
							args = fill(args, (UInt8)0);
						},
						1,
						[] (Counter &) -> int {
							// Do nothing.

							return 0;
						},
						[] (Counter &) -> void {
							// Do nothing.
						},
						onError
					);
				} else {
					// Prepare.
					typedef std::vector<Font::Codepoints> CodepointsArray;

					// Set the stack footprint guard.
					VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
					COUNTER_GUARD(ctx, stk);

					// Set the expression slot guard.
					VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

					// Collect the glyphs.
					Text::Array lines;
					CodepointsArray codepointsArray;
					do {
						// Prepare.
						FontAssets &fonts = ctx.assets->fonts;
						Token::Ptr tk = nullptr;
						std::string str;
						if (fonts.empty()) {
							THROW_INVALID_ASSET_POINT(onError);
						}

						int page = -1;
						Destination dest(0);
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, true);
						if (tks.size() == 1) { /* Do nothing. */ }
						else { THROW_INVALID_ASSET_POINT(onError); }

						if (dest.isLeft()) {
							_font = page;
						} else {
							const std::string name = dest.right().get();
							const FontAssets &fonts = ctx.assets->fonts;
							int pageIndex = -1;
							const FontAssets::Entry* fontEntry = fonts.find(name, &pageIndex); // By asset name.
							if (fontEntry) {
								page = pageIndex;
							} else {
								std::string fuzzyName;
								if (fonts.fuzzy(name, nullptr, fuzzyName)) {
									THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
								}

								THROW_INVALID_ASSET_POINT(onError);
							}
							_font = page;
						}
						if (_font < 0 || _font >= fonts.count()) {
							THROW_ASSET_PAGE_OUT_OF_BOUNDS(onError);
						}
						if (!isString(context, 1, &str, &tk)) {
							CHECK_FOR_STRING(onError, tk);
						}
						for (int i = 1; i < (int)_children.size(); ++i) {
							std::string str;
							if (!isString(context, i, &str, nullptr))
								break;

							lines.push_back(str);
						}

						FontAssets::Entry* font = fonts.get(_font);
						if (!font) { THROW_INVALID_ASSET_POINT(onError); }

						// Parse the string.
						Font::Codepoints toBake; // Reused.
						bool hasEsc = false;
						for (int i = 0; i < (int)lines.size(); ++i) {
							const std::string &str_ = lines[i];

							if (
								Text::indexOf(str_, std::string({ GLYPH_ESCAPE_RETURN })) != std::string::npos ||
								Text::indexOf(str_, std::string({ GLYPH_ESCAPE_NEW_LINE })) != std::string::npos ||
								Text::indexOf(str_, std::string({ GLYPH_ESCAPE_NEW_PAGE })) != std::string::npos
							) {
								THROW_INVALID_GLYPH(onError);
							}

							Font::Codepoints codepoints;
							bool invalid = false;
							hasEsc |= analyzeString(str_, codepoints, toBake, &invalid);
							if (invalid) { THROW_INVALID_EXPRESSION(onError, tk); }
							codepointsArray.push_back(codepoints);
						}

						// Touch it only if there's escape.
						if (hasEsc) {
							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::FONT, page, true)) { THROW_INVALID_ASSET_POINT(onError); }
						}

						// Collect the glyphs.
						for (Font::Codepoint cp : toBake) {
							GlyphTable::Entry* existing = font->glyphs.find(cp);
							if (existing) {
								++existing->refCount;

								continue;
							}

							const GlyphTable::Entry glyph(cp, 1);
							font->glyphs.add(glyph);
						}
						font->glyphs.sort();
					} while (false);

					// FEAT: TEXT FORMAT.
					// Writing layout:
					//   argument evaluations
					//   the `VM_MENU` instruction
					//     the baked font address (C function argument)
					//     the baked font bank (C function argument)
					//     the argument count (C function argument)
					//     the line count (C function argument)
					//   the arguments from front to back
					//   the format text in glyphs, with termination point
					//     that supports multi-line
					// Emit a `VM_MENU` instruction.
					constexpr const int offset = 1;
					writeFormatted( // `MENU #pg, fmt0[, fmt1, ..., fmtN][, ...]`.
						bytes, context,
						stk,
						Asm::Types::MENU, Range(offset, (int)lines.size()),
						[&] (Byte* &args) -> void {
							const int size = Math::max((int)_children.size() - (int)lines.size(), 0);
							_offset0 = prefill<UInt16>(bytes, args);
							_offset1 = prefill<UInt8>(bytes, args);
							args = fill(args, (UInt8)(size - 1));
							args = fill(args, (UInt8)lines.size());
						},
						[&] (void) -> void {
							for (int j = 0; j < (int)codepointsArray.size(); ++j) {
								const Font::Codepoints &codepoints = codepointsArray[j];

								int i = 0;
								while (i < codepoints.count()) {
									const Font::Codepoint cp = codepoints[i];
									if (cp == GLYPH_ESCAPE_PLACEHOLDER) {
										if (++i >= codepoints.count())
											continue;

										const Font::Codepoint cp_ = codepoints[i];
										switch (cp_) {
										case GLYPH_ESCAPE_INT: // Fall through.
										case GLYPH_ESCAPE_HEX: // Fall through.
										case GLYPH_ESCAPE_CHAR: {
												++i;
												const glyph_t g0((UInt16)cp);
												emit<glyph_t>(bytes, context, g0); // Emit an escape '%'.
												const glyph_t g1((UInt16)cp_);
												emit<glyph_t>(bytes, context, g1); // Emit an escape pattern character.
											}

											continue;
										case GLYPH_ESCAPE_PERCENT:
											++i;
											// Dealed as a regular character below.

											break;
										}
									} else if (cp == GLYPH_ESCAPE_SPECIAL) {
										if (++i >= codepoints.count())
											continue;

										const Font::Codepoint cp_ = codepoints[i];
										switch (cp_) {
										case GLYPH_ESCAPE_UNICODE: // Fall through.
										case GLYPH_ESCAPE_STACK: // Fall through.
										case GLYPH_ESCAPE_BACKSLASH:
											++i;
											// Dealed as a regular character below.

											break;
										}
									} else if (cp == GLYPH_ESCAPE_RETURN) {
										GBBASIC_ASSERT(false && "Impossible."); // Do not support an escape '\r'.
									} else if (cp == GLYPH_ESCAPE_NEW_LINE) {
										GBBASIC_ASSERT(false && "Impossible."); // Do not support an escape '\n'.
									} else if (cp == GLYPH_ESCAPE_NEW_PAGE) {
										GBBASIC_ASSERT(false && "Impossible."); // Do not support an escape '\f'.
									} else if (cp == ' ') {
										++i;
										_codepoints.add(cp);
										_scheduled.push_back(Scheduled((int)bytes->peek()));
										const glyph_t g;
										emit<glyph_t>(bytes, context, g); // Emit a space character.

										continue;
									} else {
										++i;
									}

									_codepoints.add(cp);
									_scheduled.push_back(Scheduled((int)bytes->peek()));
									const glyph_t g;
									emit<glyph_t>(bytes, context, g); // Emit a regular character.
								}
								_codepoints.add(GLYPH_TERMINATION);
								_scheduled.push_back(Scheduled((int)bytes->peek()));
								const glyph_t g;
								emit<glyph_t>(bytes, context, g); // Emit the termination character.
							}
						},
						onError
					);

					_type = OperationTypes::PUT;

					// Check the stack footprint.
					CHECK_COUNTER(ctx, onError);
				}

				break;
			case ResourceManipulations::ON: {
					// Check the children.
					int page = -1;
					Destination dest(0);
					if (_children.size() < 1) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (_children.size() == 1) {
						Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 0, false);
						if (tks.empty()) { THROW_INVALID_DESTINATION(onError); }
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Emit a `VM_ON_WIDGET` instruction.
					_type = OperationTypes::ON;
					SourceLocation target;
					if (dest.isLeft())
						target = SourceLocation(PAGE(page, state.inCode.page), dest.left().get()); // `#pg:lno`. By line number.
					else
						target = SourceLocation(PAGE(page, state.inCode.page), dest.right().get()); // `#pg:lbl`. By label.
					const RomLocation* romLocation = ctx.find(target);
					const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_WIDGET]);
					if (romLocation) {
						args = fill(args, (UInt16)address);
						args = fill(args, (UInt8)romLocation->bank);
					} else {
						_scheduled.push_back(Scheduled(target, bytes->pointer(), args, false));
					}
				}

				break;
			case ResourceManipulations::OFF: {
					// Check the children.
					if (_children.empty()) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}

					// Emit a `VM_ON_WIDGET` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::ON_WIDGET]);
					args = fill(args, (UInt16)0);
					args = fill(args, (UInt8)0);
				}

				break;
			default:
				THROW_INVALID_OPERATION(onError, idtk);
			}
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case OperationTypes::PUT: {
				// Prepare.
				const FontAssets &fonts = ctx.assets->fonts;
				if (fonts.empty())
					return;
				if (_font < 0 || _font >= fonts.count())
					return;

				// Fill the address of the font.
				const FontAssets::Entry* font = fonts.get(_font);
				if (!font) { THROW_INVALID_ASSET_POINT(onError); }
				fill(bytes, _offset0, (UInt16)font->address); // Fill the bank and address.
				fill(bytes, _offset1, (UInt8)font->bank);

				// Throw warning for unknown glyph(s).
				Text::Array unknownGlyphs;

				const GlyphTable &glyphs = font->glyphs;
				for (const GlyphTable::Entry &glyph : glyphs.entries) {
					if (!glyph.unknown) // Is a known glyph.
						continue;

					if (glyph.refCount == 0) // Only count referenced glyphs, this will omit unknown arbitrary glyphs.
						continue;

					if (isEscape(glyph.codepoint)) // Only count non-escape glyphs.
						continue;

					const Font::Codepoint cp = glyph.codepoint;
					std::wstring wstr;
					wstr.push_back((wchar_t)cp);
					const std::string str = Unicode::fromWide(wstr);

					unknownGlyphs.push_back(str);
				}

				if (!unknownGlyphs.empty()) {
					THROW_UNKNOWN_GLYPHS_IN_FONT_ASSET(onError, unknownGlyphs);
				}

				// Fill the content.
				auto backtrack = [] (int* growing, glyph_t* spcGlyph) -> void {
					if (spcGlyph)
						spcGlyph->advance = (UInt16)(*growing);
					*growing = 0;
				};

				int growing = 0;
				glyph_t* spcGlyph = nullptr;
				int i = 0;
				while (i < (int)_scheduled.size()) {
					const Font::Codepoint cp = _codepoints[i];
					Scheduled &scheduled = _scheduled[i];
					if (!scheduled.pending())
						continue;

					if (cp == ' ') {
						++i;
						const GlyphTable::Entry* entry = font->glyphs.find(cp);
						GBBASIC_ASSERT(entry && "Impossible.");
						Byte* args = scheduled.args(bytes->pointer());
						glyph_t* g = (glyph_t*)args;
						*g = glyph_t((UInt8)GLYPH_SPACE, (UInt16)0, (UInt8)entry->size() /* in pixels */); // Fill the space glyph.
						backtrack(&growing, spcGlyph);
						spcGlyph = g;

						continue;
					} else if (cp == GLYPH_TERMINATION) {
						++i;

						continue;
					}

					++i;
					const GlyphTable::Entry* entry = font->glyphs.find(cp);
					GBBASIC_ASSERT(entry && "Impossible.");
					Byte* args = scheduled.args(bytes->pointer());
					glyph_t* g = (glyph_t*)args;
					*g = glyph_t((UInt8)entry->bank, (UInt16)entry->address, (UInt8)entry->size() /* in pixels */); // Fill the glyph.
					if (font->preferFullWordForNonAscii) {
						GBBASIC_ASSERT(font->preferFullWord && "Impossible.");
						growing += entry->width;
					} else if (font->preferFullWord) {
						if (cp <= 255)
							growing += entry->width;
					}
				}
			}

			break;
		case OperationTypes::ON: {
				GBBASIC_ASSERT(_scheduled.size() == 1 && "Impossible.");

				Scheduled scheduled = _scheduled.front();
				if (!scheduled.pending())
					return;

				const RomLocation* romLocation = ctx.find(scheduled.target);
				const int address = romLocation ? ctx.startAddress + romLocation->address : 0;
				if (romLocation) {
					Byte* args = scheduled.args(bytes->pointer());
					args = fill(args, (UInt16)address);
					args = fill(args, (UInt8)romLocation->bank);
				} else {
					THROW_INVALID_PROGRAM_POINT(onError);
				}
			}

			break;
		default:
			GBBASIC_ASSERT(false && "Impossible.");

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("MENU");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "MENU");
	}
	using Node::dump;
};

class NodeScroll : public Node {
public:
	NodeScroll() {
	}
	virtual ~NodeScroll() override {
	}

	NODE_TYPE(Types::SCROLL)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			int argn = 0;
			int arge = 0;
			std::string name;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "scroll")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
				argn = (int)tk->data();
			})) { THROW_INVALID_SYNTAX(onError); }
			arge = (int)_children.size() - argn;
			if (!consume(Token::Types::KEYWORD, "with")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.size() < 5) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 5 || _children.size() == 6 || _children.size() == 7 || _children.size() == 8) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Scroll a rectangle.
			writeRoutine( // `SCROLL(x, y, w, h, layer = WINDOW_LAYER) with t[, attr[, dir]]`.
				bytes, context,
				Asm::Types::SCROLL, ASSET_SOURCE_IGNORED, -1,
				[&] (Counter &stk) -> int {
					if (arge == 1) {
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Direction.
						args = fill(args, (UInt16)DIRECTION_UP);
						args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Attributes.
						args = fill(args, (UInt16)0);
						writeChildren(bytes, context, Range((int)_children.size() - 1), stk, onError); // Tile.
					} else if (arge == 2) {
						usingColoredFeature(ctx, onError); // Check for feature compatibility.

						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Direction.
						args = fill(args, (UInt16)DIRECTION_UP);
						writeChildren(bytes, context, Range((int)_children.size() - 1, (int)_children.size() - 2), stk, onError); // Tile, attributes.
					} else if (arge == 3) {
						usingColoredFeature(ctx, onError); // Check for feature compatibility.

						writeChildren(bytes, context, Range((int)_children.size() - 1, (int)_children.size() - 3), stk, onError); // Tile, attributes, direction.
					}
					if (argn == 4) {
						Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2); // Layer.
						args = fill(args, (UInt16)GRAPHICS_LAYER_WINDOW);
						writeChildren(bytes, context, Range(3, 0), stk, onError); // X, y, width, height.
					} else if (argn == 5) {
						writeChildren(bytes, context, Range(4, 0), stk, onError); // X, y, width, height, layer.
					}

					return 8;
				},
				nullptr,
				onError
			);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SCROLL");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SCROLL");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Effects
*/

class NodeFx : public Node {
private:
	Scheduled::Array _scheduled;
	int _type = 0;

public:
	NodeFx() {
	}
	virtual ~NodeFx() override {
	}

	NODE_TYPE(Types::FX)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Reset the states.
			_scheduled.clear();
			_type = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "fx")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1 || _children.size() == 2) {
				// Do nothing.
			} else if (_children.size() <= 255) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit a `VM_FX` instruction.
			Token::Ptr tk = nullptr;
			int val = 0;
			if (!isUInt8(context, 0, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
			switch (val) {
			case EFFECTS_PULSE:
				if (_children.size() == 1) {
					// Emit `0` for no pulse.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)0);

					// Emit the effect type.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit the `VM_FX` instruction.
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FX]); DEC_COUNTER(stk, 2 * (int)(_children.size() + 1));
				} else {
					// Check the arguments.
					constexpr const int M = 4;
					const int n = (int)_children.size() - 2;
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }

					_type = EFFECTS_PULSE;

					// Emit the interval.
					writeChildren(bytes, context, Range(1), stk, onError);

					// Emit the effect type.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit the `VM_FX` instruction.
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FX]); DEC_COUNTER(stk, 2 * 2);

					// Emit the argument count.
					emit(bytes, context, (UInt8)(n / M));

					// Emit the arguments.
					const int N = n / M;
					for (int i = 0; i < N; ++i) {
						// Write the base tile index.
						{
							Token::Ptr tk0 = nullptr;
							int val0 = 0;
							if (!isUInt8(context, 2 + i * M + 0, val0, &tk0)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk0); }
							emit(bytes, context, (UInt8)val0);
						}

						// Write the tile count.
						{
							Token::Ptr tk1 = nullptr;
							int val1 = 0;
							if (!isUInt8(context, 2 + i * M + 1, val1, &tk1)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk1); }
							emit(bytes, context, (UInt8)val1);
						}

						// Write the tile address of the first state.
						{
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 2 + i * M + 2, true);
							if (tks.empty()) { THROW_INVALID_ASSET_POINT(onError); }
							if (page == -1 && dest.isRight()) {
								const std::string name = dest.right().get();
								int pageIndex = -1;
								const MapAssets &maps = ctx.assets->maps;
								const MapAssets::Entry* mapEntry = maps.find(name, &pageIndex); // By asset name.
								if (mapEntry) {
									page = pageIndex;
									dest = Left<int>(page);
								} else {
									std::string fuzzyName;
									if (maps.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, tks.size() == 1 ? 0 : dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
						}

						// Write the tile address of the second state.
						{
							int page = -1;
							Destination dest(0);
							Token::Array tks = flatNumericOrLabeledDestinationTokens(context, page, &dest, 2 + i * M + 3, true);
							if (tks.empty()) { THROW_INVALID_ASSET_POINT(onError); }
							if (page == -1 && dest.isRight()) {
								const std::string name = dest.right().get();
								int pageIndex = -1;
								const MapAssets &maps = ctx.assets->maps;
								const MapAssets::Entry* mapEntry = maps.find(name, &pageIndex); // By asset name.
								if (mapEntry) {
									page = pageIndex;
									dest = Left<int>(page);
								} else {
									std::string fuzzyName;
									if (maps.fuzzy(name, nullptr, fuzzyName)) {
										THROW_INVALID_ASSET_POINT_DID_YOU_MEAN(onError, fuzzyName);
									}

									THROW_INVALID_ASSET_POINT(onError);
								}
							}

							if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
							if (!ctx.pipeline->touch(ctx.assets, AssetsBundle::Categories::TILES, page, true)) { THROW_INVALID_ASSET_POINT(onError); }

							SourceLocation target(page, tks.size() == 1 ? 0 : dest.left().get()); // `#pg:n`. By page number and index.
							const int offset = (int)bytes->peek();
							emit(bytes, context, (UInt8)COMPILER_PLACEHOLDER);
							emit(bytes, context, (UInt16)COMPILER_PLACEHOLDER);
							_scheduled.push_back(Scheduled(target, offset, false));
						}
					}
				}

				break;
			case EFFECTS_PARALLAX:
				if (_children.size() == 1) {
					// Emit `0` for non-parallax.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)0);

					// Emit the effect type.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit the `VM_FX` instruction.
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FX]); DEC_COUNTER(stk, 2 * (int)(_children.size() + 1));
				} else {
					// Check the arguments.
					constexpr const int M = 3;
					const int n = (int)_children.size() - 1;
					if (n < M || n % M != 0) { THROW_ARGUMENT_COUNT_DOES_NOT_MATCH(onError); }

					// Emit the arguments.
					writeChildren(bytes, context, Range((int)_children.size() - 1, 1), stk, onError);

					// Emit the argument count.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)(n / M));

					// Emit the effect type.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit the `VM_FX` instruction.
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FX]); DEC_COUNTER(stk, 2 * (int)(_children.size() + 1));
				}

				break;
			case EFFECTS_WOBBLE:
				if (_children.size() == 1) {
					// Emit `FALSE` to disable wobble effect.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)FALSE);

					// Emit the effect type.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit the `VM_FX` instruction.
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FX]); DEC_COUNTER(stk, 2 * (int)(_children.size() + 1));
				} else if (_children.size() == 2) {
					// Check for feature compatibility.
					usingColoredFeature(ctx, onError);

					// Emit the effect switch/argument count, and effect type.
					writeChildren(bytes, context, Range((int)_children.size() - 1, 0), stk, onError);

					// Emit the `VM_FX` instruction.
					emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::FX]); DEC_COUNTER(stk, 2 * (int)_children.size());
				} else {
					THROW_INVALID_SYNTAX(onError);
				}

				break;
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}
	virtual void post(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		Context &ctx = context.top();

		if (_scheduled.empty())
			return;

		switch (_type) {
		case EFFECTS_PULSE: {
				for (int i = 0; i < (int)_scheduled.size(); ++i) {
					Scheduled &scheduled = _scheduled[i];
					if (!scheduled.pending())
						continue;

					if (!ctx.pipeline) { THROW_INVALID_ASSET_POINT(onError); }
					Pipeline::Resource::Array locations;
					if (!ctx.pipeline->lookup(AssetsBundle::Categories::TILES, scheduled.target.page, locations)) { THROW_INVALID_ASSET_POINT(onError); }
					if (locations.size() != 1) { THROW_INVALID_ASSET_POINT(onError); }
					const int bank = locations.front().bank;
					const int address = locations.front().address;
					const int size = locations.front().size;
					const int offset = scheduled.target.sub * 8 * 2;
					if (offset >= size) { THROW_INVALID_ASSET_POINT(onError); }

					Byte* args = scheduled.args(bytes->pointer());
					args = fill(args, (UInt8)bank);
					args = fill(args, (UInt16)(address + offset));
				}
			}

			break;
		}
	}

	virtual Abstract abstract(void) const override {
		return abstract("FX");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "FX");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Physics functions
*/

class NodeHits : public Node {
public:
	NodeHits() {
	}
	virtual ~NodeHits() override {
	}

	NODE_TYPE(Types::HITS)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		enum class ShapeTypes {
			NONE,
			BOX,
			POINT
		};

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::OPERATOR, "hits")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			ShapeTypes type0 = ShapeTypes::NONE;
			ShapeTypes type1 = ShapeTypes::NONE;
			Ptr group0 = nullptr;
			Ptr group1 = nullptr;
			int shapes = 0;
			if (_children.size() <= 1) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 2) {
				// Check the first group.
				group0 = _children.front();
				if (group0->consume(Token::Types::KEYWORD, "rect")) { type0 = ShapeTypes::BOX; }
				else if (group0->consume(Token::Types::KEYWORD, "point")) { type0 = ShapeTypes::POINT; }
				else { THROW_INVALID_SYNTAX(onError); }
				if (group0->consume(Token::Types::OPERATOR, "(")) {
					if (!group0->consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (type0 == ShapeTypes::BOX) {
					if (group0->allChildren().size() <= 3) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (group0->allChildren().size() == 4) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}
				} else if (type0 == ShapeTypes::POINT) {
					if (group0->allChildren().size() <= 1) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (group0->allChildren().size() == 2) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}
				}
				// Check the second group.
				group1 = _children.back();
				if (group1->consume(Token::Types::KEYWORD, "rect")) { type1 = ShapeTypes::BOX; }
				else if (group1->consume(Token::Types::KEYWORD, "point")) { type1 = ShapeTypes::POINT; }
				else { THROW_INVALID_SYNTAX(onError); }
				if (group1->consume(Token::Types::OPERATOR, "(")) {
					if (!group1->consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
				}
				if (type1 == ShapeTypes::BOX) {
					if (group1->allChildren().size() <= 3) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (group1->allChildren().size() == 4) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}
				} else if (type1 == ShapeTypes::POINT) {
					if (group1->allChildren().size() <= 1) {
						THROW_TOO_FEW_ARGUMENTS(onError);
					} else if (group1->allChildren().size() == 2) {
						// Do nothing.
					} else {
						THROW_TOO_MANY_ARGUMENTS(onError);
					}
				}
				// Determine the shapes.
				if (type0 == ShapeTypes::BOX && type1 == ShapeTypes::BOX) {
					shapes = GAME_SHAPES_BOX_BOX;
				} else if (type0 == ShapeTypes::BOX && type1 == ShapeTypes::POINT) {
					shapes = GAME_SHAPES_BOX_POINT;
				} else if (type0 == ShapeTypes::POINT && type1 == ShapeTypes::BOX) {
					std::swap(type0, type1);
					std::swap(group0, group1);
					shapes = GAME_SHAPES_BOX_POINT;
				} else {
					THROW_INVALID_SYNTAX(onError);
				}
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			COND_VAR_GUARD(ctx.expect.lnno, ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the arguments.
					int argc = 0;
					switch (shapes) {
					case GAME_SHAPES_BOX_BOX:
						group1->writeChildren(bytes, context, Range(3, 0), stk, onError);
						group0->writeChildren(bytes, context, Range(3, 0), stk, onError);
						argc = 4 + 4;

						break;
					case GAME_SHAPES_BOX_POINT:
						group1->writeChildren(bytes, context, Range(1, 0), stk, onError);
						group0->writeChildren(bytes, context, Range(3, 0), stk, onError);
						argc = 2 + 4;

						break;
					}

					// Emit a `VM_HITS` instruction.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::HITS]); DEC_COUNTER(stk, 2 * argc); INC_COUNTER(stk, 2);
					args = fill(args, (UInt8)shapes);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("HITS");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "HITS");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Update
*/

class NodeUpdate : public Node {
public:
	NodeUpdate() {
	}
	virtual ~NodeUpdate() override {
	}

	NODE_TYPE(Types::UPDATE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "update")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));

			// Emit a `VM_UPDATE` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::UPDATE]);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("UPDATE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "UPDATE");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Device functions
*/

class NodeScreen : public Node {
public:
	NodeScreen() {
	}
	virtual ~NodeScreen() override {
	}

	NODE_TYPE(Types::SCREEN)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "screen")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the option value.
					writeChildren(bytes, context, Range(0), stk, onError);

					// Emit the option type.
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)DEVICE_OPTION_SCREEN_MODE);

					// Emit a `VM_OPTION` instruction.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SCREEN");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SCREEN");
	}
	using Node::dump;
};

class NodeOption : public NodeFunction {
public:
	NodeOption(const std::string &name) : NodeFunction(name) {
	}
	virtual ~NodeOption() override {
	}

	NODE_TYPE(Types::OPTION)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		validate(context, onError);

		NodeFunction::generate(bytes, context, onError);
	}

private:
	bool validate(Context::Stack &context, Error::Handler onError) const {
		Context &ctx = context.top();

		Token::Ptr tk = nullptr;
		int val = 0;
		if (_children.empty() || !isUInt8(context, 0, val, &tk)) // Only check it if it is a constant.
			return true;

		switch (val) {
		case DEVICE_RTC_SEC: // Fall through.
		case DEVICE_RTC_MIN: // Fall through.
		case DEVICE_RTC_HOUR: // Fall through.
		case DEVICE_RTC_DAY: // Fall through.
		case DEVICE_OPTION_RTC_ENABLED: // Fall through.
		case DEVICE_OPTION_RTC_START: // Fall through.
		case DEVICE_OPTION_RTC_LATCH:
			// Do nothing.

			break;
		default:
			return true;
		}

		if (!ctx.cartridgeHasRtc) { // No RTC.
			THROW_USING_RTC_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED(onError);

			return false;
		}

		return true;
	}
};

class NodeQuery : public NodeFunction {
public:
	NodeQuery(const std::string &name) : NodeFunction(name) {
	}
	virtual ~NodeQuery() override {
	}

	NODE_TYPE(Types::QUERY)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		validate(context, onError);

		NodeFunction::generate(bytes, context, onError);
	}

private:
	bool validate(Context::Stack &context, Error::Handler onError) const {
		Context &ctx = context.top();

		Token::Ptr tk = nullptr;
		int val = 0;
		if (_children.empty() || !isUInt8(context, 0, val, &tk)) // Only check it if it is a constant.
			return true;

		switch (val) {
		case DEVICE_RTC_SEC: // Fall through.
		case DEVICE_RTC_MIN: // Fall through.
		case DEVICE_RTC_HOUR: // Fall through.
		case DEVICE_RTC_DAY:
			// Do nothing.

			break;
		default:
			return true;
		}

		if (!ctx.cartridgeHasRtc) { // No RTC.
			THROW_USING_RTC_FEATURE_BUT_CARTRIDGE_DOES_NOT_HAVE_THIS_FUNCTION_ENABLED(onError);

			return false;
		}

		return true;
	}
};

class NodeAutoToggle : public Node {
public:
	NodeAutoToggle() {
	}
	virtual ~NodeAutoToggle() override {
	}

	NODE_TYPE(Types::AUTO_TOGGLE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		enum class OperationTypes {
			NONE,
			UPDATE
		};

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			OperationTypes type = OperationTypes::NONE;
			bool on = true;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "auto")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "update")) { type = OperationTypes::UPDATE; }
			else { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "on")) { on = true; }
			else if (consume(Token::Types::KEYWORD, "off")) { on = false; }
			else { THROW_INVALID_SYNTAX(onError); }

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the option value.
					const Int16 data = (Int16)BOOLEAN(on);
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)data);

					// Emit the option type.
					Int16 y = 0;
					switch (type) {
					case OperationTypes::UPDATE:   y = DEVICE_OPTION_AUTO_UPDATE_ENABLED;   break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)y);

					// Emit a `VM_OPTION` instruction.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("AUTO TOGGLE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "AUTO TOGGLE");
	}
	using Node::dump;
};

class NodeToggle : public Node {
public:
	NodeToggle() {
	}
	virtual ~NodeToggle() override {
	}

	NODE_TYPE(Types::TOGGLE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		enum class OperationTypes {
			NONE,
			SCREEN,
			MAP, WINDOW, SPRITE,
			SOUND,
			SERIAL
		};

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			OperationTypes type = OperationTypes::NONE;
			bool on = true;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (consume(Token::Types::KEYWORD, "screen")) { type = OperationTypes::SCREEN; }
			else if (consume(Token::Types::KEYWORD, "map")) { type = OperationTypes::MAP; }
			else if (consume(Token::Types::KEYWORD, "window")) { type = OperationTypes::WINDOW; }
			else if (consume(Token::Types::KEYWORD, "sprite")) { type = OperationTypes::SPRITE; }
			else if (consume(Token::Types::KEYWORD, "sound")) { type = OperationTypes::SOUND; }
			else if (consume(Token::Types::KEYWORD, "serial")) { type = OperationTypes::SERIAL; }
			else { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::KEYWORD, "on")) { on = true; }
			else if (consume(Token::Types::KEYWORD, "off")) { on = false; }
			else { THROW_INVALID_SYNTAX(onError); }

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// Emit the right hand value.
			const bool withDeclaring = ctx.declaration.declaring != -1;
			writeRightHand(
				bytes, context, stk,
				[&] (void) -> void {
					// Emit the option value.
					const Int16 data = (Int16)BOOLEAN(on);
					Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)data);

					// Emit the option type.
					Int16 y = 0;
					switch (type) {
					case OperationTypes::SCREEN:   y = DEVICE_OPTION_SCREEN_ENABLED;   break;
					case OperationTypes::MAP:      y = DEVICE_OPTION_MAP_ENABLED;      break;
					case OperationTypes::WINDOW:   y = DEVICE_OPTION_WINDOW_ENABLED;   break;
					case OperationTypes::SPRITE:   y = DEVICE_OPTION_SPRITE_ENABLED;   break;
					case OperationTypes::SOUND:    y = DEVICE_OPTION_SOUND_ENABLED;    break;
					case OperationTypes::SERIAL:   y = DEVICE_OPTION_SERIAL_ENABLED;   break;
					default:
						GBBASIC_ASSERT(false && "Impossible.");

						break;
					}
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::PUSH]); INC_COUNTER(stk, 2);
					args = fill(args, (UInt16)y);

					// Emit a `VM_OPTION` instruction.
					args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::OPTION]); DEC_COUNTER(stk, 2 * 2); INC_COUNTER(stk, 2);
				}, withDeclaring ? 0 : 1, false,
				onError
			);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("TOGGLE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "TOGGLE");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Extensions
*/

class NodeStream : public Node { // FEAT: GBB EXTENSION.
public:
	NodeStream() {
	}
	virtual ~NodeStream() override {
	}

	NODE_TYPE(Types::STREAM)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			bool isEos = false;
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "stream")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (consume(Token::Types::KEYWORD, "end")) { isEos = true; }
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			} else {
				if (consume(Token::Types::KEYWORD, "end")) { isEos = true; }
			}

			// Check the children.
			if (_children.empty()) {
				if (!isEos)
					THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				if (isEos)
					THROW_TOO_MANY_ARGUMENTS(onError);
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Check for feature compatibility.
			usingExtensionFeature(ctx, onError);

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the streaming statement.
			if (isEos) {
				// Emit a `VM_STREAM` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::STREAM]); DEC_COUNTER(stk, 0);
				args = fill(args, (UInt8)STREAMING_STATUS_EOS);
			} else {
				// Emit the evaluations.
				writeChildren(bytes, context, Range(0), stk, onError);

				// Emit a `VM_STREAM` instruction.
				Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::STREAM]); DEC_COUNTER(stk, 2);
				args = fill(args, (UInt8)STREAMING_STATUS_FILLED);
			}

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("STREAM");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "STREAM");
	}
	using Node::dump;
};

class NodeShell : public Node { // FEAT: GBB EXTENSION.
public:
	NodeShell() {
	}
	virtual ~NodeShell() override {
	}

	NODE_TYPE(Types::SHELL)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		replenishFormatted<NodeExpression>(context, 0);

		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "shell")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check for feature compatibility.
			usingExtensionFeature(ctx, onError);

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Set the expression slot guard.
			VAR_GUARD(ctx.expression.slots, Context::Expression::Slots(new Context::Expression::Slots::element_type));

			// FEAT: TEXT FORMAT.
			// Writing layout:
			//   argument evaluations
			//   the `VM_SHELL` instruction
			//     the argument count (C function argument)
			//   the arguments from front to back
			//   the format text in string, with termination point
			// Emit a `VM_SHELL` instruction.
			writeFormatted(bytes, context, stk, Asm::Types::SHELL, 0, nullptr, onError);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SHELL");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SHELL");
	}
	using Node::dump;
};

/* ===========================================================================} */

/*
** {===========================================================================
** Extra functions
*/

class NodeSleep : public Node {
public:
	NodeSleep() {
	}
	virtual ~NodeSleep() override {
	}

	NODE_TYPE(Types::SLEEP)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "sleep")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() == 1) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the evaluations.
			writeChildren(bytes, context, Range(0), stk, onError);

			// Emit a `VM_SLEEP` instruction.
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::SLEEP]);
			args = fill(args, (Int16)ARG0);

			// Emit a `VM_POP` instruction to remove the temporary values.
			args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::POP]); DEC_COUNTER(stk, 2);
			args = fill(args, (UInt8)1);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("SLEEP");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "SLEEP");
	}
	using Node::dump;
};

class NodeRaise : public Node {
public:
	NodeRaise() {
	}
	virtual ~NodeRaise() override {
	}

	NODE_TYPE(Types::RAISE)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "raise")) { THROW_INVALID_SYNTAX(onError); }
			if (consume(Token::Types::OPERATOR, "(")) {
				if (!consume(Token::Types::OPERATOR, ")")) { THROW_INVALID_SYNTAX(onError); }
			}

			// Check the children.
			if (_children.empty()) {
				THROW_TOO_FEW_ARGUMENTS(onError);
			} else if (_children.size() <= 255) {
				// Do nothing.
			} else {
				THROW_TOO_MANY_ARGUMENTS(onError);
			}

			// Set the stack footprint guard.
			VAR_GUARD(ctx.stackFootprint, Counter::Ptr(new Counter()));
			COUNTER_GUARD(ctx, stk);

			// Emit the arguments.
			if (_children.size() > 1)
				writeChildren(bytes, context, Range(1, (int)_children.size() - 1), stk, onError);

			// Emit a `VM_RAISE` instruction.
			Token::Ptr tk = nullptr;
			int val = 0;
			if (!isUInt8(context, 0, val, &tk)) { THROW_TYPE_EXPECTED(onError, "Byte constant", tk); }
			Byte* args = emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RAISE]);
			args = fill(args, (UInt8)(_children.size() - 1));
			args = fill(args, (UInt8)val);

			// Check the stack footprint.
			CHECK_COUNTER(ctx, onError);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RAISE");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RAISE");
	}
	using Node::dump;
};

class NodeError : public Node { // Dummy node to denote an error.
public:
	NodeError() {
	}
	virtual ~NodeError() override {
	}

	NODE_TYPE(Types::ERROR)

	virtual Abstract abstract(void) const override {
		return abstract("ERROR");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "ERROR");
	}
	using Node::dump;
};

class NodeReset : public Node {
public:
	NodeReset() {
	}
	virtual ~NodeReset() override {
	}

	NODE_TYPE(Types::RESET)

	virtual void generate(Bytes::Ptr &bytes, Context::Stack &context, Error::Handler onError) override {
		const Generator_Void_Void generator = [&] (void) -> void {
			// Prepare.
			Context &ctx = context.top();
			State &state = top();

			const Asm::Instructions &INSTRUCTIONS = *ctx.instructions;

			// Determine the location in the ROM.
			state.inRom.bank = ctx.bank;
			state.inRom.address = ctx.addressCursor;
			state.inRom.size = 0;

			// Consume the tokens.
			if (ctx.expect.lnno) {
				if (!consume(Token::Types::INTEGER, ANYTHING, [&] (Token::Ptr tk) -> void {
					state.inCode = SourceLocation(tk->begin().page, (int)tk->data());
				})) { THROW_INVALID_SYNTAX(onError); }
			}
			if (!consume(Token::Types::KEYWORD, "reset")) { THROW_INVALID_SYNTAX(onError); }

			// Emit a `VM_RESET` instruction.
			emit(bytes, context, INSTRUCTIONS[(size_t)Asm::Types::RESET]);
		};

		write(bytes, context, generator, false, onError);
	}

	virtual Abstract abstract(void) const override {
		return abstract("RESET");
	}
	using Node::abstract;

	virtual std::string dump(int depth) const override {
		return dump(depth, "RESET");
	}
	using Node::dump;
};

/* ===========================================================================} */

}

/* ===========================================================================} */

/*
** {===========================================================================
** Parser
*/

namespace GBBASIC {

class Parser final {
public:
	struct Statement {
		typedef std::function<Node::Ptr(const Statement*)> Handler;

		Handler handler = nullptr;
		Token::Types type = Token::Types::NONE;
		DefaultTable defaults;
		bool withReturned = false;

		Statement() {
		}
		Statement(Handler handler_, Token::Types y, bool withReturned_) : handler(handler_), type(y), withReturned(withReturned_) {
		}

		Statement* parameters(int params, const DefaultTable::Entry::Values &values) {
			defaults.add(params, values);

			return this;
		}
	};
	typedef std::map<std::string, Statement> StatementDictionary;

	typedef std::map<std::string, Variant> Macros;

private:
	struct Options {
		GBBASIC::Options::Strategies::Compatibilities compatibility = GBBASIC::Options::Strategies::Compatibilities::CLASSIC | GBBASIC::Options::Strategies::Compatibilities::COLORED;
		bool caseInsensitive = true;
		bool completeLineNumber = true;
		int indexBase = 0;
		int bankSize = 0;
		bool failOnError = true;

		Options() {
		}
	};

	struct State {
		int index = 0;
		Token::Array tokens;
		bool success = false;

		State() {
		}
		State(int idx) : index(idx) {
		}

		int transfer(State &other) {
			if (tokens.empty())
				return 0;

			Token::Ptr tk = tokens.back();
			tokens.pop_back();
			other.tokens.push_back(tk);

			return 1;
		}
	};

	struct Lexical {
		typedef std::initializer_list<Lexical> List;

		Token::Types type0 = Token::Types::NONE;
		Variant data0 = nullptr;
		Token::Types type1 = Token::Types::NONE;
		Variant data1 = nullptr;

		Lexical() {
		}
		Lexical(Token::Types y0, const Variant &d0) : type0(y0), data0(d0) {
		}
		Lexical(Token::Types y0, const Variant &d0, Token::Types y1, const Variant &d1) : type0(y0), data0(d0), type1(y1), data1(d1) {
		}
	};

	typedef std::function<Node::Ptr(const Statement*)> NodeCreator;
	struct Defaults { /* Dummy. */ };

	struct Combinator {
	public:
		typedef std::initializer_list<Combinator> List;

		struct Options {
			bool mustHaveLineNumber = true;

			Options() {
			}
		};

		typedef std::function<bool(Node::Ptr &, const Options &)> Handler;

	private:
		Handler _handler = nullptr;

	public:
		Combinator() {
		}
		Combinator(Handler handler) : _handler(handler) {
		}
		~Combinator() {
		}

		bool operator () (Node::Ptr &p, const Options &options) const {
			if (!_handler)
				return false;

			return _handler(p, options);
		}
	};

private:
	Options _options;
	StatementDictionary _statements;
	Text::Array _statementsWithReturned;
	Text::Array _stackArguments;

	Token::Array _tokens;
	Node::Ptr _ast = nullptr;
	int _linesOfCode = 0;
	int _lineNumberWidth = 0;

public:
	Parser() {
		for (int i = 0; i < COMPILER_STACK_ARGUMENT_MAX_COUNT; ++i) {
			const std::string key = "stack" + Text::toString(i);
			_stackArguments.push_back(key);
		}
	}
	~Parser() {
	}

	Variant option(const std::string &key) const {
		if (key == "compatibility")
			return (Variant::Long)_options.compatibility;
		if (key == "case_insensitive")
			return _options.caseInsensitive;
		if (key == "complete_line_number")
			return _options.completeLineNumber;
		if (key == "index_base")
			return _options.indexBase;
		if (key == "bank_size")
			return _options.bankSize;
		if (key == "fail_on_error")
			return _options.failOnError;

		GBBASIC_ASSERT(false && "Unknown option.");

		return nullptr;
	}
	bool option(const std::string &key, const Variant &val) {
		if (key == "compatibility") {
			_options.compatibility = (GBBASIC::Options::Strategies::Compatibilities)(int)val;

			return true;
		}
		if (key == "case_insensitive") {
			_options.caseInsensitive = (bool)val;

			return true;
		}
		if (key == "complete_line_number") {
			_options.completeLineNumber = (bool)val;

			return true;
		}
		if (key == "index_base") {
			_options.indexBase = (int)val;

			return true;
		}
		if (key == "bank_size") {
			_options.bankSize = (int)val;

			return true;
		}
		if (key == "fail_on_error") {
			_options.failOnError = (bool)val;

			return true;
		}

		GBBASIC_ASSERT(false && "Unknown option.");

		return false;
	}

	void initialize(BuiltinTable &builtins, FunctionTable &functions, OperatorTable &operators) {
		// Prepare.
		const bool anyCase = _options.caseInsensitive;

		#define ADD_STATEMENT(ID, CTOR, Y, RET)   addStatement((ID), (CTOR), (Y), (RET))
		#define ADD_BUILTIN(ID, VAL)              builtins.add((ID), (VAL), anyCase)
		#define ADD_FUNCTION(ID, INST)            functions.add((ID), (INST))
		#define ADD_OPERATOR(ID, INST)            operators.add((ID), (INST))

		// Add the statements for the parser.
		// This information is used by the parser to understand the tokens.
		do {
			// Format: identifier, creator, type, has return value.

			/**< Operators. */

			// `a OP b` or `OP a`.
			ADD_STATEMENT("mod",               NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("and",               NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("or",                NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("not",               NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("band",              NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("bor",               NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("bxor",              NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("bnot",              NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("lshift",            NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);
			ADD_STATEMENT("rshift",            NODE /* for syntax assistance */,           Token::Types::OPERATOR,   false);

			// Function-like `OP(...)`.
			ADD_STATEMENT("sgn",               node<NodeMath>("sgn"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("abs",               node<NodeMath>("abs"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("sqr",               node<NodeMath>("sqr"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("sqrt",              node<NodeMath>("sqrt"),                     Token::Types::OPERATOR,   false);
			ADD_STATEMENT("sin",               node<NodeMath>("sin"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("cos",               node<NodeMath>("cos"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("atan2",             node<NodeMath>("atan2"),                    Token::Types::OPERATOR,   false);
			ADD_STATEMENT("pow",               node<NodeMath>("pow"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("min",               node<NodeMath>("min"),                      Token::Types::OPERATOR,   false);
			ADD_STATEMENT("max",               node<NodeMath>("max"),                      Token::Types::OPERATOR,   false);

			// `ASC(...)`.
			ADD_STATEMENT("asc",               node<NodeAsc>(),                            Token::Types::KEYWORD,     true);

			// `DEG(...)`.
			ADD_STATEMENT("deg",               node<NodeDeg>(),                            Token::Types::KEYWORD,     true);

			// `LEN(...)`.
			ADD_STATEMENT("len",               node<NodeLen>(),                            Token::Types::KEYWORD,     true);

			// `RND[(...)]`.
			ADD_STATEMENT("randomize",         node<NodeRandomize>(),                      Token::Types::KEYWORD,    false);
			ADD_STATEMENT("rnd",               node<NodeRnd>(),                            Token::Types::OPERATOR,    true);

			// Bank/address of.
			ADD_STATEMENT("bankof",            node<NodeBankOf>(),                         Token::Types::KEYWORD,     true);
			ADD_STATEMENT("addressof",         node<NodeAddressOf>(),                      Token::Types::KEYWORD,     true);

			// Array accessors.
			ADD_STATEMENT("=[...]",            node<NodeArrayRead>(),                      Token::Types::NONE,       false);
			ADD_STATEMENT("[...]=",            node<NodeArrayWrite>(),                     Token::Types::NONE,       false);

			/**< Syntax. */

			// Blank and remark.
			ADD_STATEMENT(" ",                 node<NodeBlank>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("rem",               node<NodeRem>(),                            Token::Types::KEYWORD,    false);
			ADD_STATEMENT("do",                NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("donothing",         node<NodeDoNothing>(),                      Token::Types::KEYWORD,    false);

			// Type definition.
			ADD_STATEMENT("int",               NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);

			// Declaration.
			ADD_STATEMENT("const",             node<NodeConst>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("let",               node<NodeLet>(),                            Token::Types::KEYWORD,    false);
			ADD_STATEMENT("local",             RESERVED,                                   Token::Types::KEYWORD,    false);
			ADD_STATEMENT("dim",               node<NodeDim>(),                            Token::Types::KEYWORD,    false);

			// Conditional.
			ADD_STATEMENT("if",                node<NodeIf>(),                             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("then",              node<NodeThen>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("else",              node<NodeElse>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("elseif",            node<NodeElseIf>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("endif",             NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("iif",               node<NodeIif>(),                            Token::Types::KEYWORD,     true);
			ADD_STATEMENT("select",            node<NodeSelect>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("case",              node<NodeCase>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("endselect",         NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("on",                node<NodeOn>(),                             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("off",               node<NodeOff>(),                            Token::Types::KEYWORD,    false);

			// Loop.
			ADD_STATEMENT("for",               node<NodeFor>(),                            Token::Types::KEYWORD,    false);
			ADD_STATEMENT("to",                NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("step",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("next",              node<NodeNext>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("while",             node<NodeWhile>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("wend",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("repeat",            node<NodeRepeat>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("until",             NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("exit",              node<NodeExit>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("continue",          RESERVED,                                   Token::Types::KEYWORD,    false);

			// Jump.
			ADD_STATEMENT("goto",              node<NodeGoto>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("gosub",             node<NodeGosub>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("return",            node<NodeReturn>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("end",               node<NodeEnd>(),                            Token::Types::KEYWORD,    false);
			ADD_STATEMENT("call",              node<NodeCall>(),                           Token::Types::KEYWORD,    false);

			// Thread.
			ADD_STATEMENT("start",             node<NodeStart>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("join",              node<NodeJoin>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("kill",              node<NodeKill>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("wait",              node<NodeWait>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("lock",              node<NodeLock>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("unlock",            node<NodeUnlock>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("arg",               node<NodeArg>(),                            Token::Types::KEYWORD,     true);

			// Scope and macros.
			ADD_STATEMENT("begin",             NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("begindo",           node<NodeBeginDo>(),                        Token::Types::KEYWORD,    false);
			ADD_STATEMENT("enddo",             NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("begindef",          node<NodeBeginDef>(),                       Token::Types::KEYWORD,    false);
			ADD_STATEMENT("enddef",            NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("def",               NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("fn",                node<NodeFn>(),                             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("def ...=M",         node<NodeDefMacroAlias>(),                  Token::Types::KEYWORD,    false);
			ADD_STATEMENT("def fn(...)=...",   node<NodeDefFn>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("def ...=N",         node<NodeDefConstant>(),                    Token::Types::KEYWORD,    false);
			ADD_STATEMENT("def ...=id",        node<NodeDefIdentifierAlias>(),             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("def ...=stackN",    node<NodeDefStackN>(),                      Token::Types::KEYWORD,    false);

			/**< Standard functions. */

			// Output.
			ADD_STATEMENT("locate",            node<NodeLocate>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("print",             node<NodePrint>(),                          Token::Types::KEYWORD,    false);

			// Data stream.
			ADD_STATEMENT("peek",              node<NodePeek>(),                           Token::Types::KEYWORD,     true);
			ADD_STATEMENT("poke",              node<NodePoke>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("peekw",             node<NodePeekW>(),                          Token::Types::KEYWORD,     true);
			ADD_STATEMENT("pokew",             node<NodePokeW>(),                          Token::Types::KEYWORD,    false);

			// Stack.
			ADD_STATEMENT("reserve",           node<NodeReserve>(),                        Token::Types::KEYWORD,    false);
			ADD_STATEMENT("push",              node<NodePush>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("pop",               node<NodePop>(),                            Token::Types::KEYWORD,    false);
			ADD_STATEMENT("top",               node<NodeTop>(),                            Token::Types::KEYWORD,     true);
			ADD_STATEMENT("stack",             node<NodeStack>(),                          Token::Types::KEYWORD,     true);
			for (int i = 0; i < COMPILER_STACK_ARGUMENT_MAX_COUNT; ++i) {
				const std::string key = _stackArguments[i];
				ADD_STATEMENT(key,             node<NodeStackN>(i),                        Token::Types::OPERATOR,    true);
			}

			// Variable.
			ADD_STATEMENT("pack",              node<NodePack>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("unpack",            node<NodeUnpack>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("packn",             node<NodePackN>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("unpackn",           node<NodeUnpackN>(),                        Token::Types::KEYWORD,    false);
			ADD_STATEMENT("swap",              node<NodeSwap>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("inc",               node<NodeInc>(),                            Token::Types::KEYWORD,    false);
			ADD_STATEMENT("dec",               node<NodeDec>(),                            Token::Types::KEYWORD,    false);

			// Data stream.
			ADD_STATEMENT("data",              node<NodeData>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("read",              node<NodeRead>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("restore",           node<NodeRestore>(),                        Token::Types::KEYWORD,    false);

			// System.
			ADD_STATEMENT("sleep",             node<NodeSleep>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("raise",             node<NodeRaise>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("reset",             node<NodeReset>(),                          Token::Types::KEYWORD,    false);

			/**< Basic functions. */

			// Graphics.
			ADD_STATEMENT("color",             node<NodeRoutine>("color"),                 Token::Types::KEYWORD,    false);
			ADD_STATEMENT("palette",           node<NodePalette>(),                        Token::Types::KEYWORD,    false);
			ADD_STATEMENT("rgb",               node<NodeRgb>(),                            Token::Types::KEYWORD,     true);
			ADD_STATEMENT("hsv",               node<NodeHsv>(),                            Token::Types::KEYWORD,     true);
			ADD_STATEMENT("plot",              node<NodeRoutine>("plot"),                  Token::Types::KEYWORD,    false);
			ADD_STATEMENT("point",             node<NodeFunction>("point"),                Token::Types::KEYWORD,     true);
			ADD_STATEMENT("line",              node<NodeRoutine>("line"),                  Token::Types::KEYWORD,    false);
			ADD_STATEMENT("rect",              node<NodeRect>("rect"),                     Token::Types::KEYWORD,    false);
			ADD_STATEMENT("rectfill",          node<NodeRect>("rectfill"),                 Token::Types::KEYWORD,    false);
			ADD_STATEMENT("text",              node<NodeText>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("image",             node<NodeImageManipulation>(),              Token::Types::KEYWORD,    false);
			ADD_STATEMENT("tile",              node<NodeTileManipulation>(),               Token::Types::KEYWORD,    false);
			ADD_STATEMENT("map",               node<NodeMapManipulation>(),                Token::Types::KEYWORD,    false);
			ADD_STATEMENT("window",            node<NodeWindowManipulation>(),             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("sprite",            node<NodeSpriteManipulation>(),             Token::Types::KEYWORD,    false);

			// Audio.
			ADD_STATEMENT("play",              node<NodePlay>(),                           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("stop",              node<NodeRoutine>("stop"),                  Token::Types::KEYWORD,    false);
			ADD_STATEMENT("sound",             node<NodeSound>(),                          Token::Types::KEYWORD,    false);
			ADD_STATEMENT("beep",              node<NodeBeep>(),                           Token::Types::KEYWORD,    false);

			// Input.
			ADD_STATEMENT("btn",               node<NodeFunction>("btn", Defaults()),      Token::Types::KEYWORD,     true)
				->parameters(0, { 0xff /* mask for all buttons */ });
			ADD_STATEMENT("btnd",              node<NodeFunction>("btnd", Defaults()),     Token::Types::KEYWORD,     true)
				->parameters(0, { 0xff /* mask for all buttons */ });
			ADD_STATEMENT("btnu",              node<NodeFunction>("btnu", Defaults()),     Token::Types::KEYWORD,     true)
				->parameters(0, { 0xff /* mask for all buttons */ });
			ADD_STATEMENT("touch",             node<NodeTouch>(),                          Token::Types::KEYWORD,     true);
			ADD_STATEMENT("touchd",            node<NodeTouch>(),                          Token::Types::KEYWORD,     true);
			ADD_STATEMENT("touchu",            node<NodeTouch>(),                          Token::Types::KEYWORD,     true);

			// Persistence.
			ADD_STATEMENT("fopen",             node<NodeFile>("fopen"),                    Token::Types::KEYWORD,     true);
			ADD_STATEMENT("fclose",            node<NodeFile>("fclose"),                   Token::Types::KEYWORD,     true);
			ADD_STATEMENT("fread",             node<NodeFile>("fread"),                    Token::Types::KEYWORD,     true);
			ADD_STATEMENT("fwrite",            node<NodeFile>("fwrite"),                   Token::Types::KEYWORD,     true);

			// Serial port.
			ADD_STATEMENT("serial",            node<NodeSerial>(),                         Token::Types::KEYWORD,     true);
			ADD_STATEMENT("sread",             node<NodeFunction>("sread", Defaults()),    Token::Types::KEYWORD,     true)
				->parameters(0, { TRUE /* sync */ });
			ADD_STATEMENT("swrite",            node<NodeFunction>("swrite", Defaults()),   Token::Types::KEYWORD,     true)
				->parameters(1, { DefaultTable::Entry::PLACEHOLDER, TRUE /* sync */ });

			// Debug.
			ADD_STATEMENT("dbginfo",           node<NodeRoutine>("dbginfo", Defaults()),   Token::Types::KEYWORD,    false)
				->parameters(0, { FALSE /* full */ });
			ADD_STATEMENT("filler",            node<NodeFiller>(),                         Token::Types::KEYWORD,    false);

			/**< Memory functions. */

			// Memory.
			ADD_STATEMENT("memcpy",            node<NodeMemcpy>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("memset",            node<NodeMemset>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("memadd",            node<NodeMemadd>(),                         Token::Types::KEYWORD,    false);

			/**< Advanced functions. */

			// Object.
			ADD_STATEMENT("new",               node<NodeNew>(),                            Token::Types::KEYWORD,     true);
			ADD_STATEMENT("del",               NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("fill",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("load",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("get",               NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("set",               NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("property",          NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("width",             node<NodeWidth>(),                          Token::Types::KEYWORD,     true);
			ADD_STATEMENT("height",            node<NodeHeight>(),                         Token::Types::KEYWORD,     true);
			ADD_STATEMENT("move",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("find",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("control",           NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("auto",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);
			ADD_STATEMENT("is",                node<NodeIs>(),                             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("with",              NODE /* for syntax assistance */,           Token::Types::KEYWORD,    false);

			// Scene.
			ADD_STATEMENT("camera",            node<NodeRoutine>("camera"),                Token::Types::KEYWORD,    false);
			ADD_STATEMENT("viewport",          node<NodeViewport>(),                       Token::Types::KEYWORD,     true);
			ADD_STATEMENT("scene",             node<NodeSceneManipulation>(),              Token::Types::KEYWORD,    false);

			// Actor.
			ADD_STATEMENT("actor",             node<NodeActorManipulation>(),              Token::Types::KEYWORD,    false);

			// Emote.
			ADD_STATEMENT("emote",             node<NodeEmoteManipulation>(),              Token::Types::KEYWORD,    false);

			// Projectile.
			ADD_STATEMENT("projectile",        node<NodeProjectileManipulation>(),         Token::Types::KEYWORD,    false);

			// Trigger.
			ADD_STATEMENT("trigger",           node<NodeTriggerManipulation>(),            Token::Types::KEYWORD,    false);

			// GUI.
			ADD_STATEMENT("widget",            node<NodeWidgetManipulation>(),             Token::Types::KEYWORD,    false);
			ADD_STATEMENT("label",             node<NodeLabelManipulation>(),              Token::Types::KEYWORD,    false);
			ADD_STATEMENT("progressbar",       node<NodeProgressBarManipulation>(),        Token::Types::KEYWORD,    false);
			ADD_STATEMENT("menu",              node<NodeMenuManipulation>(),               Token::Types::KEYWORD,    false);

			// Scroll.
			ADD_STATEMENT("scroll",            node<NodeScroll>(),                         Token::Types::KEYWORD,    false);

			// Effects.
			ADD_STATEMENT("fx",                node<NodeFx>(),                             Token::Types::KEYWORD,    false);

			// Physics.
			ADD_STATEMENT("hits",              node<NodeHits>(),                           Token::Types::OPERATOR,    true);

			// Game.
			ADD_STATEMENT("update",            node<NodeUpdate>(),                         Token::Types::KEYWORD,    false);

			// Device.
			ADD_STATEMENT("screen",            node<NodeScreen>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("option",            node<NodeOption>("option"),                 Token::Types::KEYWORD,     true);
			ADD_STATEMENT("query",             node<NodeQuery>("query"),                   Token::Types::KEYWORD,     true);
			ADD_STATEMENT("stream",            node<NodeStream>(),                         Token::Types::KEYWORD,    false);
			ADD_STATEMENT("shell",             node<NodeShell>(),                          Token::Types::KEYWORD,    false);
		} while (false);

		// Add the builtin entries for the compiler.
		// This information is used by the compiler to determine the builtin
		// registers, variables, constants, etc. But it is gathered by the
		// parser here for system defined, and later during parsing for user
		// defined.
		do {
			// Format: identifier, value, case-insensitive (omit).

			/**< Syntax. */

			// Object.
			ADD_BUILTIN("nothing",                                   BuiltinTable::Entry(0)                                                 ); // For code...

			// Boolean.
			ADD_BUILTIN("false",                                     BuiltinTable::Entry(0)                                                 ); // For code...
			ADD_BUILTIN("true",                                      BuiltinTable::Entry(1)                                                 );

			/**< Registers. */

			// System.
			ADD_BUILTIN("time",                                      BuiltinTable::Entry(Asm::Types::SYS_TIME)                              ); // For code...

			/**< Constants. */

			// Directions.
			ADD_BUILTIN("DOWN_DIR",                                  BuiltinTable::Entry(DIRECTION_DOWN)                                    ); // For point and vector calculation...
			ADD_BUILTIN("RIGHT_DIR",                                 BuiltinTable::Entry(DIRECTION_RIGHT)                                   );
			ADD_BUILTIN("UP_DIR",                                    BuiltinTable::Entry(DIRECTION_UP)                                      );
			ADD_BUILTIN("LEFT_DIR",                                  BuiltinTable::Entry(DIRECTION_LEFT)                                    );
			ADD_BUILTIN("NONE_DIR",                                  BuiltinTable::Entry(DIRECTION_NONE)                                    );

			// Properties.
			ADD_BUILTIN("PALETTE_PROP",                              BuiltinTable::Entry(PROPERTY_PALETTE)                                  ); // For properties...
			ADD_BUILTIN("HFLIP_PROP",                                BuiltinTable::Entry(PROPERTY_HFLIP)                                    );
			ADD_BUILTIN("VFLIP_PROP",                                BuiltinTable::Entry(PROPERTY_VFLIP)                                    );
			ADD_BUILTIN("PRIORITY_PROP",                             BuiltinTable::Entry(PROPERTY_PRIORITY)                                 );
			ADD_BUILTIN("HIDDEN_PROP",                               BuiltinTable::Entry(PROPERTY_HIDDEN)                                   );
			ADD_BUILTIN("ACTIVE_PROP",                               BuiltinTable::Entry(PROPERTY_ACTIVE)                                   );
			ADD_BUILTIN("ENABLED_PROP",                              BuiltinTable::Entry(PROPERTY_ENABLED)                                  );
			ADD_BUILTIN("PINNED_PROP",                               BuiltinTable::Entry(PROPERTY_PINNED)                                   );
			ADD_BUILTIN("PERSISTENT_PROP",                           BuiltinTable::Entry(PROPERTY_PERSISTENT)                               );
			ADD_BUILTIN("FOLLOWING_PROP",                            BuiltinTable::Entry(PROPERTY_FOLLOWING)                                );
			ADD_BUILTIN("ANIMATION_LOOP_PROP",                       BuiltinTable::Entry(PROPERTY_ANIMATION_LOOP)                           );
			ADD_BUILTIN("ANIMATION_PAUSED_PROP",                     BuiltinTable::Entry(PROPERTY_ANIMATION_PAUSED)                         );
			ADD_BUILTIN("MOVEMENT_INTERRUPT_PROP",                   BuiltinTable::Entry(PROPERTY_MOVEMENT_INTERRUPT)                       );
			ADD_BUILTIN("POSITION_PROP",                             BuiltinTable::Entry(PROPERTY_POSITION)                                 );
			ADD_BUILTIN("POSITION_X_PROP",                           BuiltinTable::Entry(PROPERTY_POSITION_X)                               );
			ADD_BUILTIN("POSITION_Y_PROP",                           BuiltinTable::Entry(PROPERTY_POSITION_Y)                               );
			ADD_BUILTIN("DIRECTION_PROP",                            BuiltinTable::Entry(PROPERTY_DIRECTION)                                );
			ADD_BUILTIN("ANGLE_PROP",                                BuiltinTable::Entry(PROPERTY_ANGLE)                                    );
			ADD_BUILTIN("BOUNDS_PROP",                               BuiltinTable::Entry(PROPERTY_BOUNDS)                                   );
			ADD_BUILTIN("BOUNDS_LEFT_PROP",                          BuiltinTable::Entry(PROPERTY_BOUNDS_LEFT)                              );
			ADD_BUILTIN("BOUNDS_RIGHT_PROP",                         BuiltinTable::Entry(PROPERTY_BOUNDS_RIGHT)                             );
			ADD_BUILTIN("BOUNDS_TOP_PROP",                           BuiltinTable::Entry(PROPERTY_BOUNDS_TOP)                               );
			ADD_BUILTIN("BOUNDS_BOTTOM_PROP",                        BuiltinTable::Entry(PROPERTY_BOUNDS_BOTTOM)                            );
			ADD_BUILTIN("BASE_TILE_PROP",                            BuiltinTable::Entry(PROPERTY_BASE_TILE)                                );
			ADD_BUILTIN("FRAMES_PROP",                               BuiltinTable::Entry(PROPERTY_FRAMES)                                   );
			ADD_BUILTIN("FRAME_INDEX_PROP",                          BuiltinTable::Entry(PROPERTY_FRAME_INDEX)                              );
			ADD_BUILTIN("ANIMATION_INTERVAL_PROP",                   BuiltinTable::Entry(PROPERTY_ANIMATION_INTERVAL)                       );
			ADD_BUILTIN("ANIMATIONS_PROP",                           BuiltinTable::Entry(PROPERTY_ANIMATIONS)                               );
			ADD_BUILTIN("ANIMATION_PROP",                            BuiltinTable::Entry(PROPERTY_ANIMATION)                                );
			ADD_BUILTIN("ANIMATION_INDEX_PROP",                      BuiltinTable::Entry(PROPERTY_ANIMATION_INDEX)                          );
			ADD_BUILTIN("MOVE_SPEED_PROP",                           BuiltinTable::Entry(PROPERTY_MOVE_SPEED)                               );
			ADD_BUILTIN("BEHAVIOUR_PROP",                            BuiltinTable::Entry(PROPERTY_BEHAVIOUR)                                );
			ADD_BUILTIN("COLLISION_GROUP_PROP",                      BuiltinTable::Entry(PROPERTY_COLLISION_GROUP)                          );
			ADD_BUILTIN("STRONG_PROP",                               BuiltinTable::Entry(PROPERTY_STRONG)                                   );
			ADD_BUILTIN("LIFE_TIME_PROP",                            BuiltinTable::Entry(PROPERTY_LIFE_TIME)                                );
			ADD_BUILTIN("INITIAL_OFFSET_PROP",                       BuiltinTable::Entry(PROPERTY_INITIAL_OFFSET)                           );
			ADD_BUILTIN("IS_16x16_GRID",                             BuiltinTable::Entry(PROPERTY_IS_16x16_GRID)                            );
			ADD_BUILTIN("IS_16x16_PLAYER",                           BuiltinTable::Entry(PROPERTY_IS_16x16_PLAYER)                          );
			ADD_BUILTIN("CLAMP_CAMERA_PROP",                         BuiltinTable::Entry(PROPERTY_CLAMP_CAMERA)                             );
			ADD_BUILTIN("GRAVITY_PROP",                              BuiltinTable::Entry(PROPERTY_GRAVITY)                                  );
			ADD_BUILTIN("JUMP_GRAVITY_PROP",                         BuiltinTable::Entry(PROPERTY_JUMP_GRAVITY)                             );
			ADD_BUILTIN("JUMP_MAX_COUNT_PROP",                       BuiltinTable::Entry(PROPERTY_JUMP_MAX_COUNT)                           );
			ADD_BUILTIN("JUMP_MAX_TICKS_PROP",                       BuiltinTable::Entry(PROPERTY_JUMP_MAX_TICKS)                           );
			ADD_BUILTIN("CLIMB_VELOCITY_PROP",                       BuiltinTable::Entry(PROPERTY_CLIMB_VELOCITY)                           );
			/* Not inuse.
			ADD_BUILTIN("SIZE_PROP",                                 BuiltinTable::Entry(PROPERTY_SIZE)                                     );
			*/
			ADD_BUILTIN("WIDTH_PROP",                                BuiltinTable::Entry(PROPERTY_SIZE_WIDTH)                               );
			ADD_BUILTIN("HEIGHT_PROP",                               BuiltinTable::Entry(PROPERTY_SIZE_HEIGHT)                              );
			ADD_BUILTIN("CAMERA_DEADZONE_PROP",                      BuiltinTable::Entry(PROPERTY_CAMERA_DEADZONE)                          );
			ADD_BUILTIN("CAMERA_DEADZONE_X_PROP",                    BuiltinTable::Entry(PROPERTY_CAMERA_DEADZONE_X)                        );
			ADD_BUILTIN("CAMERA_DEADZONE_Y_PROP",                    BuiltinTable::Entry(PROPERTY_CAMERA_DEADZONE_Y)                        );
			ADD_BUILTIN("BLOCKING_PROP",                             BuiltinTable::Entry(PROPERTY_BLOCKING)                                 );
			ADD_BUILTIN("BLOCKING_X_PROP",                           BuiltinTable::Entry(PROPERTY_BLOCKING_X)                               );
			ADD_BUILTIN("BLOCKING_LEFT_PROP",                        BuiltinTable::Entry(PROPERTY_BLOCKING_LEFT)                            );
			ADD_BUILTIN("BLOCKING_RIGHT_PROP",                       BuiltinTable::Entry(PROPERTY_BLOCKING_RIGHT)                           );
			ADD_BUILTIN("BLOCKING_Y_PROP",                           BuiltinTable::Entry(PROPERTY_BLOCKING_Y)                               );
			ADD_BUILTIN("BLOCKING_UP_PROP",                          BuiltinTable::Entry(PROPERTY_BLOCKING_UP)                              );
			ADD_BUILTIN("BLOCKING_DOWN_PROP",                        BuiltinTable::Entry(PROPERTY_BLOCKING_DOWN)                            );

			// Events.
			ADD_BUILTIN("ENTER",                                     BuiltinTable::Entry(EVENT_ENTER)                                       ); // For trigger...
			ADD_BUILTIN("LEAVE",                                     BuiltinTable::Entry(EVENT_LEAVE)                                       );
			ADD_BUILTIN("CHANGE",                                    BuiltinTable::Entry(EVENT_CHANGE)                                      );
			ADD_BUILTIN("CONFIRM",                                   BuiltinTable::Entry(EVENT_CONFIRM)                                     );

			// Exceptions.
			ADD_BUILTIN("UNKNOWN_PARAMETER",                         BuiltinTable::Entry(EXCEPTION_UNKNOWN_PARAMETER)                       ); // For exception...
			ADD_BUILTIN("DEVICE_ERROR",                              BuiltinTable::Entry(EXCEPTION_DEVICE_ERROR)                            );

			// Graphics.
			ADD_BUILTIN("SOLID_MODE",                                BuiltinTable::Entry(GRAPHICS_MODE_SOLID)                               ); // For graphics primitives...
			ADD_BUILTIN("OR_MODE",                                   BuiltinTable::Entry(GRAPHICS_MODE_OR)                                  );
			ADD_BUILTIN("XOR_MODE",                                  BuiltinTable::Entry(GRAPHICS_MODE_XOR)                                 );
			ADD_BUILTIN("AND_MODE",                                  BuiltinTable::Entry(GRAPHICS_MODE_AND)                                 );

			ADD_BUILTIN("WHITE",                                     BuiltinTable::Entry(GRAPHICS_PALETTE_WHITE)                            ); // For graphics primitives...
			ADD_BUILTIN("SILVER",                                    BuiltinTable::Entry(GRAPHICS_PALETTE_SILVER)                           );
			ADD_BUILTIN("GRAY",                                      BuiltinTable::Entry(GRAPHICS_PALETTE_GRAY)                             );
			ADD_BUILTIN("BLACK",                                     BuiltinTable::Entry(GRAPHICS_PALETTE_BLACK)                            );

			ADD_BUILTIN("MAP_LAYER",                                 BuiltinTable::Entry(GRAPHICS_LAYER_MAP)                                ); // `MAP_LAYER` and `SPRITE_LAYER` are for the `VM_PALETTE` instruction...
			ADD_BUILTIN("WINDOW_LAYER",                              BuiltinTable::Entry(GRAPHICS_LAYER_WINDOW)                             ); // All of these three are for the fill instruction...
			ADD_BUILTIN("SPRITE_LAYER",                              BuiltinTable::Entry(GRAPHICS_LAYER_SPRITE)                             );

			// Audio.
			ADD_BUILTIN("MINIMAL_PRIORITY",                          BuiltinTable::Entry(AUDIO_SFX_PRIORITY_MINIMAL)                        ); // For `VM_SOUND`...
			ADD_BUILTIN("NORMAL_PRIORITY",                           BuiltinTable::Entry(AUDIO_SFX_PRIORITY_NORMAL)                         );
			ADD_BUILTIN("HIGH_PRIORITY",                             BuiltinTable::Entry(AUDIO_SFX_PRIORITY_HIGH)                           );

			// Input.
			ADD_BUILTIN("UP_BTN",                                    BuiltinTable::Entry(INPUT_BUTTON_UP)                                   ); // For input primitives...
			ADD_BUILTIN("DOWN_BTN",                                  BuiltinTable::Entry(INPUT_BUTTON_DOWN)                                 );
			ADD_BUILTIN("LEFT_BTN",                                  BuiltinTable::Entry(INPUT_BUTTON_LEFT)                                 );
			ADD_BUILTIN("RIGHT_BTN",                                 BuiltinTable::Entry(INPUT_BUTTON_RIGHT)                                );
			ADD_BUILTIN("A_BTN",                                     BuiltinTable::Entry(INPUT_BUTTON_A)                                    );
			ADD_BUILTIN("B_BTN",                                     BuiltinTable::Entry(INPUT_BUTTON_B)                                    );
			ADD_BUILTIN("SELECT_BTN",                                BuiltinTable::Entry(INPUT_BUTTON_SELECT)                               );
			ADD_BUILTIN("START_BTN",                                 BuiltinTable::Entry(INPUT_BUTTON_START)                                );

			ADD_BUILTIN("TOUCH_BUTTON_0",                            BuiltinTable::Entry(INPUT_MOUSE_BUTTON_0)                              );
			ADD_BUILTIN("TOUCH_BUTTON_ANY",                          BuiltinTable::Entry(INPUT_MOUSE_BUTTON_ANY)                            );
			ADD_BUILTIN("MOUSE_BUTTON_0",                            BuiltinTable::Entry(INPUT_MOUSE_BUTTON_0)                              );
			ADD_BUILTIN("MOUSE_BUTTON_1",                            BuiltinTable::Entry(INPUT_MOUSE_BUTTON_1)                              );
			ADD_BUILTIN("MOUSE_BUTTON_ANY",                          BuiltinTable::Entry(INPUT_MOUSE_BUTTON_ANY)                            );

			// Persistence.
			ADD_BUILTIN("SRAM_ADDRESS",                              BuiltinTable::Entry(SRAM_ADDRESS)                                      ); // For persistence...
			ADD_BUILTIN("FILE_ADDRESS",                              BuiltinTable::Entry(SRAM_OFFSET)                                       ); // For persistence...

			// Serial port.
			ADD_BUILTIN("SERIAL_ERROR",                              BuiltinTable::Entry(SERIAL_ERROR)                                      ); // For serial port and device query...
			ADD_BUILTIN("SERIAL_BUSY",                               BuiltinTable::Entry(SERIAL_BUSY)                                       );
			ADD_BUILTIN("SERIAL_IDLE",                               BuiltinTable::Entry(SERIAL_IDLE)                                       );

			// Scene.
			ADD_BUILTIN("SCENE_MAP_LAYER",                           BuiltinTable::Entry(SCENE_LAYER_MAP)                                   );
			ADD_BUILTIN("SCENE_ATTR_LAYER",                          BuiltinTable::Entry(SCENE_LAYER_ATTR)                                  );
			ADD_BUILTIN("SCENE_PROP_LAYER",                          BuiltinTable::Entry(SCENE_LAYER_PROP)                                  );
			ADD_BUILTIN("SCENE_ACTOR_LAYER",                         BuiltinTable::Entry(SCENE_LAYER_ACTOR)                                 );
			ADD_BUILTIN("SCENE_TRIGGER_LAYER",                       BuiltinTable::Entry(SCENE_LAYER_TRIGGER)                               );
			ADD_BUILTIN("SCENE_DEF_LAYER",                           BuiltinTable::Entry(SCENE_LAYER_DEF)                                   );
			ADD_BUILTIN("SCENE_ALL_LAYERS",                          BuiltinTable::Entry(SCENE_LAYER_ALL)                                   );

			ADD_BUILTIN("CAMERA_SHAKE_X",                            BuiltinTable::Entry(SCENE_CAMERA_SHAKE_X)                              );
			ADD_BUILTIN("CAMERA_SHAKE_Y",                            BuiltinTable::Entry(SCENE_CAMERA_SHAKE_Y)                              );

			// Actor.
			ADD_BUILTIN("ANY_TEMPLATE",                              BuiltinTable::Entry(ACTOR_TEMPLATE_ANY)                                );

			// Controller.
			ADD_BUILTIN("NONE_BEHAVIOUR",                            BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_NONE)                         ); // For controller...
			ADD_BUILTIN("PLATFORMER_PLAYER_BEHAVIOUR",               BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_PLATFORMER_PLAYER)            );
			ADD_BUILTIN("PLATFORMER_MOVE_BEHAVIOUR",                 BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_PLATFORMER_MOVE)              );
			ADD_BUILTIN("PLATFORMER_IDLE_BEHAVIOUR",                 BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_PLATFORMER_IDLE)              );
			ADD_BUILTIN("TOPDOWN_PLAYER_BEHAVIOUR",                  BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_TOPDOWN_PLAYER_ARBITRARY)     );
			ADD_BUILTIN("TOPDOWN_MOVE_BEHAVIOUR",                    BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_TOPDOWN_MOVE_ARBITRARY)       );
			ADD_BUILTIN("TOPDOWN_IDLE_BEHAVIOUR",                    BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_TOPDOWN_IDLE)                 );
			ADD_BUILTIN("POINTNCLICK_PLAYER_BEHAVIOUR",              BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_POINTNCLICK_PLAYER)           );
			ADD_BUILTIN("POINTNCLICK_PLAYER_WITH_MOUSE_BEHAVIOUR",   BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_POINTNCLICK_PLAYER_WITH_MOUSE));
			ADD_BUILTIN("POINTNCLICK_PLAYER_WITH_TOUCH_BEHAVIOUR",   BuiltinTable::Entry(CONTROLLER_BEHAVIOUR_POINTNCLICK_PLAYER_WITH_TOUCH));

			ADD_BUILTIN("MOVABLE_FOR_NONE_FLAG",                     BuiltinTable::Entry(CONTROLLER_MOVABLE_FLAG_NONE)                      );
			ADD_BUILTIN("MOVABLE_FOR_COLLISIONS_FLAG",               BuiltinTable::Entry(CONTROLLER_MOVABLE_FLAG_COLLISIONS)                );
			ADD_BUILTIN("MOVABLE_FOR_FULL_FLAG",                     BuiltinTable::Entry(CONTROLLER_MOVABLE_FLAG_FULL)                      );

			// Projectile.
			ADD_BUILTIN("PROJECTILE_NONE_FLAG",                      BuiltinTable::Entry(PROJECTILE_FLAG_NONE)                              );
			ADD_BUILTIN("PROJECTILE_ANIMATION_NO_LOOP_FLAG",         BuiltinTable::Entry(PROJECTILE_FLAG_ANIMATION_NO_LOOP)                 );
			ADD_BUILTIN("PROJECTILE_STRONG_FLAG",                    BuiltinTable::Entry(PROJECTILE_FLAG_STRONG)                            );

			// Effects.
			ADD_BUILTIN("PULSE_EFFECT",                              BuiltinTable::Entry(EFFECTS_PULSE)                                     ); // For graphics effects...
			ADD_BUILTIN("PARALLAX_EFFECT",                           BuiltinTable::Entry(EFFECTS_PARALLAX)                                  );
			ADD_BUILTIN("WOBBLE_EFFECT",                             BuiltinTable::Entry(EFFECTS_WOBBLE)                                    );

			// Device.
			ADD_BUILTIN("TEXT_MODE",                                 BuiltinTable::Entry(DEVICE_SCREEN_TEXT)                                ); // For screen option...
			ADD_BUILTIN("GRAPHICS_MODE",                             BuiltinTable::Entry(DEVICE_SCREEN_GRAPHICS)                            );
			ADD_BUILTIN("OBJECTS_MODE",                              BuiltinTable::Entry(DEVICE_SCREEN_OBJECTS)                             );

			ADD_BUILTIN("VRAM_BANK0",                                BuiltinTable::Entry(DEVICE_VRAM_USAGE_BANK_0)                          ); // For VRAM option...
			ADD_BUILTIN("VRAM_TILES",                                BuiltinTable::Entry(DEVICE_VRAM_USAGE_TILES)                           );
			ADD_BUILTIN("VRAM_BANK1",                                BuiltinTable::Entry(DEVICE_VRAM_USAGE_BANK_1)                          );
			ADD_BUILTIN("VRAM_ATTRIBUTES",                           BuiltinTable::Entry(DEVICE_VRAM_USAGE_ATTRIBUTES)                      );

			ADD_BUILTIN("ACTIVE_TRIGGERS",                           BuiltinTable::Entry(DEVICE_TRIGGER_ACTIVE_TRIGGERS)                    ); // For both device option and query...

			ADD_BUILTIN("RTC_SEC",                                   BuiltinTable::Entry(DEVICE_RTC_SEC)                                    ); // For both device option and query...
			ADD_BUILTIN("RTC_MIN",                                   BuiltinTable::Entry(DEVICE_RTC_MIN)                                    );
			ADD_BUILTIN("RTC_HR",                                    BuiltinTable::Entry(DEVICE_RTC_HOUR)                                   );
			ADD_BUILTIN("RTC_DAY",                                   BuiltinTable::Entry(DEVICE_RTC_DAY)                                    );

			ADD_BUILTIN("FAST_CPU_ENABLED",                          BuiltinTable::Entry(DEVICE_OPTION_FAST_CPU_ENABLED)                    ); // For device option...
			ADD_BUILTIN("AUTO_UPDATE_ENABLED",                       BuiltinTable::Entry(DEVICE_OPTION_AUTO_UPDATE_ENABLED)                 );
			ADD_BUILTIN("ACTOR_HIT_WITH_DETAILS_ENABLED"  ,          BuiltinTable::Entry(DEVICE_OPTION_ACTOR_HIT_WITH_DETAILS_ENABLED)      );
			ADD_BUILTIN("OBJECT_SPRITE_BASE",                        BuiltinTable::Entry(DEVICE_OPTION_OBJECT_SPRITE_BASE)                  );
			ADD_BUILTIN("SRAM_BANK",                                 BuiltinTable::Entry(DEVICE_OPTION_SRAM_BANK)                           );
			ADD_BUILTIN("SRAM_ENABLED",                              BuiltinTable::Entry(DEVICE_OPTION_SRAM_ENABLED)                        );
			ADD_BUILTIN("VRAM_BANK",                                 BuiltinTable::Entry(DEVICE_OPTION_VRAM_BANK)                           );
			ADD_BUILTIN("VRAM_USAGE",                                BuiltinTable::Entry(DEVICE_OPTION_VRAM_USAGE)                          );
			ADD_BUILTIN("SCREEN_ENABLED",                            BuiltinTable::Entry(DEVICE_OPTION_SCREEN_ENABLED)                      );
			ADD_BUILTIN("SCREEN_MODE",                               BuiltinTable::Entry(DEVICE_OPTION_SCREEN_MODE)                         );
			ADD_BUILTIN("MAP_ENABLED",                               BuiltinTable::Entry(DEVICE_OPTION_MAP_ENABLED)                         );
			ADD_BUILTIN("WINDOW_ENABLED",                            BuiltinTable::Entry(DEVICE_OPTION_WINDOW_ENABLED)                      );
			ADD_BUILTIN("SPRITE_ENABLED",                            BuiltinTable::Entry(DEVICE_OPTION_SPRITE_ENABLED)                      );
			ADD_BUILTIN("SPRITE8x16_ENABLED",                        BuiltinTable::Entry(DEVICE_OPTION_SPRITE8x16_ENABLED)                  );
			ADD_BUILTIN("SOUND_ENABLED",                             BuiltinTable::Entry(DEVICE_OPTION_SOUND_ENABLED)                       );
			ADD_BUILTIN("MUSIC_POSITION",                            BuiltinTable::Entry(DEVICE_OPTION_MUSIC_POSITION)                      );
			ADD_BUILTIN("SERIAL_ENABLED",                            BuiltinTable::Entry(DEVICE_OPTION_SERIAL_ENABLED)                      );
			ADD_BUILTIN("RTC_ENABLED",                               BuiltinTable::Entry(DEVICE_OPTION_RTC_ENABLED)                         );
			ADD_BUILTIN("RTC_START",                                 BuiltinTable::Entry(DEVICE_OPTION_RTC_START)                           );
			ADD_BUILTIN("RTC_LATCH",                                 BuiltinTable::Entry(DEVICE_OPTION_RTC_LATCH)                           );

			ADD_BUILTIN("IS_CGB",                                    BuiltinTable::Entry(DEVICE_QUERY_IS_CGB)                               ); // For device query...
			ADD_BUILTIN("IS_SGB",                                    BuiltinTable::Entry(DEVICE_QUERY_IS_SGB)                               );
			ADD_BUILTIN("IS_AGB",                                    BuiltinTable::Entry(DEVICE_QUERY_IS_AGB)                               );
			ADD_BUILTIN("IS_GBB",                                    BuiltinTable::Entry(DEVICE_QUERY_IS_GBB)                               );
			ADD_BUILTIN("MAX_THREADS",                               BuiltinTable::Entry(DEVICE_QUERY_MAX_THREADS)                          );
			ADD_BUILTIN("ACTIVE_THREADS",                            BuiltinTable::Entry(DEVICE_QUERY_ACTIVE_THREADS)                       );
			ADD_BUILTIN("FREE_THREADS",                              BuiltinTable::Entry(DEVICE_QUERY_FREE_THREADS)                         );
			ADD_BUILTIN("CURRENT_THREAD_ID",                         BuiltinTable::Entry(DEVICE_QUERY_CURRENT_THREAD_ID)                    );
			ADD_BUILTIN("SRAM_BANKS",                                BuiltinTable::Entry(DEVICE_QUERY_SRAM_BANKS)                           );
			ADD_BUILTIN("SRAM_LENGTH",                               BuiltinTable::Entry(DEVICE_QUERY_SRAM_LENGTH)                          );
			ADD_BUILTIN("VRAM_BANKS",                                BuiltinTable::Entry(DEVICE_QUERY_VRAM_BANKS)                           );
			ADD_BUILTIN("MAP_X",                                     BuiltinTable::Entry(DEVICE_QUERY_MAP_X)                                );
			ADD_BUILTIN("MAP_Y",                                     BuiltinTable::Entry(DEVICE_QUERY_MAP_Y)                                );
			ADD_BUILTIN("CAMERA_X",                                  BuiltinTable::Entry(DEVICE_QUERY_CAMERA_X)                             );
			ADD_BUILTIN("CAMERA_Y",                                  BuiltinTable::Entry(DEVICE_QUERY_CAMERA_Y)                             );
			ADD_BUILTIN("MAX_ACTORS",                                BuiltinTable::Entry(DEVICE_QUERY_MAX_ACTORS)                           );
			ADD_BUILTIN("INSTANTIATED_ACTORS",                       BuiltinTable::Entry(DEVICE_QUERY_INSTANTIATED_ACTORS)                  );
			ADD_BUILTIN("FREE_ACTORS",                               BuiltinTable::Entry(DEVICE_QUERY_FREE_ACTORS)                          );
			ADD_BUILTIN("ACTIVE_ACTORS",                             BuiltinTable::Entry(DEVICE_QUERY_ACTIVE_ACTORS)                        );
			ADD_BUILTIN("MAX_PROJECTILES",                           BuiltinTable::Entry(DEVICE_QUERY_MAX_PROJECTILES)                      );
			ADD_BUILTIN("ACTIVE_PROJECTILES",                        BuiltinTable::Entry(DEVICE_QUERY_ACTIVE_PROJECTILES)                   );
			ADD_BUILTIN("FREE_PROJECTILES",                          BuiltinTable::Entry(DEVICE_QUERY_FREE_PROJECTILES)                     );
			ADD_BUILTIN("MAX_TRIGGERS",                              BuiltinTable::Entry(DEVICE_QUERY_MAX_TRIGGERS)                         );
			ADD_BUILTIN("FREE_TRIGGERS",                             BuiltinTable::Entry(DEVICE_QUERY_FREE_TRIGGERS)                        );
			ADD_BUILTIN("SERIAL_STATUS",                             BuiltinTable::Entry(DEVICE_QUERY_SERIAL_STATUS)                        );
			ADD_BUILTIN("SYS_TIME",                                  BuiltinTable::Entry(DEVICE_QUERY_SYS_TIME)                             );
			ADD_BUILTIN("DIV_REG",                                   BuiltinTable::Entry(DEVICE_QUERY_DIV_REG)                              );
			ADD_BUILTIN("PLATFORM_FLAGS",                            BuiltinTable::Entry(DEVICE_QUERY_PLATFORM_FLAGS)                       );
		} while (false);

		// Add the function entries for the compiler.
		// This information is used by the compiler to determine how to
		// generate ASM for basic and advanced functions.
		do {
			// Format: identifier, instruction, parameter count, return value count.

			/**< Basic functions. */

			// Graphics.
			ADD_FUNCTION("color",     FunctionTable::Entry(Asm::Types::COLOR,     3,   0));
			ADD_FUNCTION("plot",      FunctionTable::Entry(Asm::Types::PLOT,      2,   0));
			ADD_FUNCTION("point",     FunctionTable::Entry(Asm::Types::POINT,     2,   1));
			ADD_FUNCTION("line",      FunctionTable::Entry(Asm::Types::LINE,      4,   0));

			// Audio.
			ADD_FUNCTION("stop",      FunctionTable::Entry(Asm::Types::STOP,      0,   0));

			// Input.
			ADD_FUNCTION("btn",       FunctionTable::Entry(Asm::Types::BTN,       1,   1));
			ADD_FUNCTION("btnd",      FunctionTable::Entry(Asm::Types::BTND,      1,   1));
			ADD_FUNCTION("btnu",      FunctionTable::Entry(Asm::Types::BTNU,      1,   1));

			// Persistence.
			ADD_FUNCTION("fopen",     FunctionTable::Entry(Asm::Types::FOPEN,     1,   1));
			ADD_FUNCTION("fclose",    FunctionTable::Entry(Asm::Types::FCLOSE,    1,   1));
			ADD_FUNCTION("fread",     FunctionTable::Entry(Asm::Types::FREAD,     2,   1));
			ADD_FUNCTION("fwrite",    FunctionTable::Entry(Asm::Types::FWRITE,    3,   1));

			// Serial port.
			ADD_FUNCTION("sread",     FunctionTable::Entry(Asm::Types::SREAD,     1,   1));
			ADD_FUNCTION("swrite",    FunctionTable::Entry(Asm::Types::SWRITE,    2,   1));

			// Debug.
			ADD_FUNCTION("dbginfo",   FunctionTable::Entry(Asm::Types::DBGINFO,   1,   0));

			/**< Advanced functions. */

			// Scene.
			ADD_FUNCTION("camera",    FunctionTable::Entry(Asm::Types::CAMERA,    2,   0));

			// Device.
			ADD_FUNCTION("option",    FunctionTable::Entry(Asm::Types::OPTION,    2,   1));
			ADD_FUNCTION("query",     FunctionTable::Entry(Asm::Types::QUERY,     1,   1));
		} while (false);

		// Add the operator entries for the compiler.
		// This information is used by the compiler to determine how to
		// generate opcode for operators.
		do {
			// Format: identifier, opcode, parameters, function-like.

			/**< Operators. */

			// `a OP b` or `OP a`.
			ADD_OPERATOR("+",        OperatorTable::Entry(Op::Types::ADD,              2,   false));
			ADD_OPERATOR("-",        OperatorTable::Entry(Op::Types::SUB,              2,   false));
			ADD_OPERATOR("*",        OperatorTable::Entry(Op::Types::MUL,              2,   false));
			ADD_OPERATOR("/",        OperatorTable::Entry(Op::Types::DIV,              2,   false));
			ADD_OPERATOR("mod",      OperatorTable::Entry(Op::Types::MOD,              2,   false));
			ADD_OPERATOR("=",        OperatorTable::Entry(Op::Types::EQ,               2,   false));
			ADD_OPERATOR("<",        OperatorTable::Entry(Op::Types::LT,               2,   false));
			ADD_OPERATOR("<=",       OperatorTable::Entry(Op::Types::LE,               2,   false));
			ADD_OPERATOR(">",        OperatorTable::Entry(Op::Types::GT,               2,   false));
			ADD_OPERATOR(">=",       OperatorTable::Entry(Op::Types::GE,               2,   false));
			ADD_OPERATOR("<>",       OperatorTable::Entry(Op::Types::NE,               2,   false));
			ADD_OPERATOR("and",      OperatorTable::Entry(Op::Types::AND,              2,   false));
			ADD_OPERATOR("or",       OperatorTable::Entry(Op::Types::OR,               2,   false));
			ADD_OPERATOR("not",      OperatorTable::Entry(Op::Types::NOT,              1,   false));
			ADD_OPERATOR("band",     OperatorTable::Entry(Op::Types::BITWISE_AND,      2,   false));
			ADD_OPERATOR("bor",      OperatorTable::Entry(Op::Types::BITWISE_OR,       2,   false));
			ADD_OPERATOR("bxor",     OperatorTable::Entry(Op::Types::BITWISE_XOR,      2,   false));
			ADD_OPERATOR("bnot",     OperatorTable::Entry(Op::Types::BITWISE_NOT,      1,   false));
			ADD_OPERATOR("lshift",   OperatorTable::Entry(Op::Types::BITWISE_LSHIFT,   2,   false));
			ADD_OPERATOR("rshift",   OperatorTable::Entry(Op::Types::BITWISE_RSHIFT,   2,   false));
			ADD_OPERATOR(NEGATIVE,   OperatorTable::Entry(Op::Types::NEG,              1,   false));

			// Function-like `OP(...)`.
			ADD_OPERATOR("sgn",      OperatorTable::Entry(Op::Types::SGN,              1,    true));
			ADD_OPERATOR("abs",      OperatorTable::Entry(Op::Types::ABS,              1,    true));
			ADD_OPERATOR("sqr",      OperatorTable::Entry(Op::Types::SQR,              1,    true));
			ADD_OPERATOR("sqrt",     OperatorTable::Entry(Op::Types::SQRT,             1,    true));
			ADD_OPERATOR("sin",      OperatorTable::Entry(Op::Types::SIN,              1,    true));
			ADD_OPERATOR("cos",      OperatorTable::Entry(Op::Types::COS,              1,    true));
			ADD_OPERATOR("atan2",    OperatorTable::Entry(Op::Types::ATAN2,            2,    true));
			ADD_OPERATOR("pow",      OperatorTable::Entry(Op::Types::POWI,             2,    true));
			ADD_OPERATOR("min",      OperatorTable::Entry(Op::Types::MIN,              2,    true));
			ADD_OPERATOR("max",      OperatorTable::Entry(Op::Types::MAX,              2,    true));
		} while (false);

		// Finish.
		#undef ADD_STATEMENT
		#undef ADD_BUILTIN
		#undef ADD_FUNCTION
		#undef ADD_OPERATOR
	}

	Statement* addStatement(const std::string &name, Statement::Handler func, Token::Types type, bool returned) {
		const std::pair<StatementDictionary::iterator, bool> ret = _statements.insert(std::make_pair(name, Statement(func, type, returned)));
		GBBASIC_ASSERT(ret.second && "Failed to add statement.");
		if (!ret.second)
			return nullptr;

		if (returned)
			_statementsWithReturned.push_back(name);

		return &ret.first->second;
	}
	const StatementDictionary &statements(void) const {
		return _statements;
	}
	const Text::Array &statementsWithReturned(void) const {
		return _statementsWithReturned;
	}

	const Token::Array &tokens(void) const {
		return _tokens;
	}
	const Node::Ptr &ast(void) const {
		return _ast;
	}
	int linesOfCode(void) const {
		return _linesOfCode;
	}
	void linesOfCode(int val) {
		_linesOfCode = val;
	}
	int lineNumberWidth(void) const {
		return _lineNumberWidth;
	}

	bool process(
		const std::string &src, int page,
		Node::Context::Array &array,
		Node::Context::Data &data,
		BuiltinTable &builtins,
		const FunctionTable &functions,
		const OperatorTable &operators,
		Node::MacroAliasTable::Stack &macroAliases,
		Node::MacroFunctionTable::Stack &macroFunctions,
		Node::MacroConstantTable::Stack &macroConstants,
		Node::MacroIdentifierAliasTable::Stack &macroIdentifierAliases,
		Node::MacroStackReferenceTable::Stack &macroStackReferences,
		Macro::List &macros,
		const Macros &builtinMacros,
		Error::Handler onError
	) {
		// Prepare.
		_tokens.clear();
		_ast = nullptr;

		int errorCount = 0;
		Error::Handler gotError = [&] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
			if (!err.isWarning)
				++errorCount;
			onError(err, msg, loc);
		};

		// Preprocess, linearize, tokenize, sort and parse the source code.
		const std::string code     = preprocess(src);
		const Text::Array lines    = linearize(code, _lineNumberWidth, _options);
		const Token::Matrix lined  = tokenize(lines, page, _statements, _options, gotError);
		_tokens                    = sort(lined, gotError);
		_ast                       = parse(
			                             _tokens, page,
			                             _statements, _statementsWithReturned,
			                             _stackArguments,
			                             array, data,
			                             builtins, functions, operators,
			                             macroAliases,
			                             macroFunctions,
			                             macroConstants,
			                             macroIdentifierAliases,
			                             macroStackReferences,
			                             macros,
			                             builtinMacros,
			                             _options,
			                             gotError
			                         );
		_linesOfCode              += (int)lines.size();

		// Finish.
		return errorCount == 0;
	}

private:
	static std::string preprocess(const std::string &src) {
		// Prepare.
		std::string result = src;

		// Uniform new line characters to '\n'.
		result = Text::replace(result, "\r\n", "\n");
		result = Text::replace(result, "\r", "\n");

		// Finish.
		return result;
	}
	static Text::Array linearize(const std::string &src, int &lineNumberWidth, const Options &options) {
		// Prepare.
		Text::Array result;

		// Split the source code into code lines.
		const Text::Array lines = Text::split(src, "\n", false);

		bool completeLineNumber = options.completeLineNumber;
		if (completeLineNumber) {
			int lineNumberCount = 0;
			for (int i = 0; i < (int)lines.size(); ++i) {
				const std::string &ln = lines[i];
				const Text::Array parts = Text::split(ln, " ", false);
				if (parts.empty())
					continue;

				const std::string &head = parts.front();
				int lno = 0;
				if (Text::fromString(head, lno)) {
					++lineNumberCount;
				} else {
					if (i == (int)lines.size() - 1 && lines.size() > 1)
						++lineNumberCount; // Ignore the last line if it doesn't have line number.
				}
			}
			completeLineNumber = lineNumberCount != (int)lines.size();
		}

		if (completeLineNumber) {
			lineNumberWidth = 2 + 8 + 1;
			for (int i = 0; i < (int)lines.size(); ++i) {
				std::string ln = lines[i];
				ln = "0x" + Text::toHex(i + 1) + " " + ln;
				result.push_back(ln);
			}
		} else {
			for (const std::string &ln : lines)
				result.push_back(ln);
		}

		// Finish.
		return result;
	}
	static Token::Matrix tokenize(const Text::Array &lines, int page, const StatementDictionary &functions, const Options &options, Error::Handler onError) {
		// Prepare.
		enum class States {
			NORMAL,
			COMMENT,
			STRING
		};

		typedef Either<std::string, Text::Array> EitherStringOrArray;

		const std::string NEWLINE           = "\n";
		const std::string SPACE             = " \t";
		const std::string PAGE              = "#";
		const std::string PAGE_NUMBER       = "0123456789";
		const std::string COMMENT           = "\'";
		const std::string COMMENT_REM       = "rem";
		const std::string OPERATOR          = "()[]<>=+-*/,;:";
		const Text::Array OPERATORS         = {
			"<", "<=", ">", ">=", "<>",
			"(", ")", "[", "]",
			"=", "+", "-", "*", "/",
			",", ";", ":"
		};
		const std::string DOLLAR            = "$";
		const Text::Array NUMBER_EXPONENT   = { "e", "E" };
		const Text::Array NUMBER            = { "0123456789", "0123456789+-.eExXabcdefABCDEF" };
		const std::string DOUBLE_QUOTE      = "\"";
		Text::Array SYMBOLS;
		for (const StatementDictionary::value_type &kv : functions)
			SYMBOLS.push_back(kv.first);

		Token::Matrix result;
		TextLocation location(page);
		States state = States::NORMAL;
		Token::Ptr node = nullptr;
		Token::Ptr prev = nullptr;
		if (result.empty())
			result.push_back(Token::Array());

		// Token operations.
		auto is = [&] (Token::Types y) -> bool {
			// Check whether the current token matches the specific type.
			return node != nullptr && node->type() == y;
		};
		auto isNot = [&] (Token::Types y) -> bool {
			// Check whether the current token doesn't match the specific type.
			return node == nullptr || node->type() != y;
		};
		auto has = [&] (const std::string &part) -> bool {
			// Check whether the current token contains the specific text.
			if (node == nullptr)
				return false;

			return Text::indexOf(node->text(), part) != std::string::npos;
		};

		auto was = [&] (Token::Types y) -> bool {
			// Check whether the last token matches the specific type.
			if (result.empty() || result.back().empty())
				return false;
			const Token::Ptr &tk = result.back().back();

			return tk != nullptr && tk->type() == y;
		};
		auto pop = [&] (void) -> void {
			// Pop the last token if there's any.
			if (result.empty() || result.back().empty())
				return;

			result.back().pop_back();
		};

		auto seal = [&] (void) -> void {
			// Prepare.
			if (node == nullptr)
				return;

			// Complete the current token.
			node
				->end(TextLocation(location))
				->parse(options.caseInsensitive);

			// Determine its detail type.
			do {
				// Check for function.
				if (node->is(Token::Types::SYMBOL)) {
					StatementDictionary::const_iterator it = functions.find(node->text());
					if (it != functions.end()) {
						const Statement &func = it->second;
						node->type(func.type); // Reappoint the token's type according to the statement definition.

						break;
					}
				}

				// Check for identifier.
				if (node->is(Token::Types::SYMBOL)) {
					if (node->text() == "true") {
						node->type(Token::Types::BOOLEAN); // Reappoint the token's type as boolean.
						node->data(true);
					} else if (node->text() == "false") {
						node->type(Token::Types::BOOLEAN); // Reappoint the token's type as boolean.
						node->data(false);
					} else if (node->text() == "_") {
						node->type(Token::Types::LINE_CONNECTOR); // Reappoint the token's type as line connector.
					} else {
						node->type(Token::Types::IDENTIFIER); // Reappoint the token's type as identifier.
					}

					break;
				}

				// Check for number.
				if (node->is(Token::Types::NUMBER)) {
					Word val = 0;
					if (!validate<Word, UWord>(node, val, onError)) // Validate the token's data.
						node->data(val);

					break;
				}
			} while (false);

			// Finish.
			node = nullptr;
		};
		auto token = [&] (Token::Types y) -> Token::Ptr { // Create a new token with the specific type.
			// Seal the last token.
			if (node != nullptr) {
				--location.column;
				seal();
				++location.column;
			}

			if (!result.back().empty())
				prev = result.back().back();

			// Create a new token.
			node = Token::Ptr(new Token());
			node
				->type(y)
				->begin(TextLocation(location));

			// Process the new token.
			const bool wasLineConnector = was(Token::Types::LINE_CONNECTOR);
			const bool isConnectedLineNumber = wasLineConnector && GBBASIC::is(y, Token::Types::NUMBER);
			const bool isConnectedComment = wasLineConnector && GBBASIC::is(y, Token::Types::COMMENT);
			if (isConnectedLineNumber) {
				// Pop the last `LINE_CONNECTOR`, do not push the line number.
				pop();
			} else if (isConnectedComment) {
				// Do not push the comment.
				// Do nothing.
			} else {
				// Push the token.
				result.back().push_back(node);
			}

			// Push a new line.
			if (GBBASIC::is(y, Token::Types::END_OF_LINE))
				result.push_back(Token::Array());

			// Finish.
			return node;
		};

		// Tokenizes one line.
		auto tokenizeLine = [&] (const std::string &ln) -> void {
			// Prepare.
			int cursor = 0;

			// Traverse source code.
			typedef std::function<int(const std::string &, const std::string &, int, bool)> Traverser;
			auto next = [&] (int n) -> void {
				// Move the text cursor to the next location.
				location.column += n;
				cursor += n;
			};
			auto anyway = [&] (const std::string &txt, const EitherStringOrArray &what, int offset, bool caseInsensitive, Traverser match) -> bool {
				// Check whether the former or latter text matches the specific pattern.
				if (what.isLeft())
					return !!match(txt, what.left().get(), offset, caseInsensitive);

				for (const std::string &what_ : what.right().get()) {
					if (!!match(txt, what_, offset, caseInsensitive))
						return true;
				}

				return false;
			};
			auto forward = [&] (const std::string &txt, const EitherStringOrArray &what, int offset, bool caseInsensitive) -> int {
				// Check whether the latter text matches the specific pattern.
				return anyway(
					txt, what, offset, caseInsensitive,
					[] (const std::string &txt, const std::string &what, int offset, bool caseInsensitive) -> int {
						if (offset < 0 || offset + (int)what.length() > (int)txt.length())
							return 0;
						for (int i = 0; i < (int)what.length(); ++i) {
							const char left = what[i];
							const char right = txt[offset + i];
							if (caseInsensitive) {
								if (tolower(left) != tolower(right))
									return 0;
							} else {
								if (left != right)
									return 0;
							}
						}

						return (int)what.length();
					}
				);
			};
			auto backward = [&] (const std::string &txt, const EitherStringOrArray &what, int offset, bool caseInsensitive) -> int {
				// Check whether the former text matches the specific pattern.
				return anyway(
					txt, what, offset, caseInsensitive,
					[] (const std::string &txt, const std::string &what, int offset, bool caseInsensitive) -> int {
						if (offset < 0 || offset + 1 - (int)what.length() < 0)
							return 0;
						for (int i = 0; i < (int)what.length(); ++i) {
							const char left = what[i];
							const char right = txt[offset + 1 - (int)what.length() + i];
							if (caseInsensitive) {
								if (tolower(left) != tolower(right))
									return 0;
							} else {
								if (left != right)
									return 0;
							}
						}

						return (int)what.length();
					}
				);
			};

			// Generic matching.
			auto contains = [] (const EitherStringOrArray &pattern, const std::string &what) -> bool {
				if (pattern.isLeft())
					return Text::indexOf(pattern.left().get(), what) != std::string::npos;

				const Text::Array patterns = pattern.right().get();

				return std::find(patterns.begin(), patterns.end(), what) != patterns.end();
			};

			// Character calculation and operation.
			auto isSymbolic = [] (const std::string &ch) -> bool {
				constexpr const char* _D = "$",             // $.
					                * _ = "_",              // _.
					                * _0 = "0", * _9 = "9", // 0 - 9.
					                * A = "A",  * Z = "Z",  // A - Z.
					                * a = "a",  * z = "z";  // a - z.
				if (ch == _D)
					return true;
				if (ch == _)
					return true;
				if (ch >= _0 && ch <= _9)
					return true;
				if (ch >= A && ch <= Z)
					return true;
				if (ch >= a && ch <= z)
					return true;
				if (ch.size() > 1) // Is a UTF-8 character.
					return true;

				return false;
			};

			// Unicode symbols.
			const Codepoint::Collection UNICODE_SYMBOLS = Codepoint::UNICODE_SYMBOLS();

			// Traverse through all the characters.
			while (cursor < (int)ln.length()) {
				// Take a character.
				int n = Unicode::expectUtf8(ln.c_str() + cursor);
				if (n == 0) {
					const char ch = ln[cursor];
					const Error err("Invalid character \"{0}\"", false);
					onError(err, err.format({ Text::toString(ch) }), location);

					break;
				}
				std::string ch;
				for (int i = 0; i < n; ++i)
					ch += ln[cursor + i];
				std::string chlow = ch;
				Text::toLowerCase(chlow);

				const int n1 = Unicode::expectUtf8(ln.c_str() + cursor + n);
				std::string ch1;
				std::string chlow1;
				if (n1 > 0) {
					for (int i = 0; i < n1; ++i)
						ch1 += ln[cursor + n + i];
					chlow1 = ch1;
					Text::toLowerCase(chlow1);
				}

				// Determine where to go.
				if (state == States::NORMAL) { // Is parsing normal token.
					if (UNICODE_SYMBOLS.has(ch)) {
						// Met Unicode symbols that could not be a part of an identifier.
						const Error err("Unexpected UTF-8 character \"{0}\"", false);
						onError(err, err.format({ ch }), location);

						break;
					} else if (ch == COMMENT) {
						// Met `'` comment; transport to comment state.
						state = States::COMMENT;

						token(Token::Types::COMMENT);
					} else if (Text::startsWith(COMMENT_REM, chlow, options.caseInsensitive) && forward(ln, EitherStringOrArray(Left<std::string>(COMMENT_REM)), cursor, options.caseInsensitive)) {
						// Met `REM` comment; transport to comment state.
						state = States::COMMENT;

						token(Token::Types::COMMENT);

						node->add(COMMENT_REM);

						next((int)COMMENT_REM.length());

						continue;
					} else if (ch == DOUBLE_QUOTE) {
						// Met `"`; transport to string state.
						state = States::STRING;

						token(Token::Types::STRING);

						node->add(DOUBLE_QUOTE);
					} else {
						// Determine the character's ascribing.
						Token::Types met = Token::Types::NONE;
						if (contains(EitherStringOrArray(Left<std::string>(SPACE)), ch)) {
							// Met space.
							if (isNot(Token::Types::SPACE)) {
								seal();
							}

							met = Token::Types::SPACE;
						} else if (isNot(Token::Types::PAGE) && ch == PAGE) {
							// Met page.
							token(Token::Types::PAGE);

							node->add(ch);

							met = Token::Types::PAGE;
						} else if (is(Token::Types::PAGE) && contains(EitherStringOrArray(Left<std::string>(PAGE_NUMBER)), ch)) {
							// Met page number.
							node->add(ch);

							met = Token::Types::PAGE;
						} else if (is(Token::Types::SYMBOL) && isSymbolic(ch)) {
							// Met symbol; proceed later.
							// Do nothing.
						} else if (
							isNot(Token::Types::NUMBER) &&
							(
								backward(ln, EitherStringOrArray(Left<std::string>(std::string("+"))), cursor - 1, false) ||
								backward(ln, EitherStringOrArray(Left<std::string>(std::string("-"))), cursor - 1, false)
							) &&
							!(prev && (
								(prev->is(Token::Types::OPERATOR) && prev->data() == ")") ||
								(prev->is(Token::Types::IDENTIFIER | Token::Types::BOOLEAN | Token::Types::NUMBER))
							))
						) {
							// Met `+`, `-`; now it could be determined that
							// the previous `+`, `-` is a part of a positive/negative number.
							node->type(Token::Types::NUMBER);
							node->add(ch);

							met = Token::Types::NUMBER;
						} else if (
							isNot(Token::Types::NUMBER) &&
							contains(EitherStringOrArray(Left<std::string>(NUMBER[0])), ch)
						) {
							// Met number; start a number.
							token(Token::Types::NUMBER);

							node->add(ch);

							met = Token::Types::NUMBER;
						} else if (
							is(Token::Types::NUMBER) &&
							contains(EitherStringOrArray(Left<std::string>(NUMBER[1])), ch)
						) {
							// Met number; the current character is a part of the current number token.
							if (
								(ch == "+" || ch == "-") &&
								!backward(ln, EitherStringOrArray(Right<Text::Array>(NUMBER_EXPONENT)), cursor - 1, false)
							) {
								// Do nothing.
							} else if (ch == "." && has(".")) {
								// Do nothing.
							} else {
								node->add(ch);

								met = Token::Types::NUMBER;
							}
						}

						// Further determination.
						if (GBBASIC::is(met, Token::Types::ANY)) {
							// Already handled above.
							// Do nothing.
						} else if (contains(EitherStringOrArray(Left<std::string>(OPERATOR)), ch)) {
							// Met operator.
							if (is(Token::Types::SYMBOL) && ch == ":") {
								// Met `:`; the token should be a destination label.
								Token::Ptr node_ = node;
								node->add(ch);
								seal();
								node_->type(Token::Types::LABEL);

								met = Token::Types::LABEL;
							} else {
								// The token should be an operator.
								if (isNot(Token::Types::OPERATOR)) {
									token(Token::Types::OPERATOR);

									node->add(ch);
								} else {
									if (!contains(EitherStringOrArray(Right<Text::Array>(OPERATORS)), node->text() + ch)) {
										token(Token::Types::OPERATOR);
									}

									node->add(ch);
								}

								met = Token::Types::OPERATOR;
							}
						} else if (isSymbolic(ch)) {
							// Met symbol.
							if (isNot(Token::Types::SYMBOL) && !contains(EitherStringOrArray(Left<std::string>(NUMBER[0])), ch)) {
								token(Token::Types::SYMBOL);

								node->add(ch);

								met = Token::Types::SYMBOL;
							} else if (is(Token::Types::SYMBOL)) {
								if (Text::endsWith(node->text(), DOLLAR, options.caseInsensitive)) {
									const Error err("Unexpected character \"{0}\"", false);
									onError(err, err.format({ ch }), location); // The $ character is expected to occur at the end of a symbol.

									break;
								} else {
									node->add(ch);

									met = Token::Types::SYMBOL;
								}
							} else {
								const Error err("Unexpected character \"{0}\"", false);
								onError(err, err.format({ ch }), location);

								break;
							}
						} else {
							// Met an unexpected character.
							const Error err("Invalid character \"{0}\"", false);
							onError(err, err.format({ ch }), location);

							break;
						}
					}
				} else if (state == States::COMMENT) { // Is parsing comment.
					// Take whatever it met, until the end of this line.
					node->add(ch);
				} else if (state == States::STRING) { // Is parsing string.
					if (ch == "\\" && ch1 == "\"") { // Is an escaped double quote.
						// Append a double quote.
						node->add(DOUBLE_QUOTE);

						n += n1;
					} else if (ch == "\\" && ch1 == "\\") { // Is an escaped backslash.
						// Append a non-escaped backslash.
						// It will escape later.
						node->add("\\");
						node->add("\\");

						n += n1;
					} else if (ch == DOUBLE_QUOTE) { // Is a literal double quote
						// Finish the string, transport to normal state.
						state = States::NORMAL;

						node->add(DOUBLE_QUOTE);

						seal();
					} else { // Is a regular character.
						// Append a character to the string.
						node->add(ch);
					}
				}

				// Next step.
				next(n);
			}

			// Finish.
			switch (state) {
			case States::COMMENT:
				state = States::NORMAL;

				// Fall through.
			default:
				--location.column;
				seal();
				++location.column;

				break;
			}
		};

		// Tokenizes all the lines.
		for (const std::string &ln : lines) {
			tokenizeLine(ln);

			if (state != States::NORMAL) {
				const Error err("Incomplete code line", false);
				onError(err, err.format(), location);

				break;
			}

			if (was(Token::Types::LINE_CONNECTOR)) {
				// Do not append `END_OF_LINE` if the last token was a `LINE_CONNECTOR`.
				// Do nothing.
			} else {
				token(Token::Types::END_OF_LINE);
				node->add(NEWLINE);
				seal();
			}

			++location.row;
			location.column = 0;
		}

		// Finish.
		location = TextLocation(page, 0, 0);
		state = States::NORMAL;

		return result;
	}
	static Token::Array sort(const Token::Matrix &lined, Error::Handler onError) {
		// Prepare.
		typedef std::map<int, int> OrderedByLineNumber;

		Token::Array result;
		OrderedByLineNumber ordered;

		// Iterate the tokens.
		for (int i = 0; i < (int)lined.size(); ++i) {
			const Token::Array &line = lined[i];
			if (line.empty())
				continue;

			const Token::Ptr &tk = line.front();
			if (tk->is(Token::Types::END_OF_LINE))
				continue;

			if (tk->isNot(Token::Types::INTEGER)) {
				const Error err("Line number expected", false);
				onError(err, err.format(), tk->begin());

				return result;
			}
			const int lnno = (int)tk->data();
			if (lnno <= 0) {
				const Error err("Invalid line number \"{0}\"", false);
				onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());

				return result;
			}
			const std::pair<OrderedByLineNumber::iterator, bool> ret = ordered.insert(std::make_pair(lnno, i));
			if (!ret.second) {
				const Error err("Duplicate line number \"{0}\"", false);
				onError(err, err.format({ tk->caseSensitiveText() }), tk->begin());

				return result;
			}
		}

		// Construct the ordered tokens.
		for (const OrderedByLineNumber::value_type &kv : ordered) {
			const Token::Array &line = lined[kv.second];
			for (const Token::Ptr &tk : line)
				result.push_back(tk);
		}

		// Finish.
		return result;
	}
	static Node::Ptr parse(
		const Token::Array &tokens, int page,
		const StatementDictionary &statements, const Text::Array &returned,
		const Text::Array &stackArguments,
		Node::Context::Array &array,
		Node::Context::Data &data,
		BuiltinTable &builtins,
		const FunctionTable &functions,
		const OperatorTable &operators,
		Node::MacroAliasTable::Stack &macroAliases,
		Node::MacroFunctionTable::Stack &macroFunctions,
		Node::MacroConstantTable::Stack &macroConstants,
		Node::MacroIdentifierAliasTable::Stack &macroIdentifierAliases,
		Node::MacroStackReferenceTable::Stack &macroStackReferences,
		Macro::List &macros,
		const Macros &builtinMacros,
		const Options &options,
		Error::Handler onError_
	) {
		/**< Prepare. */

		// Prepare.
		int cursor = 0;

		Text::Array structures;

		IdentifierTable identifiers;

		IDictionary::Ptr opts(Dictionary::create({
			{ "page", page }
		}));
		Node::Ptr ast(new NodePage());
		ast->options(opts);

		// Define builtin macros.
		for (Macros::value_type kv : builtinMacros) {
			std::string name = kv.first;
			Text::toLowerCase(name);
			const Variant &data_ = kv.second;
			const int val = (int)data_;

			Token::Ptr tk(new Token());
			tk
				->type(Token::Types::INTEGER)
				->data(val)
				->text(Text::toString(val));

			macroConstants.add(name, Node::MacroConstantTable::Entry(tk, val)); // Add to the macro constant table.
			const Macro macro(name, Macro::Types::CONSTANT, val, TextLocation::INVALID());
			macros.push_back(macro); // Add to the exposable macro list.
		}

		/**< Processors. */

		// AST traversers.
		auto begin = [&] (void) -> State {
			// Begin a parsing state.
			return State(cursor);
		};
		auto end = [&] (const State &q) -> void {
			// End a parsing state.
			if (!q.success)
				return;

			cursor = q.index;
		};
		auto next = [&] (State &q) -> Token::Ptr {
			// Move the cursor to the next token.
			if (q.index >= (int)tokens.size())
				return nullptr;

			const Token::Ptr &tk = tokens[q.index];

			++q.index;

			return tk;
		};

		auto between = [&] (int beginIdx, int endIdx) -> Token::Array {
			Token::Array result;
			for (int i = beginIdx; i <= endIdx; ++i) {
				if (i < 0 || i >= (int)tokens.size())
					continue;

				const Token::Ptr &tk = tokens[i];
				result.push_back(tk);
			}

			return result;
		};

		auto backwardN = [&] (int n, Token::Types y, Variant d = nullptr) -> auto {
			GBBASIC_ASSERT(n > 0 && "Wrong data.");

			// Return a function which checks `n` steps backward for whether it matches the specific pattern,
			// where `n` starts from 1.
			return [&, n, y, d] (int index_) -> Token::Ptr {
				const int index = index_ - n;
				if (index < 0 || index >= (int)tokens.size())
					return nullptr;

				const Token::Ptr &tk = tokens[index];
				if (tk->isNot(y))
					return nullptr;
				if (d == ANYTHING)
					return tk;
				if (d != nullptr && tk->data() != d)
					return nullptr;

				return tk;
			};
		};
		auto backward = [&] (Token::Types y, Variant d = nullptr) -> auto {
			// Return a function which checks 1 steps backward for whether it matches the specific pattern.
			return backwardN(1, y, d);
		};
		auto forwardN = [&] (int n, Token::Types y, Variant d = nullptr) -> auto {
			GBBASIC_ASSERT(n >= 0 && "Wrong data.");

			// Return a function which checks `n` steps forward for whether it matches the specific pattern,
			// where `n` starts from 1.
			return [&, n, y, d] (int index_) -> Token::Ptr {
				const int index = index_ + n - 1;
				if (index < 0 || index >= (int)tokens.size())
					return nullptr;

				const Token::Ptr &tk = tokens[index];
				if (tk->isNot(y))
					return nullptr;
				if (d == ANYTHING)
					return tk;
				if (d != nullptr && tk->data() != d)
					return nullptr;

				return tk;
			};
		};
		auto forward = [&] (Token::Types y, Variant d = nullptr) -> auto {
			// Return a function which checks 1 steps forward for whether it matches the specific pattern.
			return forwardN(1, y, d);
		};
		auto must = [&] (Token::Types y, Variant d = nullptr) -> auto {
			// Expect a token that matches the specific pattern, move the cursor to the next location if matched,
			// otherwise return `nullptr`.
			return [&, y, d] (State &q) -> Token::Ptr {
				if (q.index >= (int)tokens.size())
					return nullptr;

				const Token::Ptr &tk = tokens[q.index];
				if (tk->isNot(y))
					return nullptr;
				if (d == ANYTHING)
					return tk;
				if (d != nullptr && tk->data() != d)
					return nullptr;

				q.tokens.push_back(tk);
				++q.index;

				return tk;
			};
		};
		auto maybe = [&] (Token::Types y, Variant d = nullptr) -> auto {
			// Expect a token that matches the specific pattern, move the cursor to the next location despite it matched or not.
			return [&, y, d] (State &q) -> Token::Ptr {
				if (q.index >= (int)tokens.size())
					return nullptr;

				const Token::Ptr &tk = tokens[q.index];
				if (tk->is(y) && (d == nullptr || tk->data() == d)) {
					q.tokens.push_back(tk);
					++q.index;
				}

				return tk;
			};
		};
		auto any = [&] (void) -> auto {
			// Expect a token in any form, move the cursor to the next location.
			return [&] (State &q) -> Token::Ptr {
				if (q.index >= (int)tokens.size())
					return nullptr;

				const Token::Ptr &tk = tokens[q.index];
				q.tokens.push_back(tk);
				++q.index;

				return tk;
			};
		};
		auto ignore = [&] (Token::Types y, Variant d = nullptr) -> auto {
			// Ignore a token if it matches the specific pattern, return `true` for matched,
			// otherwise `false`.
			return [&, y, d] (State &q) -> Token::Ptr {
				Token::Ptr tk = forward(y, d)(q.index);
				if (!tk)
					return nullptr;

				next(q);

				return tk;
			};
		};
		auto stop = [forwardN] (const Lexical::List &stops, int index, int n = 1) -> bool {
			Lexical::List::const_iterator it = std::find_if(
				stops.begin(), stops.end(),
				[forwardN, index, n] (const Lexical &word) -> bool {
					if (!forwardN(n, word.type0, word.data0)(index))
						return false;

					if (is(word.type1, Token::Types::ANY)) {
						if (!forwardN(n + 1, word.type1, word.data1)(index))
							return false;
					}

					return true;
				}
			);

			return it != stops.end();
		};

		// Node processors.
		typedef std::stack<TextLocation> TextLocationStack;

		TextLocationStack scopeHeads;
		auto beginDef = [&] (int idx) -> auto {
			return [&, idx] (void) -> void {
				macroAliases.push();
				macroFunctions.push();
				macroConstants.push();
				macroIdentifierAliases.push();
				macroStackReferences.push();
				if (idx >= 0 && idx < (int)tokens.size()) {
					const Token::Ptr &tk = tokens[idx];
					const TextLocation &loc = tk->begin();
					scopeHeads.push(loc);
				}
			};
		};
		auto endDef = [&] (int idx) -> auto {
			return [&, idx] (void) -> void {
				if (idx >= 0 && idx < (int)tokens.size()) {
					const Token::Ptr &tk = tokens[idx];
					const TextLocation &loc = tk->end();
					for (Macro &macro : macros) {
						if (!macro.scopeLocationRange.first.invalid() && macro.scopeLocationRange.second.invalid())
							macro.scopeLocationRange.second = loc;
					}
					if (!scopeHeads.empty())
						scopeHeads.pop();
				}
				macroAliases.pop();
				macroFunctions.pop();
				macroConstants.pop();
				macroIdentifierAliases.pop();
				macroStackReferences.pop();
			};
		};
		auto headOfCurrentScope = [&] (void) -> TextLocation {
			if (scopeHeads.empty())
				return TextLocation::INVALID();

			return scopeHeads.top();
		};
		auto beginStructure = [&] (const std::string &keyword) -> auto {
			return [&, keyword] (void) -> void {
				structures.push_back(keyword);
			};
		};
		auto endStructure = [&] (void) -> auto {
			return [&] (void) -> void {
				structures.pop_back();
			};
		};
		auto isLoopStructure = [&] (const std::string &keyword) -> bool {
			for (Text::Array::reverse_iterator it = structures.rbegin(); it != structures.rend(); ++it) {
				if (keyword == ANYTHING) {
					if (*it == "for" || *it == "while" || *it == "repeat")
						return true;
				} else {
					if (*it == keyword)
						return true;
				}
			}

			return false;
		};
		auto tooManyNestedStructures = [&] (void) -> bool {
			if (structures.size() > NESTED_STRUCTURE_MAX_COUNT)
				return true;

			return false;
		};
		auto createNode = [&] (const std::string &keyword, const Variant &id, const Dictionary::Arguments &args) -> Node::Ptr {
			IDictionary::Ptr opts(Dictionary::create(args));
			const bool allowCall = (bool)opts->get("allow_call");

			Node::Ptr node = nullptr;
			if (id == nullptr) {
				if (allowCall) {
					node = Node::Ptr(new NodeCall());
				} else {
					GBBASIC_ASSERT(false && "Not implemented.");
				}
			} else {
				std::string key = keyword;
				if (key == "math")
					key = (std::string)id;
				StatementDictionary::const_iterator it = statements.find(key);
				if (it == statements.end()) {
					if (allowCall) {
						node = Node::Ptr(new NodeCall());
					} else {
						GBBASIC_ASSERT(false && "Not implemented.");
					}
				} else {
					const Statement &function = it->second;
					if (function.handler)
						node = function.handler(&function);
				}
			}

			if (node)
				node->options(opts);

			return node;
		};

		// Error handling.
		int warnings = 0;
		int errors = 0;
		Error::Handler onError = [onError_, &warnings, &errors] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
			if (err.isWarning)
				++warnings;
			else
				++errors;
			onError_(err, msg, loc);
		};

		auto throwError = [&] (const char* const msg, int index, bool isWaning) -> bool {
			Token::Ptr tk = tokens[index];
			if (tk->is(Token::Types::END_OF_LINE)) {
				const int index_ = index - 1;
				if (index_ >= 0 && index_ < (int)tokens.size())
					tk = tokens[index_];
			}
			const Error err(msg, isWaning);
			onError(err, err.format(), tk->begin());

			return false;
		};
		auto throwDataInsideStructureAlwaysTakesEffectOnceAndOnlyOnce = [&] (int index, const std::string &struct_) -> bool {
			const std::string msg = Text::format("Data inside structure \"{0}\" always takes effect once and only once", { struct_ });

			return throwError(msg.c_str(), index, true);
		};
		auto throwDataSectionOverflow = [&] (int index) -> bool {
			return throwError("Data section overflow", index, false);
		};
		auto throwFillerInsideStructureAlwaysTakesEffectOnceAndOnlyOnce = [&] (int index, const std::string &struct_) -> bool {
			const std::string msg = Text::format("Filler inside structure \"{0}\" always takes effect once and only once", { struct_ });

			return throwError(msg.c_str(), index, true);
		};
		auto throwIdHasBeenAlreadyDeclared = [&] (int index, const std::string &name) -> bool {
			const std::string msg = Text::format("ID \"{0}\" has been already decleared", { name });

			return throwError(msg.c_str(), index, false);
		};
		auto throwIdHasNotBeenDeclared = [&] (int index, const std::string &name) -> bool {
			const std::string msg = Text::format("ID \"{0}\" has not been decleared", { name });

			return throwError(msg.c_str(), index, false);
		};
		auto throwIncompleteStructure = [&] (int index) -> bool {
			return throwError("Incomplete structure", index, false);
		};
		auto throwInvalidSyntax = [&] (int index) -> bool {
			return throwError("Invalid syntax", index, false);
		};
		auto throwLoopExpected = [&] (int index) -> bool {
			return throwError("Loop expected", index, false);
		};
		auto throwNotImplemented = [&] (int index) -> bool {
			return throwError("Not implemented", index, false);
		};
		auto throwTooFewArguments = [&] (int index) -> bool {
			return throwError("Too few arguments", index, false);
		};
		auto throwTooManyArguments = [&] (int index) -> bool {
			return throwError("Too many arguments", index, false);
		};
		auto throwTooManyDimensions = [&] (int index) -> bool {
			return throwError("Too many dimensions", index, false);
		};
		auto throwTooManyNestedStructures = [&] (int index) -> bool {
			return throwError("Too many nested structures", index, false);
		};
		auto throwUnexpectedComma = [&] (int index) -> bool {
			return throwError("Unexpected comma", index, false);
		};

		auto idHasBeenDefined = [&] (const std::string &name) -> bool {
			if (builtins.find(name))
				return true;
			if (functions.find(name))
				return true;
			if (operators.find(name))
				return true;

			if (macroAliases.find(name, 1 /* local only */))
				return true;
			if (macroFunctions.find(name, 1 /* local only */))
				return true;
			if (macroConstants.find(name, 1 /* local only */))
				return true;
			if (macroIdentifierAliases.find(name, 1 /* local only */))
				return true;
			if (macroStackReferences.find(name, 1 /* local only */))
				return true;

			return false;
		};

		int unexpectedCommas = 0;
		#define CHECK_UNEXPECTED(Q) \
			do { \
				if (unexpectedCommas > 0) { \
					unexpectedCommas = 0; \
					return throwUnexpectedComma((Q).index); \
				} \
			} while (false);

		/**< Combinators. */

		// Stops.
		const Lexical::List EVALUATION_STOPS = {
			Lexical(Token::Types::KEYWORD,     ANYTHING),
			Lexical(Token::Types::OPERATOR,    "["),
			Lexical(Token::Types::OPERATOR,    "]"),
			Lexical(Token::Types::OPERATOR,    ","),
			Lexical(Token::Types::OPERATOR,    ";")
		};
		const Lexical::List IF_STOPS = {
			Lexical(Token::Types::KEYWORD,     "else"),
			Lexical(Token::Types::KEYWORD,     "elseif"),
				Lexical(Token::Types::KEYWORD, "else", Token::Types::KEYWORD, "if"),
			Lexical(Token::Types::KEYWORD,     "endif"),
				Lexical(Token::Types::KEYWORD, "end", Token::Types::KEYWORD, "if")
		};
		const Lexical::List SELECT_STOPS = {
			Lexical(Token::Types::KEYWORD,     "case"),
			Lexical(Token::Types::KEYWORD,     "else"),
			Lexical(Token::Types::KEYWORD,     "endselect"),
				Lexical(Token::Types::KEYWORD, "end", Token::Types::KEYWORD, "select")
		};
		const Lexical::List FOR_STOPS = {
			Lexical(Token::Types::KEYWORD,     "next")
		};
		const Lexical::List WHILE_STOPS = {
			Lexical(Token::Types::KEYWORD,     "wend"),
				Lexical(Token::Types::KEYWORD, "end", Token::Types::KEYWORD, "while")
		};
		const Lexical::List REPEAT_STOPS = {
			Lexical(Token::Types::KEYWORD,     "until")
		};
		const Lexical::List BEGINDO_STOPS = {
			Lexical(Token::Types::KEYWORD,     "enddo"),
				Lexical(Token::Types::KEYWORD, "end", Token::Types::KEYWORD, "do")
		};
		const Lexical::List BEGINDEF_STOPS = {
			Lexical(Token::Types::KEYWORD,     "enddef"),
				Lexical(Token::Types::KEYWORD, "end", Token::Types::KEYWORD, "def")
		};

		// Sub combinators.
		std::function<int(State &, Node::Array &)> Evaluation  = nullptr;

		auto LineNumber = [&] (State &q, const Combinator::Options &opts, int* lnno = nullptr) -> bool { // Line number.
			if (lnno)
				*lnno = -1;

			Token::Ptr tk = nullptr;
			if (opts.mustHaveLineNumber) {
				tk = must(Token::Types::INTEGER)(q);
				if (!tk)
					return false;
			} else {
				tk = maybe(Token::Types::INTEGER)(q);
			}
			if (tk) {
				if (lnno)
					*lnno = (int)tk->data();
			}

			return true;
		};
		auto EndOfLine = [&] (State &q) -> bool { // End of line.
			const bool hasComment = !!ignore(Token::Types::COMMENT)(q);
			(void)hasComment;
			ignore(Token::Types::END_OF_LINE)(q);

			return true;
		};
		auto Arguments = [&] (State &q, Node::Array &children) -> int { // Arguments separated by commas.
			int n = 0;
			unexpectedCommas = -1;
			for (EVER) {
				State q1 = begin();
				q1.index = q.index;
				Node::Array children_;

				if (!Evaluation(q1, children_)) {
					if (unexpectedCommas != -1) {
						if (forward(Token::Types::KEYWORD, "read")(q1.index) || forward(Token::Types::KEYWORD, "data")(q1.index))
							--unexpectedCommas;
					}

					break;
				}

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				exp->add(children_);
				children.push_back(exp);

				++n;

				if (unexpectedCommas == -1)
					unexpectedCommas = 1;
				--unexpectedCommas;

				if (forward(Token::Types::OPERATOR, ",")(q1.index)) {
					++unexpectedCommas;

					++q1.index;

					q1.success = true;
					end(q1);
					q.index = q1.index;
				} else {
					q1.success = true;
					end(q1);
					q.index = q1.index;

					break;
				}
			}

			return n;
		};
		auto References = [&] (State &q, Node::Array &children) -> int { // References separated by commas.
			int n = 0;
			unexpectedCommas = -1;
			for (EVER) {
				State q1 = begin();
				q1.index = q.index;

				if (!must(Token::Types::OPERATOR)(q1)) break;

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				children.push_back(exp);

				++n;

				if (unexpectedCommas == -1)
					unexpectedCommas = 1;
				--unexpectedCommas;

				if (forward(Token::Types::OPERATOR, ",")(q1.index)) {
					++unexpectedCommas;

					++q1.index;

					q1.success = true;
					end(q1);
					q.index = q1.index;
				} else {
					q1.success = true;
					end(q1);
					q.index = q1.index;

					break;
				}
			}

			return n;
		};
		auto Parameters = [&] (State &q, Node::Array &children) -> int { // Parameters separated by commas.
			int n = 0;
			unexpectedCommas = -1;
			for (EVER) {
				State q1 = begin();
				q1.index = q.index;

				if (!maybe(Token::Types::IDENTIFIER)(q1)) break;

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				children.push_back(exp);

				++n;

				if (unexpectedCommas == -1)
					unexpectedCommas = 1;
				--unexpectedCommas;

				if (forward(Token::Types::OPERATOR, ",")(q1.index)) {
					++unexpectedCommas;

					++q1.index;

					q1.success = true;
					end(q1);
					q.index = q1.index;
				} else {
					q1.success = true;
					end(q1);
					q.index = q1.index;

					break;
				}
			}

			return n;
		};
		auto ParametersOrNumbers = [&] (State &q, Node::Array &children) -> int { // Parameters separated by commas.
			int n = 0;
			unexpectedCommas = -1;
			for (EVER) {
				State q1 = begin();
				q1.index = q.index;

				if (forward(Token::Types::IDENTIFIER)(q1.index)) any()(q1);
				else if (forward(Token::Types::NUMBER)(q1.index)) any()(q1);
				else break;

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				children.push_back(exp);

				++n;

				if (unexpectedCommas == -1)
					unexpectedCommas = 1;
				--unexpectedCommas;

				if (forward(Token::Types::OPERATOR, ",")(q1.index)) {
					++unexpectedCommas;

					++q1.index;

					q1.success = true;
					end(q1);
					q.index = q1.index;
				} else {
					q1.success = true;
					end(q1);
					q.index = q1.index;

					break;
				}
			}

			return n;
		};
		auto Numbers = [&] (State &q, Node::Array &children, std::function<void(const Token::Ptr &)> iterater) -> int { // Numbers.
			int n = 0;
			unexpectedCommas = -1;
			for (EVER) {
				State q1 = begin();
				q1.index = q.index;

				if (!maybe(Token::Types::NUMBER)(q1)) break;

				if (!q1.tokens.empty()) {
					const Token::Ptr tk = q1.tokens.front();
					if (iterater)
						iterater(tk);
				}

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				children.push_back(exp);

				++n;

				if (unexpectedCommas == -1)
					unexpectedCommas = 1;
				--unexpectedCommas;

				if (forward(Token::Types::OPERATOR, ",")(q1.index)) {
					++unexpectedCommas;

					++q1.index;

					q1.success = true;
					end(q1);
					q.index = q1.index;
				} else {
					q1.success = true;
					end(q1);
					q.index = q1.index;

					break;
				}
			}

			return n;
		};
		auto TypedNumbers = [&] (State &q, Node::Array &children, std::function<void(const Token::Ptr &, const Token::Ptr &)> iterater) -> int { // Numbers with optional types.
			int n = 0;
			unexpectedCommas = -1;
			for (EVER) {
				State q1 = begin();
				q1.index = q.index;

				if (must(Token::Types::NUMBER)(q1)) {
					// Do nothing.
				} else if (must(Token::Types::KEYWORD, "int")(q1)) {
					if (must(Token::Types::OPERATOR, "(")(q1)) {
						if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
							if (!maybe(Token::Types::NUMBER)(q1)) break;
						}
						if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
					} else {
						if (!maybe(Token::Types::NUMBER)(q1)) break;
					}
				} else {
					break;
				}

				if (!q1.tokens.empty()) {
					if (q1.tokens.size() == 1) {
						const Token::Ptr tk = q1.tokens.front();
						if (iterater)
							iterater(tk, nullptr);
					} else if (q1.tokens.size() == 4) {
						const Token::Ptr tk = q1.tokens[2];
						const Token::Ptr tky = q1.tokens[0];
						if (iterater)
							iterater(tk, tky);
					} else {
						GBBASIC_ASSERT(false && "Impossible.");
					}
				}

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				children.push_back(exp);

				++n;

				if (unexpectedCommas == -1)
					unexpectedCommas = 1;
				--unexpectedCommas;

				if (forward(Token::Types::OPERATOR, ",")(q1.index)) {
					++unexpectedCommas;

					++q1.index;

					q1.success = true;
					end(q1);
					q.index = q1.index;
				} else {
					q1.success = true;
					end(q1);
					q.index = q1.index;

					break;
				}
			}

			return n;
		};
		auto DataSequence = [&] (State &q, Node::Array &children) -> bool { // `DATA` sequence.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;

			if (!TypedNumbers(q1, children_, [&] (const Token::Ptr &tkval, const Token::Ptr &tktype) -> void {
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER);

				Token::IntegerTypes y = typeOf(tktype);
				int val = 0;
				switch (y) {
				case Token::IntegerTypes::UNSPECIFIED:
					validate<Int8, UInt8>(tkval, val, onError);
					node
						->data(val)
						->details().integerType = Token::IntegerTypes::UNSPECIFIED;

					break;
				case Token::IntegerTypes::INT:
					validate<Word, UWord>(tkval, val, onError);
					node
						->data(val)
						->details().integerType = Token::IntegerTypes::INT;

					break;
				default:
					GBBASIC_ASSERT(false && "Not implemented.");

					break;
				}

				Node::Ptr exp(new NodeExpression());
				exp->concat(node);
				children.push_back(exp);
			})) return false;
			CHECK_UNEXPECTED(q1);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto Expression = [&] (State &q, Node::Array &children) -> bool { // Expression.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;

			if (!Evaluation(q1, children_)) return false;

			Node::Ptr exp(new NodeExpression());
			exp->concat(q1.tokens);
			exp->add(children_);
			children.push_back(exp);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto Range = [&] (State &q, Node::Array &children) -> bool { // Range, for `SELECT CASE`.
			State q1 = begin();
			q1.index = q.index;

			State q2 = begin();
			q2.index = q1.index;
			Node::Array children_;
			if (!Evaluation(q2, children_)) return false;
			Node::Ptr exp0(new NodeExpression());
			exp0->concat(q2.tokens);
			exp0->add(children_);
			q1.index = q2.index;

			q2 = begin();
			q2.index = q1.index;
			children_.clear();
			if (!must(Token::Types::KEYWORD, "to")(q2)) return false;
			for (Token::Ptr &tk : q2.tokens)
				q1.tokens.push_back(tk);
			q1.index = q2.index;

			q2 = begin();
			q2.index = q1.index;
			children_.clear();
			if (!Evaluation(q2, children_)) return false;
			Node::Ptr exp1(new NodeExpression());
			exp1->concat(q2.tokens);
			exp1->add(children_);
			q1.index = q2.index;

			children.push_back(exp0);
			children.push_back(exp1);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};

		auto Math = [&] (State &q, Node::Array &children) -> bool { // Math operation.
			Token::Ptr id = nullptr;
			std::string name;
			Node::Array children_;

			if (!(id = must(Token::Types::OPERATOR)(q))) return false;
			else name = (std::string)id->data();
			if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
			Arguments(q, children_);
			CHECK_UNEXPECTED(q);
			if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);

			Node::Ptr node = createNode(
				"math", name,
				{
					{ "allow_call", false }
				}
			);
			if (!node) return false;
			node->concat(q.tokens);
			node->add(children_);
			children.push_back(node);

			q.success = true;
			end(q);

			return true;
		};
		auto Rnd = [&] (State &q, Node::Array &children) -> bool { // `RND` statement.
			Node::Array children_;

			if (!must(Token::Types::OPERATOR, "rnd")(q)) return false;
			if (forward(Token::Types::OPERATOR, "(")(q.index)) {
				if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
				Arguments(q, children_);
				CHECK_UNEXPECTED(q);
				if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
			}

			Node::Ptr node = createNode(
				"math", "rnd",
				{
					{ "allow_call", false }
				}
			);
			if (!node) return false;
			node->concat(q.tokens);
			node->add(children_);
			children.push_back(node);

			q.success = true;
			end(q);

			return true;
		};
		auto ArrayR = [&] (State &q, Node::Array &children) -> bool { // Array reading.
			Token::Ptr id = nullptr;
			std::string name;
			Node::Array children_;

			if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
			else name = (std::string)id->data();
			const int r = q.index;
			if (!must(Token::Types::OPERATOR, "[")(q)) return throwInvalidSyntax(q.index);
			Arguments(q, children_);
			CHECK_UNEXPECTED(q);
			if (!must(Token::Types::OPERATOR, "]")(q)) return throwInvalidSyntax(q.index);

			const Node::MacroIdentifierAliasTable::Entry* idAlias = macroIdentifierAliases.find(name); // FEAT: MACRO.
			if (idAlias) {
				const std::string idName = idAlias->name;
				const IdentifierTable::Entry* idEntry = identifiers.find(idName);
				if (!idEntry)
					return throwIdHasNotBeenDeclared(r, idName);
				if (idEntry->type != IdentifierTable::Entry::Types::DIM)
					return throwInvalidSyntax(r);

				id->data(idName);
			}

			Node::Ptr node = createNode(
				"=[...]", "_",
				{
					{ "allow_call", false }
				}
			);
			if (!node) return false;
			node->concat(q.tokens);
			node->add(children_);
			children.push_back(node);

			q.success = true;
			end(q);

			return true;
		};
		auto LenR = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Length reading.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "get")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (name == "tile" || name == "actor" || name == "projectile") {
				if (forward(Token::Types::KEYWORD, "len")(q1.index)) {
					any()(q1);
				}
				if (!must(Token::Types::OPERATOR, "(")(q1)) return throwInvalidSyntax(q1.index);
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
				if (!must(Token::Types::OPERATOR, ")")(q1)) return throwInvalidSyntax(q1.index);
			}
			{
				const int n = (int)children_.size();
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER)
					->data(n);
				q1.tokens.push_back(node);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto Invoking = [&] (State &q, Node::Array &children, bool expEol) -> bool { // An invoking sequence.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (must(Token::Types::OPERATOR, "(")(q1)) {
				if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
					Arguments(q1, children_);
					CHECK_UNEXPECTED(q1);
				}
				if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
			} else {
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto MacroFn = [&] (State &q, Node::Array &children, const std::string &name) -> bool { // Macro for `FN`.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;

			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			if (must(Token::Types::OPERATOR, "(")(q1)) {
				if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
					Arguments(q1, children_);
					CHECK_UNEXPECTED(q1);
				}
				if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
			} else {
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
			}

			Node::Ptr node = createNode(
				"fn", name,
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto MacroConstant = [&] (State &q, Node::Array &children, const std::string &name) -> bool { // Macro for constant.
			(void)children;

			State q1 = begin();
			q1.index = q.index;
			Token::Ptr id = nullptr;

			if (!(id = must(Token::Types::IDENTIFIER)(q1))) return false;

			const Node::MacroConstantTable::Entry* constant = macroConstants.find(name); // FEAT: MACRO.
			GBBASIC_ASSERT(constant && "Impossible.");
			{
				const Token::Ptr &tk = constant->constant;
				q.tokens.push_back(tk);
			}

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto MacroIdentifierAlias = [&] (State &q, Node::Array &children, const std::string &name) -> bool { // Macro for variable alias.
			(void)children;

			State q1 = begin();
			q1.index = q.index;
			Token::Ptr id = nullptr;

			if (!(id = must(Token::Types::IDENTIFIER)(q1))) return false;

			const Node::MacroIdentifierAliasTable::Entry* idAlias = macroIdentifierAliases.find(name); // FEAT: MACRO.
			GBBASIC_ASSERT(idAlias && "Impossible.");
			{
				const Token::Ptr &tk = idAlias->alias;
				q.tokens.push_back(tk);
			}

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto MacroStackN = [&] (State &q, Node::Array &children, const std::string &name) -> bool { // Macro for `STACKN`.
			State q1 = begin();
			q1.index = q.index;
			Token::Ptr id = nullptr;

			if (!(id = must(Token::Types::IDENTIFIER)(q1))) return false;

			const Node::MacroStackReferenceTable::Entry* stackNRef = macroStackReferences.find(name); // FEAT: MACRO.
			GBBASIC_ASSERT(stackNRef && "Impossible.");
			{
				const std::string key = "stack" + Text::toString(stackNRef->index);
				Token::Array tokens_;
				tokens_.push_back(stackNRef->alias);

				Node::Ptr node = createNode(
					"math", key,
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(tokens_);
				children.push_back(node);
			}

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto StackN = [&] (State &q, Node::Array &children, int index) -> bool { // `STACKN` statement.
			const std::string key = "stack" + Text::toString(index);

			if (!must(Token::Types::OPERATOR, key)(q)) return false;
			if (forward(Token::Types::OPERATOR, "(")(q.index)) return throwInvalidSyntax(q.index);

			Node::Ptr node = createNode(
				"math", key,
				{
					{ "allow_call", false }
				}
			);
			if (!node) return false;
			node->concat(q.tokens);
			children.push_back(node);

			q.success = true;
			end(q);

			return true;
		};
		auto SizeR = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Size reading.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "get")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (name == "map" || name == "window" || name == "scene" || name == "actor" || name == "projectile") {
				if (forward(Token::Types::KEYWORD, "width")(q1.index)) {
					any()(q1);
				} else if (forward(Token::Types::KEYWORD, "height")(q1.index)) {
					any()(q1);
				}
				if (!must(Token::Types::OPERATOR, "(")(q1)) return throwInvalidSyntax(q1.index);
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
				if (!must(Token::Types::OPERATOR, ")")(q1)) return throwInvalidSyntax(q1.index);
			}
			{
				const int n = (int)children_.size();
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER)
					->data(n);
				q1.tokens.push_back(node);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto TileR = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Tile reading.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "get")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (name == "map" || name == "window" || name == "sprite") {
				if (!must(Token::Types::OPERATOR, "(")(q1)) return throwInvalidSyntax(q1.index);
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
				if (!must(Token::Types::OPERATOR, ")")(q1)) return throwInvalidSyntax(q1.index);
			}
			{
				const int n = (int)children_.size();
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER)
					->data(n);
				q1.tokens.push_back(node);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto PropertyR = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Property reading.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "get")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (name == "sprite" || name == "scene" || name == "actor") {
				if (forward(Token::Types::KEYWORD, "property")(q1.index)) {
					any()(q1);
				}
				if (!must(Token::Types::OPERATOR, "(")(q1)) return throwInvalidSyntax(q1.index);
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
				if (!must(Token::Types::OPERATOR, ")")(q1)) return throwInvalidSyntax(q1.index);
			}
			{
				const int n = (int)children_.size();
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER)
					->data(n);
				q1.tokens.push_back(node);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto ObjectF = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Object finding.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "find")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (name == "actor") {
				if (!must(Token::Types::OPERATOR, "(")(q1)) return throwInvalidSyntax(q1.index);
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
				if (!must(Token::Types::OPERATOR, ")")(q1)) return throwInvalidSyntax(q1.index);
			}
			{
				const int n = (int)children_.size();
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER)
					->data(n);
				q1.tokens.push_back(node);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto ObjectS = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Object starting.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "start")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (name == "projectile") {
				if (!must(Token::Types::OPERATOR, "(")(q1)) return throwInvalidSyntax(q1.index);
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
				if (!must(Token::Types::OPERATOR, ")")(q1)) return throwInvalidSyntax(q1.index);
			}
			{
				const int n = (int)children_.size();
				Token::Ptr node(new Token());
				node
					->type(Token::Types::INTEGER)
					->data(n);
				q1.tokens.push_back(node);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto Is = [&] (State &q, Node::Array &children, bool expEol) -> bool { // Object type determination.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;

			if (Parameters(q1, children_) != 1) return false;
			CHECK_UNEXPECTED(q1);
			if (!must(Token::Types::KEYWORD, "is")(q1)) return false;
			if (!must(Token::Types::KEYWORD)(q1)) return false;
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				"is", "_",
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto New = [&] (State &q, Node::Array &children) -> bool { // `NEW` statement.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!must(Token::Types::KEYWORD, "new")(q1)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (must(Token::Types::OPERATOR, "(")(q1)) {
				if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
					Arguments(q1, children_);
					CHECK_UNEXPECTED(q1);
				}
				if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
			} else {
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
			}
			maybe(Token::Types::OPERATOR, ";")(q1);
			if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);

			Node::Ptr node = createNode(
				"new", id->data(),
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto Start = [&] (State &q, Node::Array &children, bool expEol, bool inplace) -> bool { // Start a thread.
			State q1 = begin();
			q1.index = q.index;
			Node::Array children_;
			Token::Ptr id = nullptr;
			std::string name;

			if (!(id = must(Token::Types::SYMBOL)(q1))) return false;
			else name = (std::string)id->data();
			if (must(Token::Types::OPERATOR, "(")(q1)) {
				if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
					Arguments(q1, children_);
					CHECK_UNEXPECTED(q1);
				}
				if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
			} else {
				Arguments(q1, children_);
				CHECK_UNEXPECTED(q1);
			}
			if (expEol) {
				maybe(Token::Types::OPERATOR, ";")(q1);
				if (!EndOfLine(q1)) return throwInvalidSyntax(q1.index);
			}

			Node::Ptr node = createNode(
				name, id->data(),
				{
					{ "allow_call", true },
					{ "inplace_join", inplace }
				}
			);
			if (!node) return false;
			node->concat(q1.tokens);
			node->add(children_);
			children.push_back(node);

			q1.success = true;
			end(q1);
			q.index = q1.index;

			return true;
		};
		auto Hits = [&] (State &q, Node::Array &children) -> bool { // `HITS` statement.
			Token::Ptr id = nullptr;
			std::string name;
			Node::Array children_;

			if (!must(Token::Types::OPERATOR, "hits")(q)) return false;
			if (!(id = must(Token::Types::SYMBOL)(q))) return false;
			else name = (std::string)id->data();
			if (name == "rect" || name == "point") {
				State q1 = begin();
				q1.index = q.index;
				Node::Array children__;

				q.transfer(q1);
				if (must(Token::Types::OPERATOR, "(")(q1)) {
					if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
						Arguments(q1, children__);
						CHECK_UNEXPECTED(q1);
					}
					if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
				} else {
					Arguments(q1, children__);
					CHECK_UNEXPECTED(q1);
				}

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				exp->add(children__);
				children_.push_back(exp);

				q1.success = true;
				end(q1);
				q.index = q1.index;
			} else {
				return throwInvalidSyntax(q.index);
			}
			if (!ignore(Token::Types::OPERATOR, ",")(q)) return throwInvalidSyntax(q.index);
			if (!(id = must(Token::Types::SYMBOL)(q))) return false;
			else name = (std::string)id->data();
			if (name == "rect" || name == "point") {
				State q1 = begin();
				q1.index = q.index;
				Node::Array children__;

				q.transfer(q1);
				if (must(Token::Types::OPERATOR, "(")(q1)) {
					if (!forward(Token::Types::OPERATOR, ")")(q1.index)) {
						Arguments(q1, children__);
						CHECK_UNEXPECTED(q1);
					}
					if (!must(Token::Types::OPERATOR, ")")(q1)) return false;
				} else {
					Arguments(q1, children__);
					CHECK_UNEXPECTED(q1);
				}

				Node::Ptr exp(new NodeExpression());
				exp->concat(q1.tokens);
				exp->add(children__);
				children_.push_back(exp);

				q1.success = true;
				end(q1);
				q.index = q1.index;
			} else {
				return throwInvalidSyntax(q.index);
			}

			Node::Ptr node = createNode(
				"hits", "_",
				{
					{ "allow_call", true }
				}
			);
			if (!node) return false;
			node->concat(q.tokens);
			node->add(children_);
			children.push_back(node);

			q.success = true;
			end(q);

			return true;
		};

		Evaluation = [&] (State &q, Node::Array &children) -> int { // An evaluable sequence.
			int n = 0;
			int c = 0;
			int s = 0;
			for (EVER) {
				Token::Ptr id = nullptr;
				std::string name;
				if ((id = forward(Token::Types::OPERATOR)(q.index))) {
					name = (std::string)id->data();
					const int stackN = Text::indexOf(stackArguments, name);
					if (name == ",") {
						// Do nothing.
					} else if (name == "-") { // Check negative operator.
						const Token::Ptr lastTk = backward(Token::Types::ANY)(q.index);
						std::string lastData;
						if (lastTk)
							lastData = (std::string)lastTk->data();
						const bool isNeg = !lastTk ||                    // No previous token, or
						(
							lastTk->isNot(Token::Types::NUMBER) &&       // was not a number, and
							lastTk->isNot(Token::Types::SYMBOL) && (     // was not a symbol, and
								lastTk->isNot(Token::Types::OPERATOR) || // was not an operator, or
								(lastData != ")" && lastData != "]")     // was a `)` or `]` operator,
							)
						);                                               // then this is a negative operator.
						if (isNeg) { // Is a unary negative operator.
							Token::Ptr node(new Token());
							node
								->type(Token::Types::OPERATOR)
								->data(NEGATIVE); // Negative.
							q.tokens.push_back(node);
							++q.index;

							any()(q);
							++n;

							continue;
						}
					} else if (name == "rnd") { // `RND` is a specialized math function, which accepts 0, 1 or 2 arguments.
						State q1 = begin();
						q1.index = q.index;

						if (Rnd(q1, children)) {
							{
								Token::Ptr node(new Token());
								node
									->type(Token::Types::MATH)
									->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
								q.tokens.push_back(node);
								n += q1.index - q.index;
							}

							q1.success = true;
							end(q1);
							q.index = q1.index;

							continue;
						}
					} else if (stackN != -1) { // `STACKN` is a specialized function, which does not expect braces.
						State q1 = begin();
						q1.index = q.index;

						if (StackN(q1, children, stackN)) {
							{
								Token::Ptr node(new Token());
								node
									->type(Token::Types::MATH)
									->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
								q.tokens.push_back(node);
								n += q1.index - q.index;
							}

							q1.success = true;
							end(q1);
							q.index = q1.index;

							continue;
						}
					} else if (name == "hits") { // `HITS` is a specialized function, which accepts `RECT` or `POINT` as arguments.
						State q1 = begin();
						q1.index = q.index;

						if (Hits(q1, children)) {
							{
								Token::Ptr node(new Token());
								node
									->type(Token::Types::MATH)
									->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
								q.tokens.push_back(node);
								n += q1.index - q.index;
							}

							q1.success = true;
							end(q1);
							q.index = q1.index;

							continue;
						}
					} else { // An operator.
						const OperatorTable::Entry* entry = operators.find(name);
						if (entry && entry->isFunctionLike) { // Is a function-like operator, i.e. `ABS(...)`.
							State q1 = begin();
							q1.index = q.index;

							if (Math(q1, children)) {
								{
									Token::Ptr node(new Token());
									node
										->type(Token::Types::MATH)
										->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
									q.tokens.push_back(node);
									n += q1.index - q.index;
								}

								q1.success = true;
								end(q1);
								q.index = q1.index;

								continue;
							}
						}
					}
				}
				if ((id = forward(Token::Types::SYMBOL)(q.index))) {
					name = (std::string)id->data();
					Text::Array::const_iterator it = std::find(returned.begin(), returned.end(), name);
					if (it != returned.end()) { // Statement with return value.
						const int qi = q.index;
						if (Invoking(q, children, false)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					const Node::MacroAliasTable::Entry* aliasEntry = nullptr;
					do {
						aliasEntry = macroAliases.find(name); // FEAT: MACRO.
						if (aliasEntry)
							name = aliasEntry->name; // Interpret as original macro.
					} while (aliasEntry);
					const Node::MacroFunctionTable::Entry* fnEntry = macroFunctions.find(name); // FEAT: MACRO.
					if (fnEntry) { // User defined macro function.
						const int qi = q.index;
						if (MacroFn(q, children, name)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::MACRO)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					const Node::MacroConstantTable::Entry* constEntry = macroConstants.find(name); // FEAT: MACRO.
					if (constEntry) { // User defined macro constant.
						const int qi = q.index;
						if (MacroConstant(q, children, name)) {
							n += q.index - qi;

							continue;
						}
					}
					const Node::MacroIdentifierAliasTable::Entry* idAliasEntry = macroIdentifierAliases.find(name); // FEAT: MACRO.
					if (idAliasEntry) { // User defined variable alias.
						const bool isArray =
							!!forwardN(2, Token::Types::OPERATOR, "[")(q.index);
						const int qi = q.index;
						if (!isArray) {
							if (MacroIdentifierAlias(q, children, name)) {
								n += q.index - qi;

								continue;
							}
						}
					}
					const Node::MacroStackReferenceTable::Entry* stackRefEntry = macroStackReferences.find(name); // FEAT: MACRO.
					if (stackRefEntry) { // User defined stack reference.
						const int qi = q.index;
						if (MacroStackN(q, children, name)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::MATH)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "get") { // Width or height getting.
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "map")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "window")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "scene")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "actor")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "projectile")(q.index);
						const bool size =
							!!forwardN(3, Token::Types::KEYWORD, "width")(q.index) ||
							!!forwardN(3, Token::Types::KEYWORD, "height")(q.index);
						const int qi = q.index;
						if (targets && size && SizeR(q, children, false)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "get") { // Length getting.
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "tile")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "actor")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "projectile")(q.index);
						const bool len = !!forwardN(3, Token::Types::KEYWORD, "len")(q.index);
						const int qi = q.index;
						if (targets && len && LenR(q, children, false)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "get") { // Property getting.
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "sprite")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "scene")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "actor")(q.index);
						const bool prop = !!forwardN(3, Token::Types::KEYWORD, "property")(q.index);
						const int qi = q.index;
						if (targets && prop && PropertyR(q, children, false)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "get") { // Tile getting.
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "map")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "window")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "sprite")(q.index);
						const bool prop = !!forwardN(3, Token::Types::KEYWORD, "property")(q.index);
						const int qi = q.index;
						if (targets && !prop && TileR(q, children, false)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "find") {
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "actor")(q.index);
						const int qi = q.index;
						if (targets && ObjectF(q, children, false)) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "start") {
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "projectile")(q.index);
						const int qi = q.index;
						if (targets && ObjectS(q, children, false)) { // Projectile.
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "start") {
						const bool threaded =
							!!forwardN(0, Token::Types::KEYWORD, "join")(q.index);
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "actor")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "projectile")(q.index);
						const int qi = q.index;
						if (threaded && !targets && Start(q, children, false, true)) { // Thread.
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
					if (name == "is") { // Object type determination.
						const bool targets =
							!!forwardN(2, Token::Types::KEYWORD, "actor")(q.index) ||
							!!forwardN(2, Token::Types::KEYWORD, "projectile")(q.index);
						const int qi = q.index;
						if (targets && Is(q, children, false)) { // Macro before, type after.
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
				}
				if ((id = forwardN(2, Token::Types::SYMBOL)(q.index))) {
					name = (std::string)id->data();
					if (name == "is") { // Object type determination.
						const bool targets =
							!!forwardN(3, Token::Types::KEYWORD, "actor")(q.index) ||
							!!forwardN(3, Token::Types::KEYWORD, "projectile")(q.index);
						const int qi = q.index;
						if (targets && Is(q, children, false)) { // Variable before, type after.
							Token::Ptr node(new Token());
							node
								->type(Token::Types::STATEMENT)
								->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
							q.tokens.push_back(node);
							n += q.index - qi;

							continue;
						}
					}
				}
				if ((id = forward(Token::Types::SYMBOL)(q.index))) {
					name = (std::string)id->data();
					const bool isArray = !!forwardN(2, Token::Types::OPERATOR, "[")(q.index);
					if (isArray) { // `=[...]` (array reading).
						State q1 = begin();
						q1.index = q.index;

						if (ArrayR(q1, children)) {
							{
								Token::Ptr node(new Token());
								node
									->type(Token::Types::ARRAY)
									->data((Variant::Int)children.size() - 1); // The data is the intermedia value's index.
								q.tokens.push_back(node);
								n += q1.index - q.index;
							}

							q1.success = true;
							end(q1);
							q.index = q1.index;

							continue;
						}
					}
				}

				if (forward(Token::Types::COMMENT)(q.index)) {
					break;
				} else if (forward(Token::Types::END_OF_LINE)(q.index)) {
					break;
				} else if (c == 0 && forward(Token::Types::OPERATOR, ")")(q.index)) {
					break;
				}
				if (stop(EVALUATION_STOPS, q.index)) {
					if (forward(Token::Types::OPERATOR, ",")(q.index) && (c != 0 || s != 0)) {
						if (any()(q))
							++n;
					} else {
						break;
					}
				} else if (must(Token::Types::OPERATOR, "(")(q)) {
					++c;
					++n;
				} else if (must(Token::Types::OPERATOR, ")")(q)) {
					--c;
					++n;
				} else if (any()(q)) {
					++n;
				} else {
					break;
				}
			}

			if (c != 0) {
				const Token::Ptr &tk = tokens[Math::min(q.index, (int)tokens.size() - 1)];
				const Error err("Unmatched braces", false);
				onError(err, err.format(), tk->begin());

				return 0;
			} else if (s != 0) {
				const Token::Ptr &tk = tokens[Math::min(q.index, (int)tokens.size() - 1)];
				const Error err("Unmatched square brackets", false);
				onError(err, err.format(), tk->begin());

				return 0;
			}

			return n;
		};

		std::function<bool(Node::Ptr &, const Combinator::Options &)> Statement = nullptr;
		auto StatementN = [&] (Node::Ptr &p, const Combinator::Options &opts) -> bool { // A number of statements.
			int n = 0;
			const int st = (int)structures.size();
			do {
				++n;
				if (!Statement(p, opts)) return false;
			} while (st < (int)structures.size());
			GBBASIC_ASSERT(n == 1 && "Impossible.");

			return true;
		};

		// Syntax combinators.
		const Combinator Blank( // Blank line.
			[&] (Node::Ptr &p, const Combinator::Options &) -> bool {
				State q = begin();

				if (!must(Token::Types::INTEGER)(q)) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!must(Token::Types::END_OF_LINE)(q)) return false;

				Node::Ptr node = createNode(
					" ", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				return true;
			}
		);
		const Combinator Rem( // Comment.
			[&] (Node::Ptr &p, const Combinator::Options &) -> bool {
				State q = begin();

				if (!must(Token::Types::INTEGER)(q)) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!must(Token::Types::COMMENT)(q)) return false;
				if (!must(Token::Types::END_OF_LINE)(q)) return false;

				Node::Ptr node = createNode(
					"rem", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				return true;
			}
		);
		const Combinator DoNothing( // `DO NOTHING`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "do")(q)) return false;
				if (!must(Token::Types::IDENTIFIER, "nothing")(q)) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"donothing", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Const( // Const. Reserved.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				int n = 0;
				BuiltinTable::Entry entry;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "const")(q)) return false;
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
				else name = (std::string)id->data();
				const int r = q.index;
				if (must(Token::Types::OPERATOR, "=")(q)) {
					if (!Numbers(q, children, [&] (const Token::Ptr &tk) -> void {
						int val = 0;
						validate<Word>(tk, val, onError);
						entry = BuiltinTable::Entry::define(val);
						++n;
					})) return throwInvalidSyntax(q.index);
					CHECK_UNEXPECTED(q);
				} else {
					return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				const Node::MacroIdentifierAliasTable::Entry* idAlias = macroIdentifierAliases.find(name); // FEAT: MACRO.
				if (idAlias) {
					const std::string idName = idAlias->name;
					const IdentifierTable::Entry* idEntry = identifiers.find(idName);
					if (!idEntry)
						return throwIdHasNotBeenDeclared(r, idName);
					if (idEntry->type != IdentifierTable::Entry::Types::CONST)
						return false;

					id->data(idName);
				} else {
					if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(r, name); }
				}

				if (n != 1) return throwInvalidSyntax(r);
				builtins.add(name, entry, options.caseInsensitive);

				Node::Ptr node = createNode(
					"const", id->data(),
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				if (!identifiers.find(name))
					identifiers.add(name, IdentifierTable::Entry(IdentifierTable::Entry::Types::CONST));

				return throwNotImplemented(q.index); // Reserved, not implemented yet.
			}
		);
		const Combinator Let( // `LET`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				bool let = false;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				let = !!forward(Token::Types::KEYWORD, "let")(q.index); if (let) any()(q);
				if ((id = must(Token::Types::OPERATOR)(q))) {
					name = (std::string)id->data();
					if (!Text::startsWith(name, "stack", true)) return throwInvalidSyntax(q.index);
					const std::string idxTxt = name.substr(5 /* after "stack" */);
					int idx = -1;
					if (!Text::fromString(idxTxt, idx)) return throwInvalidSyntax(q.index);
					if (idx < 0 || idx >= COMPILER_STACK_ARGUMENT_MAX_COUNT) return throwInvalidSyntax(q.index);
				} else if ((id = must(Token::Types::IDENTIFIER)(q))) {
					name = (std::string)id->data();
				} else {
					return false;
				}
				const int r = q.index;
				if (must(Token::Types::OPERATOR, "=")(q)) {
					if (!New(q, children) && !Expression(q, children) && !Invoking(q, children, true) && !Is(q, children, true)) return throwInvalidSyntax(q.index);
					if (forward(Token::Types::OPERATOR, ANYTHING)(q.index)) return throwInvalidSyntax(q.index);
				} else {
					if (let) { /* Do nothing. */ }
					else { return false; } // Just skip this parser.
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				const Node::MacroIdentifierAliasTable::Entry* idAlias = macroIdentifierAliases.find(name); // FEAT: MACRO.
				const Node::MacroStackReferenceTable::Entry* stackNRef = macroStackReferences.find(name); // FEAT: MACRO.
				if (idAlias) {
					const std::string idName = idAlias->name;
					const IdentifierTable::Entry* idEntry = identifiers.find(idName);
					if (!idEntry)
						return throwIdHasNotBeenDeclared(r, idName);
					if (idEntry->type != IdentifierTable::Entry::Types::LET)
						return throwInvalidSyntax(r);

					id->data(idName);
				} else if(stackNRef) {
					if (let) { return throwIdHasBeenAlreadyDeclared(r, name); }
					id
						->type(Token::Types::OPERATOR)
						->text(stackNRef->alias->text())
						->parse(false);
				} else {
					if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(r, name); }
				}

				Node::Ptr node = createNode(
					"let", id->data(),
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				if (!identifiers.find(name))
					identifiers.add(name, IdentifierTable::Entry(IdentifierTable::Entry::Types::LET));

				return true;
			}
		);
		const Combinator Local( // Local. Reserved.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				bool local = false;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				local = !!forward(Token::Types::KEYWORD, "local")(q.index); if (local) any()(q);
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
				else name = (std::string)id->data();
				const int r = q.index;
				if (must(Token::Types::OPERATOR, "=")(q)) {
					if (!New(q, children) && !Expression(q, children) && !Invoking(q, children, true) && !Is(q, children, true)) return throwInvalidSyntax(q.index);
					if (forward(Token::Types::OPERATOR, ANYTHING)(q.index)) return throwInvalidSyntax(q.index);
				} else {
					if (local) return throwInvalidSyntax(q.index);
					else return false; // Just skip this parser.
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				const Node::MacroIdentifierAliasTable::Entry* idAlias = macroIdentifierAliases.find(name); // FEAT: MACRO.
				if (idAlias) {
					const std::string idName = idAlias->name;
					const IdentifierTable::Entry* idEntry = identifiers.find(idName);
					if (!idEntry)
						return throwIdHasNotBeenDeclared(r, idName);
					if (idEntry->type != IdentifierTable::Entry::Types::LOCAL)
						return false;

					id->data(idName);
				} else {
					if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(r, name); }
				}

				Node::Ptr node = createNode(
					"local", id->data(),
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				if (!identifiers.find(name))
					identifiers.add(name, IdentifierTable::Entry(IdentifierTable::Entry::Types::LOCAL));

				return throwNotImplemented(q.index); // Reserved, not implemented yet.
			}
		);
		const Combinator Dim( // `DIM` array.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				Node::Context::Array::Dimensions dimensions;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "dim")(q)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return throwInvalidSyntax(q.index);
				else name = (std::string)id->data();
				if (name == "trigger") return false;
				const int r = q.index;
				if (!must(Token::Types::OPERATOR, "[")(q)) return throwInvalidSyntax(q.index);
				if (!Numbers(q, children, [&] (const Token::Ptr &tk) -> void {
					int val = 0;
					validate<Word>(tk, val, onError);
					max(tk, val, options.indexBase, onError);
					dimensions.bounds.push_back(val);
				})) return throwInvalidSyntax(q.index);
				CHECK_UNEXPECTED(q);
				if (!must(Token::Types::OPERATOR, "]")(q)) return throwInvalidSyntax(q.index);
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(r, name); }

				if (dimensions.bounds.size() > DIMENSION_MAX_COUNT) return throwTooManyDimensions(r);

				Node::Ptr node = createNode(
					"dim", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				if (!identifiers.find(name))
					identifiers.add(name, IdentifierTable::Entry(IdentifierTable::Entry::Types::DIM));

				array.named.insert(std::make_pair(name, dimensions));

				return true;
			}
		);
		const Combinator ArrayW( // Array writing.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				const int r = q.index;
				if (!must(Token::Types::OPERATOR, "[")(q)) return false;
				Arguments(q, children);
				CHECK_UNEXPECTED(q);
				if (!must(Token::Types::OPERATOR, "]")(q)) return throwInvalidSyntax(q.index);
				if (must(Token::Types::OPERATOR, "=")(q)) {
					if (!New(q, children) && !Expression(q, children) && !Invoking(q, children, true) && !Is(q, children, true)) return throwInvalidSyntax(q.index);
					if (forward(Token::Types::OPERATOR, ANYTHING)(q.index)) return throwInvalidSyntax(q.index);
				} else {
					return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				const Node::MacroIdentifierAliasTable::Entry* idAlias = macroIdentifierAliases.find(name); // FEAT: MACRO.
				if (idAlias) {
					const std::string idName = idAlias->name;
					const IdentifierTable::Entry* idEntry = identifiers.find(idName);
					if (!idEntry)
						return throwIdHasNotBeenDeclared(r, idName);
					if (idEntry->type != IdentifierTable::Entry::Types::DIM)
						return throwInvalidSyntax(r);

					id->data(idName);
				}

				Node::Ptr node = createNode(
					"[...]=", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator If1( // Single line `IF`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr tkgoto = nullptr;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "if")(q)) return false;
				if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "goto")(q.index)) tkgoto = next(q);
				else if (!forward(Token::Types::KEYWORD, "then")(q.index)) return throwInvalidSyntax(q.index);
				{
					if (
						!tkgoto && (
							forwardN(2, Token::Types::COMMENT)(q.index) ||
							forwardN(2, Token::Types::END_OF_LINE)(q.index)
						)
					) { // Is not a single line `IF`.
						return false;
					}

					Node::Ptr then(new NodeThen());
					if (!tkgoto) then->concat(next(q)); // `THEN`.
					cursor = q.index;
					{
						Combinator::Options sub = opts;
						sub.mustHaveLineNumber = false;
						if (forward(Token::Types::INTEGER)(q.index)) { // Line number.
							State q1 = begin();
							q1.index = q.index;

							any()(q1);

							Node::Ptr exp(new NodeExpression());
							exp->concat(q1.tokens);
							Node::Ptr goto_(new NodeGoto());
							goto_->add(exp);
							then->add(goto_);

							q1.success = true;
							end(q1);
							q.index = q1.index;
						} else if (
							forward(Token::Types::IDENTIFIER)(q.index) && (
								forwardN(2, Token::Types::COMMENT)(q.index) ||
								forwardN(2, Token::Types::END_OF_LINE)(q.index)
							)
						) { // Destination label.
							State q1 = begin();
							q1.index = q.index;

							any()(q1);

							Node::Ptr exp(new NodeExpression());
							exp->concat(q1.tokens);
							Node::Ptr goto_(new NodeGoto());
							goto_->add(exp);
							then->add(goto_);

							q1.success = true;
							end(q1);
							q.index = q1.index;
						} else if (!Statement(then, sub)) { // Statement.
							return throwInvalidSyntax(q.index);
						}
					}
					children.push_back(then);
					q.index = cursor;
				}
				if (forward(Token::Types::KEYWORD, "else")(q.index)) {
					if (forwardN(2, Token::Types::END_OF_LINE)(q.index)) return throwInvalidSyntax(q.index);

					Node::Ptr else_(new NodeElse());
					else_->concat(next(q)); // `ELSE`.
					cursor = q.index;
					{
						Combinator::Options sub = opts;
						sub.mustHaveLineNumber = false;
						if (!Statement(else_, sub)) return throwInvalidSyntax(q.index);
					}
					children.push_back(else_);
					q.index = cursor;
				}
				if (
					forwardN(1, Token::Types::KEYWORD, "end")(q.index) &&
					forwardN(2, Token::Types::KEYWORD, "if")(q.index)
				) { // Paired `END IF` is identical with `ENDIF`.
					return throwInvalidSyntax(q.index);
				} else if (forward(Token::Types::KEYWORD, "endif")(q.index)) {
					return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"if", "_",
					{
						{ "allow_call", false },
						{ "single_line", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator IfN( // Multiline `IF`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("if"), endStructure());

				State q = begin();
				Node::Array children;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "if")(q)) return false;
				if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				if (!forward(Token::Types::KEYWORD, "then")(q.index)) return throwInvalidSyntax(q.index);
				{
					const Token::Ptr thenTk = next(q);
					ignore(Token::Types::COMMENT)(q);
					if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index); // Is not a multi-line `IF`.

					Node::Ptr then(new NodeThen());
					then->concat(thenTk); // `THEN`.
					cursor = q.index;
					for (EVER) {
						const bool stp = stop(IF_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(then, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(then);
					q.index = cursor;
				}
				for (EVER) {
					bool pairedElseIf = false;
					if (
						forwardN(2, Token::Types::KEYWORD, "else")(q.index) &&
						forwardN(3, Token::Types::KEYWORD, "if")(q.index)
					) { // Paired `ELSE IF` is identical with `ELSEIF`.
						pairedElseIf = true;
					} else if (!forwardN(2, Token::Types::KEYWORD, "elseif")(q.index)) {
						break;
					}

					Node::Ptr elseif(new NodeElseIf());

					{
						State q1 = begin();
						q1.index = q.index;

						if (!LineNumber(q1, opts)) return throwInvalidSyntax(q.index);
						elseif->concat(q1.tokens);
						if (pairedElseIf) {
							Token::Ptr node(new Token());
							node
								->type(Token::Types::KEYWORD)
								->data("elseif");
							q1.index += 2;
							elseif->concat(node); // `ELSE IF`.
						} else {
							elseif->concat(next(q1)); // `ELSEIF`.
						}
						if (forward(Token::Types::END_OF_LINE)(q1.index)) return throwInvalidSyntax(q1.index);

						if (!Expression(q1, children)) return throwInvalidSyntax(q.index);

						q.index = q1.index;
					}

					if (forward(Token::Types::KEYWORD, "then")(q.index)) {
						next(q);
						ignore(Token::Types::COMMENT)(q);
						if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);
					}

					cursor = q.index;
					for (EVER) {
						const bool stp = stop(IF_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(elseif, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(elseif);
					q.index = cursor;
				}
				if (forwardN(2, Token::Types::KEYWORD, "else")(q.index)) {
					Node::Ptr else_(new NodeElse());

					{
						State q1 = begin();
						q1.index = q.index;

						if (!LineNumber(q1, opts)) return throwInvalidSyntax(q.index);
						else_->concat(q1.tokens);
						else_->concat(next(q1)); // `ELSE`.
						ignore(Token::Types::COMMENT)(q1);
						if (!ignore(Token::Types::END_OF_LINE)(q1)) return throwInvalidSyntax(q1.index);

						q.index = q1.index;
					}

					cursor = q.index;
					for (EVER) {
						const bool stp = stop(IF_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(else_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(else_);
					q.index = cursor;
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (
						forwardN(1, Token::Types::KEYWORD, "end")(q1.index) &&
						forwardN(2, Token::Types::KEYWORD, "if")(q1.index)
					) { // Paired `END IF` is identical with `ENDIF`.
						Token::Ptr node(new Token());
						node
							->type(Token::Types::KEYWORD)
							->data("endif");
						q1.tokens.push_back(node);
						q1.index += 2;
					} else if (!must(Token::Types::KEYWORD, "endif")(q1)) {
						return throwInvalidSyntax(q1.index);
					}
					q.index = q1.index;
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"if", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator SelectCase( // `SELECT CASE`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("select case"), endStructure());

				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "select")(q)) return false;
				if (!must(Token::Types::KEYWORD, "case")(q)) return throwInvalidSyntax(q.index);
				if (!(id = must(Token::Types::SYMBOL)(q))) return throwInvalidSyntax(q.index);
				else name = (std::string)id->data();
				{
					ignore(Token::Types::COMMENT)(q);
					if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);
				}
				for (EVER) {
					if (forwardN(2, Token::Types::COMMENT)(q.index)) {
						if (!ignore(Token::Types::INTEGER)(q)) return throwInvalidSyntax(q.index);
						if (!ignore(Token::Types::COMMENT)(q)) return throwInvalidSyntax(q.index);
						if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);

						continue;
					}
					if (!forwardN(2, Token::Types::KEYWORD, "case")(q.index)) {
						break;
					}

					Node::Ptr case_(new NodeCase());

					do {
						State q1 = begin();
						q1.index = q.index;

						if (!LineNumber(q1, opts)) return throwInvalidSyntax(q.index);
						if (!must(Token::Types::KEYWORD, "case")(q1)) return throwInvalidSyntax(q1.index);
						case_->concat(q1.tokens); // `CASE`.
						if (forward(Token::Types::END_OF_LINE)(q1.index)) return throwInvalidSyntax(q1.index);

						State q2 = begin();
						q2.index = q1.index;
						Node::Array children_;
						if (Range(q2, children_) && children_.size() == 2) { // Range.
							Node::Ptr &child0 = children_.front();
							Node::Ptr &child1 = children_.back();

							Token::Ptr ob0(new Token());
							ob0
								->type(Token::Types::OPERATOR)
								->data("(")
								->begin(id->begin())
								->end(id->end());
							Token::Ptr id0(new Token(*id));
							Token::Ptr gte(new Token());
							gte
								->type(Token::Types::OPERATOR)
								->data(">=")
								->begin(id->begin())
								->end(id->end());
							Token::Ptr cb0(new Token());
							cb0
								->type(Token::Types::OPERATOR)
								->data(")")
								->begin(id->begin())
								->end(id->end());
							child0->insert(ob0);
							child0->insert(id0, 1);
							child0->insert(gte, 2);
							child0->concat(cb0);

							Token::Ptr ob1(new Token());
							ob1
								->type(Token::Types::OPERATOR)
								->data("(")
								->begin(id->begin())
								->end(id->end());
							Token::Ptr id1(new Token(*id));
							Token::Ptr lte(new Token());
							lte
								->type(Token::Types::OPERATOR)
								->data("<=")
								->begin(id->begin())
								->end(id->end());
							Token::Ptr cb1(new Token());
							cb1
								->type(Token::Types::OPERATOR)
								->data(")")
								->begin(id->begin())
								->end(id->end());
							child1->insert(ob1);
							child1->insert(id1, 1);
							child1->insert(lte, 2);
							child1->concat(cb1);

							const Token::Array tokens0 = child0->allTokens(true);
							Token::Ptr and_(new Token());
							and_
								->type(Token::Types::OPERATOR)
								->data("and")
								->begin(id->begin())
								->end(id->end());
							const Token::Array tokens1 = child1->allTokens(true);

							Node::Ptr exp(new NodeExpression());
							exp->concat(tokens0);
							exp->concat(and_);
							exp->concat(tokens1);
							children.push_back(exp);

							q.index = q2.index;

							break;
						}

						q2 = begin();
						q2.index = q1.index;
						children_.clear();
						if (Arguments(q2, children_) && children_.size() > 1) { // Values.
							CHECK_UNEXPECTED(q2);

							Node::Ptr exp(new NodeExpression());

							for (int i = 0; i < (int)children_.size(); ++i) {
								Node::Ptr &child = children_[i];
								Token::Ptr ob(new Token());
								ob
									->type(Token::Types::OPERATOR)
									->data("(")
									->begin(id->begin())
									->end(id->end());
								Token::Ptr id_(new Token(*id));
								Token::Ptr eq(new Token());
								eq
									->type(Token::Types::OPERATOR)
									->data("=")
									->begin(id->begin())
									->end(id->end());
								Token::Ptr cb(new Token());
								cb
									->type(Token::Types::OPERATOR)
									->data(")")
									->begin(id->begin())
									->end(id->end());
								child->insert(ob);
								child->insert(id_, 1);
								child->insert(eq, 2);
								child->concat(cb);

								const Token::Array tokens = child->allTokens(true);
								exp->concat(tokens);

								if (i != (int)children_.size() - 1) {
									Token::Ptr or_(new Token());
									or_
										->type(Token::Types::OPERATOR)
										->data("or")
										->begin(id->begin())
										->end(id->end());

									exp->concat(or_);
								}
							}

							children.push_back(exp);

							q.index = q2.index;

							break;
						}

						q2 = begin();
						q2.index = q1.index;
						children_.clear();
						if (Expression(q2, children_) && children_.size() == 1) {
							Node::Ptr &child = children_.front();
							const Token::Ptr tk = child->firstTokenInThisOrChildren();
							const bool isComparison =
								tk->is(Token::Types::OPERATOR) && (
									tk->text() == "="  ||
									tk->text() == "<"  ||
									tk->text() == "<=" ||
									tk->text() == ">"  ||
									tk->text() == ">=" ||
									tk->text() == "<>"
								);
							if (isComparison) { // Comparison.
								Token::Ptr id_(new Token(*id));
								child->insert(id_);
							} else { // Value.
								Token::Ptr id_(new Token(*id));
								Token::Ptr eq(new Token());
								eq
									->type(Token::Types::OPERATOR)
									->data("=")
									->begin(id->begin())
									->end(id->end());
								child->insert(id_);
								child->insert(eq, 1);
							}
							children.push_back(child);

							q.index = q2.index;

							break;
						}

						return throwInvalidSyntax(q.index);
					} while (false);

					ignore(Token::Types::COMMENT)(q);
					if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);

					cursor = q.index;
					for (EVER) {
						const bool stp = stop(SELECT_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(case_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(case_);
					q.index = cursor;
				}
				if (forwardN(2, Token::Types::KEYWORD, "else")(q.index)) {
					Node::Ptr else_(new NodeElse());

					{
						State q1 = begin();
						q1.index = q.index;

						if (!LineNumber(q1, opts)) return throwInvalidSyntax(q.index);
						else_->concat(q1.tokens);
						else_->concat(next(q1)); // `ELSE`.
						ignore(Token::Types::COMMENT)(q1);
						if (!ignore(Token::Types::END_OF_LINE)(q1)) return throwInvalidSyntax(q1.index);

						q.index = q1.index;
					}

					cursor = q.index;
					for (EVER) {
						const bool stp = stop(SELECT_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(else_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(else_);
					q.index = cursor;
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (
						forwardN(1, Token::Types::KEYWORD, "end")(q1.index) &&
						forwardN(2, Token::Types::KEYWORD, "select")(q1.index)
					) { // Paired `END SELECT` is identical with `ENDSELECT`.
						Token::Ptr node(new Token());
						node
							->type(Token::Types::KEYWORD)
							->data("endselect");
						q1.tokens.push_back(node);
						q1.index += 2;
					} else if (!must(Token::Types::KEYWORD, "endselect")(q1)) {
						return throwInvalidSyntax(q1.index);
					}
					q.index = q1.index;
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"select", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator On( // `ON`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "on")(q)) return false;
				if (
					forward(Token::Types::KEYWORD, "btn")(q.index) ||
					forward(Token::Types::KEYWORD, "btnd")(q.index) ||
					forward(Token::Types::KEYWORD, "btnu")(q.index)
				) {
					any()(q);
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (must(Token::Types::KEYWORD, "gosub")(q)) { /* Do nothing. */ }
					else if (must(Token::Types::KEYWORD, "goto")(q)) { /* Do nothing. */ }
					else if (must(Token::Types::KEYWORD, "start")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else if (
					forward(Token::Types::KEYWORD, "touch")(q.index) ||
					forward(Token::Types::KEYWORD, "touchd")(q.index) ||
					forward(Token::Types::KEYWORD, "touchu")(q.index)
				) {
					any()(q);
					if (must(Token::Types::KEYWORD, "gosub")(q)) { /* Do nothing. */ }
					else if (must(Token::Types::KEYWORD, "goto")(q)) { /* Do nothing. */ }
					else if (must(Token::Types::KEYWORD, "start")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else if (forward(Token::Types::KEYWORD, "actor")(q.index)) {
					return false; // Actor's callback is handled by `ActorM`.
				} else if (forward(Token::Types::KEYWORD, "trigger")(q.index)) {
					return false; // Trigger's callback is handled by `TriggerM`.
				} else if (forward(Token::Types::KEYWORD, "menu")(q.index)) {
					return false; // Menu's callback is handled by `MenuM`.
				} else {
					{
						State q1 = begin();
						q1.index = q.index;
						Node::Array children_;

						if (!Evaluation(q1, children_)) return throwInvalidSyntax(q.index);

						Node::Ptr exp(new NodeExpression());
						exp->concat(q1.tokens);
						exp->add(children_);
						children.push_back(exp);

						q1.success = true;
						end(q1);
						q.index = q1.index;
					}
					if (forward(Token::Types::KEYWORD, "goto")(q.index)) {
						any()(q);
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					} else if (forward(Token::Types::KEYWORD, "gosub")(q.index)) {
						any()(q);
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"on", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Off( // `OFF`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "off")(q)) return false;
				if (
					forward(Token::Types::KEYWORD, "btn")(q.index) ||
					forward(Token::Types::KEYWORD, "btnd")(q.index) ||
					forward(Token::Types::KEYWORD, "btnu")(q.index)
				) {
					any()(q);
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else if (
					forward(Token::Types::KEYWORD, "touch")(q.index) ||
					forward(Token::Types::KEYWORD, "touchd")(q.index) ||
					forward(Token::Types::KEYWORD, "touchu")(q.index)
				) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "actor")(q.index)) {
					return false; // Actor's callback is handled by `ActorM`.
				} else if (forward(Token::Types::KEYWORD, "trigger")(q.index)) {
					return false; // Trigger's callback is handled by `TriggerM`.
				} else if (forward(Token::Types::KEYWORD, "menu")(q.index)) {
					return false; // Menu's callback is handled by `MenuM`.
				} else {
					return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"off", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator For( // `FOR` loop.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("for"), endStructure());

				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "for")(q)) return false;
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return throwInvalidSyntax(q.index);
				else name = (std::string)id->data();
				if (!must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				if (!must(Token::Types::KEYWORD, "to")(q)) return throwInvalidSyntax(q.index);
				if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "step")(q.index)) {
					any()(q);
					if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				}
				{
					ignore(Token::Types::COMMENT)(q);
					if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);

					Node::Ptr do_(new NodeDo());
					cursor = q.index;
					for (EVER) {
						const bool stp = stop(FOR_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(do_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(do_);
					q.index = cursor;
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (!must(Token::Types::KEYWORD, "next")(q1)) return throwInvalidSyntax(q1.index);
					if (forward(Token::Types::IDENTIFIER)(q1.index)) {
						Token::Ptr id_ = maybe(Token::Types::IDENTIFIER)(q1);
						const std::string name_ = (std::string)id_->data();
						if (name_ != name) return throwInvalidSyntax(q1.index);
					}
					q.index = q1.index;
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"for", id->data(),
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Next( // `NEXT`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "next")(q)) return false;
				if (forward(Token::Types::IDENTIFIER)(q.index)) {
					id = maybe(Token::Types::IDENTIFIER)(q);
					name = (std::string)id->data();
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (!isLoopStructure("for")) return throwLoopExpected(q.index);

				Node::Ptr node = createNode(
					"next", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator While( // `WHILE` loop.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("while"), endStructure());

				State q = begin();
				Node::Array children;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "while")(q)) return false;
				if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				{
					ignore(Token::Types::COMMENT)(q);
					if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);

					Node::Ptr do_(new NodeDo());
					cursor = q.index;
					for (EVER) {
						const bool stp = stop(WHILE_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(do_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(do_);
					q.index = cursor;
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (
						forwardN(1, Token::Types::KEYWORD, "end")(q1.index) &&
						forwardN(2, Token::Types::KEYWORD, "while")(q1.index)
					) { // Paired `END WHILE` is identical with `WEND`.
						Token::Ptr node(new Token());
						node
							->type(Token::Types::KEYWORD)
							->data("wend");
						q1.tokens.push_back(node);
						q1.index += 2;
					} else if (!must(Token::Types::KEYWORD, "wend")(q1)) {
						return throwInvalidSyntax(q1.index);
					}
					q.index = q1.index;
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"while", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Repeat( // `REPEAT` loop.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("repeat"), endStructure());

				State q = begin();
				Node::Array children;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "repeat")(q)) return false;
				{
					ignore(Token::Types::COMMENT)(q);
					if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);

					Node::Ptr do_(new NodeDo());
					cursor = q.index;
					for (EVER) {
						const bool stp = stop(REPEAT_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(do_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(do_);
					q.index = cursor;
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (!must(Token::Types::KEYWORD, "until")(q1)) return throwInvalidSyntax(q1.index);
					q.index = q1.index;
				}
				if (!Expression(q, children)) return throwInvalidSyntax(q.index);
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"repeat", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Exit( // `EXIT`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "exit")(q)) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (!isLoopStructure(ANYTHING)) return throwLoopExpected(q.index);

				Node::Ptr node = createNode(
					"exit", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Destination( // Destination for jump statements.
			[&] (Node::Ptr &p, const Combinator::Options &) -> bool {
				State q = begin();
				Token::Ptr tk = nullptr;

				if (!must(Token::Types::INTEGER)(q)) return false;
				if (!(tk = must(Token::Types::LABEL)(q))) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return false;

				std::string name = (std::string)tk->data();
				if (!name.empty() && name.back() == ':')
					name.pop_back();
				const int dataCursor = (int)data.size();
				data.labeled.insert(std::make_pair(Node::Context::Data::Labeled(page, name), dataCursor));

				Node::Ptr dst(new NodeDestination());
				std::string caseSensitiveName = tk->caseSensitiveText();
				if (!caseSensitiveName.empty() && caseSensitiveName.back() == ':')
					caseSensitiveName.pop_back();
				dst->options(
					IDictionary::Ptr(
						Dictionary::create(
							{
								{ "name", name },
								{ "case_sensitive_name", caseSensitiveName }
							}
						)
					)
				);
				dst->concat(q.tokens);
				p->add(dst);

				q.success = true;
				end(q);

				return true;
			}
		);
		const Combinator Goto( // `GOTO`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "goto")(q)) return false;
				Arguments(q, children);
				CHECK_UNEXPECTED(q);
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"goto", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Gosub( // `GOSUB`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "gosub")(q)) return false;
				Arguments(q, children);
				CHECK_UNEXPECTED(q);
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"gosub", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Return( // `RETURN`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "return")(q)) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"return", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				return true;
			}
		);
		const Combinator Data( // `DATA`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				int lnno = -1;
				Node::Context::Data data_;

				if (!LineNumber(q, opts, &lnno)) return false;
				if (!must(Token::Types::KEYWORD, "data")(q)) return false;
				if (forward(Token::Types::KEYWORD, "repeat")(q.index)) {
					any()(q);
					int n = 0;
					int value = 0;
					int times = 0;
					int dataSize = 0;
					Token::IntegerTypes y = Token::IntegerTypes::UNSPECIFIED;
					if (!TypedNumbers(q, children, [&] (const Token::Ptr &tkval, const Token::Ptr &tktype) -> void {
						y = typeOf(tktype);
						int val = 0;
						if (n == 0) {
							switch (y) {
							case Token::IntegerTypes::UNSPECIFIED:
								validate<Int8, UInt8>(tkval, val, onError);
								value = val;
								dataSize = 1;

								break;
							case Token::IntegerTypes::INT:
								validate<Word>(tkval, val, onError);
								value = val;
								dataSize = 2;

								break;
							default:
								GBBASIC_ASSERT(false && "Not implemented.");

								break;
							}
						} else if (n == 1) {
							validate<Word>(tkval, val, onError);
							times = val;
						}
						++n;
					})) return throwInvalidSyntax(q.index);
					CHECK_UNEXPECTED(q);
					if (n != 2) return throwInvalidSyntax(q.index);
					const int headSize = Asm::INSTRUCTIONS[(Byte)Asm::Types::JUMP_FAR].totalSize();
					if (headSize + times * dataSize > options.bankSize) {
						// DOC: ROM SCHEMA.
						// The data size of this data statement overflows, throw an error.
						// This statement doesn't care about other ones, the check is just
						// an insurance to prevent the `times` parameter is too big.
						return throwDataSectionOverflow(q.index);
					}
					for (int i = 0; i < times; ++i)
						data_.values.push_back(Node::Context::Data::Value(page, lnno, value, y));
				} else {
					if (!TypedNumbers(q, children, [&] (const Token::Ptr &tkval, const Token::Ptr &tktype) -> void {
						Token::IntegerTypes y = typeOf(tktype);
						int val = 0;
						val = (int)(Variant::Int)tkval->data();
						switch (y) {
						case Token::IntegerTypes::UNSPECIFIED:
							validate<Int8, UInt8>(tkval, val, onError);

							break;
						case Token::IntegerTypes::INT:
							validate<Word>(tkval, val, onError);

							break;
						default:
							GBBASIC_ASSERT(false && "Not implemented.");

							break;
						}
						data_.values.push_back(Node::Context::Data::Value(page, lnno, val, y));
					})) return throwInvalidSyntax(q.index);
					CHECK_UNEXPECTED(q);
				}
				if (!structures.empty()) {
					const std::string &struct_ = structures.back();
					throwDataInsideStructureAlwaysTakesEffectOnceAndOnlyOnce(q.index, struct_);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"data", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				if (!data_.empty()) {
					for (const Node::Context::Data::Value &d : data_.values)
						data.values.push_back(d);
				}

				return true;
			}
		);
		const Combinator Read( // `READ`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "read")(q)) return false;
				maybe(Token::Types::KEYWORD, "int")(q);
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						ParametersOrNumbers(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					ParametersOrNumbers(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"read", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Restore( // `RESTORE`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "restore")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"restore", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Filler( // `FILLER`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "filler")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				if (!structures.empty()) {
					const std::string &struct_ = structures.back();
					throwFillerInsideStructureAlwaysTakesEffectOnceAndOnlyOnce(q.index, struct_);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"filler", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator BeginDo( // `BEGINDO`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("begin do"), endStructure());

				State q = begin();
				Node::Array children;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (
					forwardN(1, Token::Types::KEYWORD, "begin")(q.index) &&
					forwardN(2, Token::Types::KEYWORD, "do")(q.index)
				) { // Paired `BEGIN DO` is identical with `BEGINDO`.
					Token::Ptr node(new Token());
					node
						->type(Token::Types::KEYWORD)
						->data("begindo");
					q.tokens.push_back(node);
					q.index += 2;
				} else if (!must(Token::Types::KEYWORD, "begindo")(q)) {
					return false;
				}
				ignore(Token::Types::COMMENT)(q);
				if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);
				{
					Node::Ptr do_(new NodeDo());
					cursor = q.index;
					for (EVER) {
						const bool stp = stop(BEGINDO_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						if (!StatementN(do_, sub)) return throwIncompleteStructure(index);
					}
					children.push_back(do_);
					q.index = cursor;
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (
						forwardN(1, Token::Types::KEYWORD, "end")(q1.index) &&
						forwardN(2, Token::Types::KEYWORD, "do")(q1.index)
					) { // Paired `END DO` is identical with `ENDDO`.
						Token::Ptr node(new Token());
						node
							->type(Token::Types::KEYWORD)
							->data("enddo");
						q1.tokens.push_back(node);
						q1.index += 2;
					} else if (!must(Token::Types::KEYWORD, "enddo")(q1)) {
						return throwInvalidSyntax(q1.index);
					}
					q.index = q1.index;
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"begindo", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator BeginDef( // FEAT: MACRO. `BEGINDEF`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				PROC_GUARD(beginStructure("begin def"), endStructure());

				State q = begin();
				Node::Array children;
				const int index = q.index;

				if (tooManyNestedStructures()) return throwTooManyNestedStructures(index);

				if (!LineNumber(q, opts)) return false;
				if (
					forwardN(1, Token::Types::KEYWORD, "begin")(q.index) &&
					forwardN(2, Token::Types::KEYWORD, "def")(q.index)
				) { // Paired `BEGIN DEF` is identical with `BEGINDEF`.
					Token::Ptr node(new Token());
					node
						->type(Token::Types::KEYWORD)
						->data("begindef");
					q.tokens.push_back(node);
					q.index += 2;
				} else if (!must(Token::Types::KEYWORD, "begindef")(q)) {
					return false;
				}
				ignore(Token::Types::COMMENT)(q);
				if (!ignore(Token::Types::END_OF_LINE)(q)) return throwInvalidSyntax(q.index);
				Node::MacroFunctionTable tbl;
				{
					PROC_GUARD(beginDef(index), endDef(q.index));

					Node::Ptr do_(new NodeDo());
					cursor = q.index;
					for (EVER) {
						const bool stp = stop(BEGINDEF_STOPS, cursor, 2);
						if (stp)
							break;

						Combinator::Options sub = opts;
						const int errorCount = errors;
						if (!StatementN(do_, sub)) {
							if (errors > errorCount) // Already raised error.
								return false;

							return throwIncompleteStructure(index);
						}
					}
					children.push_back(do_);
					q.index = cursor;

					tbl = std::move(macroFunctions.top());
				}
				{
					State q1 = q;
					if (!LineNumber(q1, opts)) return throwInvalidSyntax(q1.index);
					if (
						forwardN(1, Token::Types::KEYWORD, "end")(q1.index) &&
						forwardN(2, Token::Types::KEYWORD, "def")(q1.index)
					) { // Paired `END DEF` is identical with `ENDDEF`.
						Token::Ptr node(new Token());
						node
							->type(Token::Types::KEYWORD)
							->data("enddef");
						q1.tokens.push_back(node);
						q1.index += 2;
					} else if (!must(Token::Types::KEYWORD, "enddef")(q1)) {
						return throwInvalidSyntax(q1.index);
					}
					q.index = q1.index;
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"begindef", "_",
					{
						{ "allow_call", false },
						{ "macro_function_table", (void*)&tbl }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator DefMacroAlias( // FEAT: MACRO. `DEF ... = M`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				int r = 0;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "def")(q)) return false;
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
				else name = (std::string)id->data();
				if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(q.index, name); }
				if (must(Token::Types::OPERATOR, "=")(q)) {
					r = q.index;
					if (!Parameters(q, children)) return false;
					CHECK_UNEXPECTED(q);
				} else {
					return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 1) return throwTooFewArguments(r);
				else if (children.size() > 1) return throwTooManyArguments(r);

				if (!children.front()->onlyToken())
					return false;

				const std::string aliasName = children.front()->onlyToken()->text();
				const Node::MacroAliasTable::Entry* macroAliasEntry = macroAliases.find(aliasName);
				const Node::MacroFunctionTable::Entry* fnEntry = macroFunctions.find(aliasName);
				const Node::MacroConstantTable::Entry* constEntry = macroConstants.find(aliasName);
				const Node::MacroIdentifierAliasTable::Entry* idAliasEntry = macroIdentifierAliases.find(aliasName);
				const Node::MacroStackReferenceTable::Entry* stackRefEntry = macroStackReferences.find(aliasName);
				if (!macroAliasEntry && !fnEntry && !constEntry && !idAliasEntry && !stackRefEntry) // Is not a macro.
					return false;

				Node::Ptr node = createNode(
					"def ...=M", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				Token::Ptr var = node->onlyTokenInOnlyChild();
				const std::string &varName = var->text();
				macroAliases.add(name, Node::MacroAliasTable::Entry(var, varName)); // Add to the macro alias table.
				const Variant data = varName;
				const Macro macro(name, Macro::Types::MACRO_AILAS, data, headOfCurrentScope());
				macros.push_back(macro); // Add to the exposable macro list.

				return true;
			}
		);
		const Combinator DefFn( // FEAT: MACRO. `DEF FN(...) = ...`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				int beginIdx = -1;
				int endIdx = -1;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "def")(q)) return false;
				maybe(Token::Types::KEYWORD, "fn")(q);
				beginIdx = q.index;
				{
					if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
					else name = (std::string)id->data();
					if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(q.index, name); }
					if (!must(Token::Types::OPERATOR, "(")(q)) return false;
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					if (must(Token::Types::OPERATOR, "=")(q)) {
						if (!New(q, children) && !Expression(q, children) && !Invoking(q, children, true) && !Is(q, children, true)) return throwInvalidSyntax(q.index);
						if (forward(Token::Types::OPERATOR, ANYTHING)(q.index)) return throwInvalidSyntax(q.index);
					} else {
						return throwInvalidSyntax(q.index);
					}
				}
				endIdx = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 2) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"def fn(...)=...", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				Token::Array params = node->flatOnlyTokens(Node::Range(0, (int)children.size() - 1 - 1));
				Node::Ptr expr = children.back();
				macroFunctions.add(name, Node::MacroFunctionTable::Entry(params, expr)); // Add to the macro function table.
				const Token::Array tokens = between(beginIdx, endIdx);
				Token::Array filtered;
				std::copy_if(
					tokens.begin(), tokens.end(), 
					std::back_inserter(filtered),
					[] (const Token::Ptr &tk) -> bool {
						switch (tk->type()) {
						case Token::Types::NONE: // Fall through.
						case Token::Types::END_OF_LINE: // Fall through.
						case Token::Types::LINE_CONNECTOR: // Fall through.
						case Token::Types::COMMENT:
							return false;
						default:
							return true;
						}
					}
				);
				std::string txt;
				for (int i = 0; i < (int)filtered.size(); ++i) {
					const Token::Ptr &tk = filtered[i];
					switch (tk->type()) {
					case Token::Types::OPERATOR:
						if (tk->data() == "(") {
							txt += tk->caseSensitiveText();
						} else if (tk->data() == ")") {
							txt += tk->caseSensitiveText();
							if (i != (int)filtered.size() - 1)
								txt += " ";
						} else if (tk->data() == "sgn" || tk->data() == "abs" || tk->data() == "sqr" || tk->data() == "sqrt" || tk->data() == "sin" || tk->data() == "cos" || tk->data() == "atan2" || tk->data() == "pow" || tk->data() == "min" || tk->data() == "max") {
							txt += tk->caseSensitiveText();
						} else {
							txt += tk->caseSensitiveText();
							txt += " ";
						}

						break;
					default:
						txt += tk->caseSensitiveText();

						break;
					}
				}
				const Variant data = txt;
				const Macro macro(name, Macro::Types::FUNCTION, data, headOfCurrentScope());
				macros.push_back(macro); // Add to the exposable macro list.

				return true;
			}
		);
		const Combinator DefConstant( // FEAT: MACRO. `DEF ... = n`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "def")(q)) return false;
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
				else name = (std::string)id->data();
				if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(q.index, name); }
				if (must(Token::Types::OPERATOR, "=")(q)) {
					if (forward(Token::Types::IDENTIFIER, "nothing")(q.index)) {
						ignore(Token::Types::IDENTIFIER)(q);

						Token::Ptr node(new Token());
						node
							->type(Token::Types::INTEGER)
							->text("0")
							->data(0);

						Node::Ptr exp(new NodeExpression());
						exp->concat(node);
						children.push_back(exp);
					} else if (forward(Token::Types::BOOLEAN, false)(q.index)) {
						ignore(Token::Types::BOOLEAN)(q);

						Token::Ptr node(new Token());
						node
							->type(Token::Types::INTEGER)
							->text("0")
							->data(0);

						Node::Ptr exp(new NodeExpression());
						exp->concat(node);
						children.push_back(exp);
					} else if (forward(Token::Types::BOOLEAN, true)(q.index)) {
						ignore(Token::Types::BOOLEAN)(q);

						Token::Ptr node(new Token());
						node
							->type(Token::Types::INTEGER)
							->text("1")
							->data(1);

						Node::Ptr exp(new NodeExpression());
						exp->concat(node);
						children.push_back(exp);
					} else {
						if (!Numbers(q, children, [&] (const Token::Ptr &tk) -> void {
							int val = 0;
							validate<Word, UWord>(tk, val, onError);
						})) return false;
					}
					CHECK_UNEXPECTED(q);
				} else {
					return throwInvalidSyntax(q.index);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 1) return throwTooFewArguments(r);
				else if (children.size() > 1) return throwTooManyArguments(r);

				if (!children.front()->onlyToken())
					return false;

				Node::Ptr node = createNode(
					"def ...=N", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				Token::Ptr valTk = node->onlyTokenInOnlyChild();
				const std::string &valTxt = valTk->text();
				int val = -1;
				if (!Text::fromString(valTxt, val)) return throwInvalidSyntax(r);
				if (val < std::numeric_limits<Int16>::min() || val > std::numeric_limits<UInt16>::max()) return throwInvalidSyntax(r);
				macroConstants.add(name, Node::MacroConstantTable::Entry(valTk, val)); // Add to the macro constant table.
				const Variant data = val;
				const Macro macro(name, Macro::Types::CONSTANT, data, headOfCurrentScope());
				macros.push_back(macro); // Add to the exposable macro list.

				return true;
			}
		);
		const Combinator DefIdentifierAlias( // FEAT: MACRO. `DEF ... = var`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				int r = 0;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "def")(q)) return false;
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
				else name = (std::string)id->data();
				if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(q.index, name); }
				if (must(Token::Types::OPERATOR, "=")(q)) {
					r = q.index;
					if (!Parameters(q, children)) return false;
					CHECK_UNEXPECTED(q);
				} else {
					return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 1) return throwTooFewArguments(r);
				else if (children.size() > 1) return throwTooManyArguments(r);

				if (!children.front()->onlyToken())
					return false;

				const std::string idName = children.front()->onlyToken()->text();
				const IdentifierTable::Entry* idEntry = identifiers.find(idName);
				if (!idEntry) {
					if (!Text::startsWith(idName, "stack", true)) return throwIdHasNotBeenDeclared(r, idName); // Is not a stack reference.

					return false;
				}

				Node::Ptr node = createNode(
					"def ...=id", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				Token::Ptr var = node->onlyTokenInOnlyChild();
				const std::string &varName = var->text();
				macroIdentifierAliases.add(name, Node::MacroIdentifierAliasTable::Entry(var, varName)); // Add to the macro variable alias table.
				const Variant data = varName;
				const Macro macro(name, Macro::Types::VARIABLE_ALIAS, data, headOfCurrentScope());
				macros.push_back(macro); // Add to the exposable macro list.

				return true;
			}
		);
		const Combinator DefStackN( // FEAT: MACRO. `DEF ... = STACKN`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "def")(q)) return false;
				if (!(id = must(Token::Types::IDENTIFIER)(q))) return false;
				else name = (std::string)id->data();
				if (idHasBeenDefined(name)) { return throwIdHasBeenAlreadyDeclared(q.index, name); }
				if (must(Token::Types::OPERATOR, "=")(q)) {
					if (!References(q, children)) return false;
					CHECK_UNEXPECTED(q);
				} else {
					return throwInvalidSyntax(q.index);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 1) return throwTooFewArguments(r);
				else if (children.size() > 1) return throwTooManyArguments(r);

				if (!children.front()->onlyToken())
					return false;

				Node::Ptr node = createNode(
					"def ...=stackN", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				Token::Ptr ref = node->onlyTokenInOnlyChild();
				const std::string &refTo = ref->text();
				if (!Text::startsWith(refTo, "stack", true)) return throwInvalidSyntax(r);
				const std::string idxTxt = refTo.substr(5 /* after "stack" */);
				int idx = -1;
				if (!Text::fromString(idxTxt, idx)) return throwInvalidSyntax(r);
				if (idx < 0 || idx >= COMPILER_STACK_ARGUMENT_MAX_COUNT) return throwInvalidSyntax(r);
				macroStackReferences.add(name, Node::MacroStackReferenceTable::Entry(ref, idx)); // Add to the macro stack reference table.
				const Variant data = refTo;
				const Macro macro(name, Macro::Types::STACK_REFERENCE, data, headOfCurrentScope());
				macros.push_back(macro); // Add to the exposable macro list.

				return true;
			}
		);
		const Combinator Reserve( // `RESERVE`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "reserve")(q)) return false;
				if (!forward(Token::Types::COMMENT)(q.index) && !forward(Token::Types::END_OF_LINE)(q.index)) {
					if (!Expression(q, children) && !Invoking(q, children, true) && !Is(q, children, true)) return throwInvalidSyntax(q.index);
					if (forward(Token::Types::OPERATOR, ANYTHING)(q.index)) return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"reserve", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Push( // `PUSH`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "push")(q)) return false;
				if (!forward(Token::Types::COMMENT)(q.index) && !forward(Token::Types::END_OF_LINE)(q.index)) {
					if (!Expression(q, children) && !Invoking(q, children, true) && !Is(q, children, true)) return throwInvalidSyntax(q.index);
					if (forward(Token::Types::OPERATOR, ANYTHING)(q.index)) return throwInvalidSyntax(q.index);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"push", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Pop( // `POP`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "pop")(q)) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"pop", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Pack( // `PACK`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "pack")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 2) return throwTooFewArguments(r);
				else if (children.size() > 2) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"pack", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Unpack( // `UNPACK`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "unpack")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Parameters(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 3) return throwTooFewArguments(r);
				else if (children.size() > 3) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"unpack", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator PackN( // `PACKN`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "packn")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 4) return throwTooFewArguments(r);
				else if (children.size() > 4) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"packn", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator UnpackN( // `UNPACKN`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "unpackn")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Parameters(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 5) return throwTooFewArguments(r);
				else if (children.size() > 5) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"unpackn", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Swap( // `SWAP`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "swap")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Parameters(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 2) return throwTooFewArguments(r);
				else if (children.size() > 2) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"swap", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Inc( // `INC`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "inc")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Parameters(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 1) return throwTooFewArguments(r);
				else if (children.size() > 1) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"inc", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Dec( // `DEC`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "dec")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Parameters(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
				}
				const int r = q.index;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (children.size() < 1) return throwTooFewArguments(r);
				else if (children.size() > 1) return throwTooManyArguments(r);

				Node::Ptr node = createNode(
					"dec", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Rgb( // `RGB`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "rgb")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"rgb", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Hsv( // `HSV`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "hsv")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"hsv", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Memcpy( // Memcpy operations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "memcpy")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (forward(Token::Types::OPERATOR, "=")(q.index)) {
					if (!must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
					if (must(Token::Types::KEYWORD, "with")(q)) {
						if (forward(Token::Types::KEYWORD, "tile")(q.index)) {
							any()(q);
						} else if (forward(Token::Types::KEYWORD, "map")(q.index)) {
							any()(q);
						} else {
							return throwInvalidSyntax(q.index);
						}
					}
					if (forward(Token::Types::KEYWORD, "read")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
						any()(q);
						if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
					} else {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"memcpy", "_",
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator AutoToggle( // Auto toggle statements.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Token::Ptr id = nullptr;
				std::string name;
				Token::Ptr on = nullptr;
				std::string onoroff;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "auto")(q)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (!(
					name == "update"
				)) return false;
				if (!(on = must(Token::Types::SYMBOL)(q))) return false;
				else onoroff = (std::string)on->data();
				if (!(onoroff == "on" || onoroff == "off")) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node(new NodeAutoToggle());
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				return true;
			}
		);
		const Combinator Toggle( // Toggle statements.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Token::Ptr id = nullptr;
				std::string name;
				Token::Ptr on = nullptr;
				std::string onoroff;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (!(
					name == "screen" ||
					name == "map" || name == "window" || name == "sprite" ||
					name == "sound" ||
					name == "serial"
				)) return false;
				if (!(on = must(Token::Types::SYMBOL)(q))) return false;
				else onoroff = (std::string)on->data();
				if (!(onoroff == "on" || onoroff == "off")) return false;
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node(new NodeToggle());
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				return true;
			}
		);
		const Combinator ImageM( // Image manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "image")(q)) return false;
				if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
				Arguments(q, children);
				CHECK_UNEXPECTED(q);
				if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (!must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (must(Token::Types::KEYWORD, "with")(q)) {
					if (forward(Token::Types::KEYWORD, "tile")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "map")(q.index)) {
						any()(q);
					} else {
						return throwInvalidSyntax(q.index);
					}
				}
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"image", "_",
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator TileM( // Tile manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "tile") {
					return throwInvalidSyntax(q.index);
				} else {
					if (!must(Token::Types::KEYWORD, "tile")(q)) return false;
					if (forward(Token::Types::KEYWORD, "len")(q.index)) {
						any()(q);
					}
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"tile", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator MapM( // Map manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "map") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "map")(q)) return false;
					if (forward(Token::Types::KEYWORD, "width")(q.index) || forward(Token::Types::KEYWORD, "height")(q.index)) {
						any()(q);
					}
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"map", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator WindowM( // Window manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "window") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "window")(q)) return false;
					if (forward(Token::Types::KEYWORD, "width")(q.index) || forward(Token::Types::KEYWORD, "height")(q.index)) {
						any()(q);
					}
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"window", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator SpriteM( // Sprite manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "sprite") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "sprite")(q)) return false;
					if (forward(Token::Types::KEYWORD, "property")(q.index)) {
						any()(q);
					}
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"sprite", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator SceneM( // Scene manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "scene") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "scene")(q)) return false;
					if (forward(Token::Types::KEYWORD, "property")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "width")(q.index) || forward(Token::Types::KEYWORD, "height")(q.index)) {
						any()(q);
					}
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"scene", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator ActorM( // Actor manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "actor") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "actor")(q)) return false;
					if (forward(Token::Types::KEYWORD, "property")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "len")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "width")(q.index) || forward(Token::Types::KEYWORD, "height")(q.index)) {
						any()(q);
					}
					if (name == "def") {
						if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
						if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
					} else if (name == "del") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "play") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						}
					} else if (name == "start") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "join" || name == "kill" || name == "wait") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "find") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "move") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "stop") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "control") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "on") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "off") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else {
						if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
						if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
					}
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (name == "del") {
					// Do nothing.
				} else if (name == "play") {
					// Do nothing.
				} else if (name == "start") {
					// Do nothing.
				} else if (name == "join" || name == "kill" || name == "wait") {
					// Do nothing.
				} else if (name == "find") {
					// Do nothing.
				} else if (name == "move") {
					if (must(Token::Types::KEYWORD, "to")(q)) { /* Do nothing. */ }
					else if (must(Token::Types::KEYWORD, "with")(q)) { /* Do nothing. */ }
				} else if (name == "stop") {
					// Do nothing.
				} else if (name == "control") {
					// Do nothing.
				} else if (name == "on") {
					if (must(Token::Types::OPERATOR, "hits")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
					if (must(Token::Types::KEYWORD, "start")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
				} else if (name == "off") {
					if (must(Token::Types::OPERATOR, "hits")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
				} else {
					if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				}
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (forward(Token::Types::OPERATOR, ";")(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::COMMENT)(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::END_OF_LINE)(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::KEYWORD, "read")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
						any()(q);
						if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
					} else {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"actor", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator EmoteM( // Emote manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "emote")(q)) return false;
				if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
				if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "with")(q.index)) {
					any()(q);
					if (!must(Token::Types::KEYWORD, "actor")(q)) return throwInvalidSyntax(q.index);
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (!must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"emote", "_",
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator ProjectileM( // Projectile manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "projectile") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "projectile")(q)) return false;
					if (forward(Token::Types::KEYWORD, "property")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "len")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "width")(q.index) || forward(Token::Types::KEYWORD, "height")(q.index)) {
						any()(q);
					}
				}
				if (name == "def") {
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				} else if (name == "start") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (name == "start") {
					if (must(Token::Types::KEYWORD, "with")(q)) {
						if (!must(Token::Types::KEYWORD, "actor")(q)) return throwInvalidSyntax(q.index);
					}
				} else {
					if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				}
				if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (forward(Token::Types::OPERATOR, ";")(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::COMMENT)(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::END_OF_LINE)(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::KEYWORD, "read")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
						any()(q);
						if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
					} else {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"projectile", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator TriggerM( // Trigger manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;
				Node::Context::Array::Dimensions dimensions;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "trigger") {
					return throwInvalidSyntax(q.index);
				} else {
					if (!must(Token::Types::KEYWORD, "trigger")(q)) return false;
					if (name == "dim") {
						if (!must(Token::Types::OPERATOR, "[")(q)) return throwInvalidSyntax(q.index);
						if (!Numbers(q, children, [&] (const Token::Ptr &tk) -> void {
							int val = 0;
							validate<Word>(tk, val, onError);
							max(tk, val, options.indexBase, onError);
							dimensions.bounds.push_back(val);
						})) return throwInvalidSyntax(q.index);
						CHECK_UNEXPECTED(q);
						if (!must(Token::Types::OPERATOR, "]")(q)) return throwInvalidSyntax(q.index);
					} else if (name == "def") {
						if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
						if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
					} else if (name == "on") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else if (name == "off") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					} else {
						return throwInvalidSyntax(q.index);
					}
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (name == "on") {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (must(Token::Types::KEYWORD, "start")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
				} else if (name == "off") {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				} else {
					if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				}
				if (name == "dim") {
					// Do nothing.
				} else if (forward(Token::Types::KEYWORD, "read")(q.index)) {
					any()(q);
				} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
					any()(q);
					if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
				} else {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (forward(Token::Types::OPERATOR, ";")(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::COMMENT)(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::END_OF_LINE)(q.index)) {
						// Do nothing.
					} else if (forward(Token::Types::KEYWORD, "read")(q.index)) {
						any()(q);
					} else if (forward(Token::Types::KEYWORD, "data")(q.index)) {
						any()(q);
						if (!DataSequence(q, children)) return throwInvalidSyntax(q.index);
					} else {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
								Arguments(q, children);
								CHECK_UNEXPECTED(q);
							}
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				if (dimensions.bounds.size() > 1) return throwTooManyDimensions(q.index);

				Node::Ptr node = createNode(
					"trigger", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator WidgetM( // GUI widget manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "widget") {
					return throwInvalidSyntax(q.index);
				} else {
					if (!must(Token::Types::KEYWORD, "widget")(q)) return false;
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				{
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"widget", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator LabelM( // GUI label manipulations.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "label") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "label")(q)) return false;
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				{
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"label", id->data(),
					{
						{ "allow_call", true },
						{ "put", name == "label" }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator ProgressBarM( // GUI progressbar manipulation.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "progressbar") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "progressbar")(q)) return false;
					if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				{
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"progressbar", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator MenuM( // GUI menu manipulation.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (name == "menu") {
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				} else {
					if (!must(Token::Types::KEYWORD, "menu")(q)) return false;
					if (name == "def") {
						if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
						if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
					} else if (name == "on") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							// Do nothing.
						}
					} else if (name == "off") {
						if (must(Token::Types::OPERATOR, "(")(q)) {
							if (!must(Token::Types::OPERATOR, ")")(q)) return false;
						} else {
							// Do nothing.
						}
					} else {
						return throwInvalidSyntax(q.index);
					}
				}
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (name == "on") {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (must(Token::Types::KEYWORD, "start")(q)) { /* Do nothing. */ }
					else { return throwInvalidSyntax(q.index); }
				} else if (name == "off") {
					// Do nothing.
				}
				if (expectAssign(name) && !must(Token::Types::OPERATOR, "=")(q)) return throwInvalidSyntax(q.index);
				{
					if (must(Token::Types::OPERATOR, "(")(q)) {
						if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
							Arguments(q, children);
							CHECK_UNEXPECTED(q);
						}
						if (!must(Token::Types::OPERATOR, ")")(q)) return false;
					} else {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"menu", id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Scroll( // `SCROLL`.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "scroll")(q)) return false;
				if (!must(Token::Types::OPERATOR, "(")(q)) return throwInvalidSyntax(q.index);
				Arguments(q, children);
				CHECK_UNEXPECTED(q);
				if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				{
					const int n = (int)children.size();
					Token::Ptr node(new Token());
					node
						->type(Token::Types::INTEGER)
						->data(n);
					q.tokens.push_back(node);
				}
				if (!must(Token::Types::KEYWORD, "with")(q)) return throwInvalidSyntax(q.index);
				if (must(Token::Types::OPERATOR, "(")(q)) {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
					if (!must(Token::Types::OPERATOR, ")")(q)) return throwInvalidSyntax(q.index);
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"scroll", "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Touch( // Touch statements.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (
					!(id = must(Token::Types::KEYWORD, "touch")(q)) &&
					!(id = must(Token::Types::KEYWORD, "touchd")(q)) &&
					!(id = must(Token::Types::KEYWORD, "touchu")(q))
				) return false;
				else name = (std::string)id->data();
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Parameters(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Parameters(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					name, "_",
					{
						{ "allow_call", false }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Stream( // Streaming statement.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "stream")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						if (forward(Token::Types::KEYWORD, "end")(q.index)) any()(q);
						else Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					if (forward(Token::Types::KEYWORD, "end")(q.index)) any()(q);
					else Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"stream", "_",
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator CallNative( // Call a native function.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "call")(q)) return false;
				if ((id = must(Token::Types::SYMBOL)(q))) {
					name = (std::string)id->data();
				} else {
					name = "call";
					if (!must(Token::Types::INTEGER)(q)) return throwInvalidSyntax(q.index);
					if (!forward(Token::Types::OPERATOR, ",")(q.index)) return throwInvalidSyntax(q.index);
					else next(q);
					if (!must(Token::Types::INTEGER)(q)) return throwInvalidSyntax(q.index);
				}
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					name, id ? id->data() : "_",
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Call( // Call an API.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!(id = must(Token::Types::SYMBOL)(q))) return false;
				else name = (std::string)id->data();
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					name, id->data(),
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator Raise( // Raise an exception.
			[&] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
				State q = begin();
				Node::Array children;
				Token::Ptr id = nullptr;
				std::string name;

				if (!LineNumber(q, opts)) return false;
				if (!must(Token::Types::KEYWORD, "raise")(q)) return false;
				if (must(Token::Types::OPERATOR, "(")(q)) {
					if (!forward(Token::Types::OPERATOR, ")")(q.index)) {
						Arguments(q, children);
						CHECK_UNEXPECTED(q);
					}
					if (!must(Token::Types::OPERATOR, ")")(q)) return false;
				} else {
					Arguments(q, children);
					CHECK_UNEXPECTED(q);
				}
				maybe(Token::Types::OPERATOR, ";")(q);
				if (!EndOfLine(q)) return throwInvalidSyntax(q.index);

				Node::Ptr node = createNode(
					"raise", "_",
					{
						{ "allow_call", true }
					}
				);
				if (!node) return false;
				node->concat(q.tokens);
				p->add(node);

				q.success = true;
				end(q);

				node->add(children);

				return true;
			}
		);
		const Combinator::List Combinators = {
			/**< Blank. */

			Blank,
			Rem,
			DoNothing,

			/**< Declaration. */

			Const,
			Let,
			Local,
			Dim, ArrayW,

			/**< Conditional. */

			If1, IfN,
			SelectCase,
			On, Off,

			/**< Loop. */

			For, Next,
			While,
			Repeat,
			Exit,

			/**< Jump. */

			Destination,
			Goto,
			Gosub, Return,

			/**< Data sequence. */

			Data, Read, Restore,
			Filler,

			/**< Scope and macros. */

			BeginDo,
			BeginDef,
			DefMacroAlias,
			DefFn,
			DefConstant,
			DefIdentifierAlias,
			DefStackN,

			/**< Stack. */

			Reserve,
			Push, Pop,

			/**< Variable. */

			Pack, Unpack, PackN, UnpackN,
			Swap,
			Inc, Dec,

			/**< Basic. */

			Rgb, Hsv,

			/**< Memory. */

			Memcpy,

			/**< Graphics, input. */

			AutoToggle,
			Toggle,

			ImageM,
			TileM, MapM, WindowM, SpriteM,
			SceneM, ActorM, EmoteM, ProjectileM, TriggerM,
			WidgetM, LabelM, ProgressBarM, MenuM, Scroll,

			Touch,

			/**< Streaming. */

			Stream,

			/**< Invoking. */

			CallNative, Call,

			/**< Error handling. */

			Raise
		};
		Statement = [&options, &Combinators, &cursor] (Node::Ptr &p, const Combinator::Options &opts) -> bool {
			for (int i = 0; i < (int)Combinators.size(); ++i) {
				const Combinator &parse_ = *(Combinators.begin() + i);
				const int cursor_ = cursor;
				if (parse_(p, opts))
					return true;

				cursor = cursor_;
			}

			return false;
		};

		#undef CHECK_UNEXPECTED

		/**< Parse. */

		// Traverse one step.
		auto step = [&] (Node::Ptr &p, NodeError::Ptr &lastErrorNode, const Combinator::Options &opts) -> bool {
			int guard = cursor;
			if (cursor >= (int)tokens.size())
				return false;

			const int cursor_ = cursor;
			if (!Statement(p, opts))
				cursor = cursor_;

			if (cursor == guard) { // Error occurs.
				const Token::Ptr &tk = tokens[cursor];
				if (options.failOnError) {
					if (errors == 0) {
						const Error err("Invalid syntax", false);
						onError(err, err.format(), tk->begin());
					}

					return false;
				} else {
					if (lastErrorNode == nullptr) {
						lastErrorNode = NodeError::Ptr(new NodeError());
						lastErrorNode->concat(tk);

						p->add(lastErrorNode);
					}

					for (EVER) {
						if (++cursor >= (int)tokens.size()) return true;
						if (tokens[cursor]->is(Token::Types::END_OF_LINE)) continue;

						break;
					}
				}
			} else { // No error.
				guard = cursor;

				if (lastErrorNode)
					lastErrorNode = nullptr;
			}

			return true;
		};

		// Traverse through all the tokens.
		NodeError::Ptr lastErrorNode = nullptr;
		const Combinator::Options default_;
		while (cursor < (int)tokens.size()) {
			if (!step(ast, lastErrorNode, default_))
				break;
		}

		// Finish.
		return ast;
	}

	template<typename T> static NodeCreator node(void) {
		return [] (const Statement*) -> Node::Ptr {
			return Node::Ptr(new T());
		};
	}
	template<typename T> static NodeCreator node(Defaults &&) {
		return [] (const Statement* stmt) -> Node::Ptr {
			return Node::Ptr(new T(&stmt->defaults));
		};
	}
	template<typename T> static NodeCreator node(int data) {
		return [data] (const Statement*) -> Node::Ptr {
			return Node::Ptr(new T(data));
		};
	}
	template<typename T> static NodeCreator node(const std::string &data) {
		return [data] (const Statement*) -> Node::Ptr {
			return Node::Ptr(new T(data));
		};
	}
	template<typename T> static NodeCreator node(const std::string &data, Defaults &&) {
		return [data] (const Statement* stmt) -> Node::Ptr {
			return Node::Ptr(new T(data, &stmt->defaults));
		};
	}

	static Token::IntegerTypes typeOf(const Token::Ptr &tk) {
		if (!tk)
			return Token::IntegerTypes::UNSPECIFIED;

		if (tk && tk->text() == "int")
			return Token::IntegerTypes::INT;

		return Token::IntegerTypes::UNSPECIFIED;
	}

	template<typename T, typename U> static bool validate(const Token::Ptr &tk, U &val, Error::Handler onError) {
		const TextLocation &location = tk->begin();
		switch (tk->data().type()) {
		case Variant::INTEGER: {
				const Variant::Int data = (Variant::Int)tk->data();
				val = (U)data;
				if (data < (Variant::Int)std::numeric_limits<T>::min() || data > (Variant::Int)std::numeric_limits<T>::max()) {
					const Error err("Number {0} overflow", true);
					onError(err, err.format({ Text::toString(data) }), location);

					val = (U)Math::clamp(data, (Variant::Int)std::numeric_limits<T>::min(), (Variant::Int)std::numeric_limits<T>::max());

					return false;
				}
			}

			return true;
		case Variant::LONG: {
				const Variant::Long data = (Variant::Long)tk->data();
				val = (U)data;
				if (data < (Variant::Long)std::numeric_limits<T>::min() || data > (Variant::Long)std::numeric_limits<T>::max()) {
					const Error err("Number {0} overflow", true);
					onError(err, err.format({ Text::toString(data) }), location);

					val = (U)Math::clamp(data, (Variant::Long)std::numeric_limits<T>::min(), (Variant::Long)std::numeric_limits<T>::max());

					return false;
				}
			}

			return true;
		case Variant::REAL: {
				const Variant::Real data = (Variant::Real)tk->data();
				const Error err("Number {0} is trimmed to integer", true);
				onError(err, err.format({ Text::toString(data) }), location);

				val = (U)Math::clamp(data, (Variant::Real)std::numeric_limits<T>::min(), (Variant::Real)std::numeric_limits<T>::max());

				return false;
			}
		default: {
				const Error err("Invalid number", true);
				onError(err, err.format(), location);
			}

			return false;
		}
	}
	template<typename R, typename T, typename U> static bool validate(const Token::Ptr &tk, U &val, Error::Handler onError) {
		static_assert((std::is_signed<R>::value && std::is_unsigned<T>::value) || (std::is_signed<T>::value && std::is_unsigned<R>::value), "Must have a signed and an unsigned.");

		const TextLocation &location = tk->begin();
		switch (tk->data().type()) {
		case Variant::NIL: {
				const Error err("Invalid number", false);
				onError(err, err.format(), location);
			}

			return false;
		case Variant::INTEGER: {
				const Variant::Int data = (Variant::Int)tk->data();
				val = (U)data;
			}

			break;
		case Variant::LONG: {
				const Variant::Long data = (Variant::Long)tk->data();
				val = (U)data;
			}

			break;
		case Variant::REAL: {
				const Variant::Real data = (Variant::Real)tk->data();
				const Error err("Number {0} is trimmed to integer", true);
				onError(err, err.format({ Text::toString(data) }), location);

				val = (U)data;
			}

			break;
		default: {
				const Error err("Invalid number", true);
				onError(err, err.format(), location);
			}

			return false;
		}
		if (std::is_signed<R>::value) {
			if (val >= (Variant::Int)std::numeric_limits<R>::min() && val < 0)
				return true;

			return validate<T>(tk, val, onError);
		} else {
			if (val >= (Variant::Int)std::numeric_limits<T>::min() && val < 0)
				return true;

			return validate<R>(tk, val, onError);
		}
	}

	template<typename U> static bool max(const Token::Ptr &tk, U &val, U M, Error::Handler onError) {
		if (val < M) {
			const TextLocation &location = tk->begin();
			switch (tk->data().type()) {
			case Variant::INTEGER: {
					const Variant::Int data = (Variant::Int)tk->data();
					const Error err("Number {0} overflow", true);
					onError(err, err.format({ Text::toString(data) }), location);
				}

				break;
			case Variant::LONG: {
					const Variant::Long data = (Variant::Long)tk->data();
					const Error err("Number {0} overflow", true);
					onError(err, err.format({ Text::toString(data) }), location);
				}

				break;
			case Variant::REAL: {
					const Variant::Real data = (Variant::Real)tk->data();
					const Error err("Number {0} overflow", true);
					onError(err, err.format({ Text::toString(data) }), location);
				}

				break;
			default: {
					const Error err("Invalid number", true);
					onError(err, err.format(), location);
				}

				break;
			}

			val = Math::max(val, M);

			return false;
		}

		return true;
	}
};

}

/* ===========================================================================} */

/*
** {===========================================================================
** Organizer
*/

namespace GBBASIC {

class Organizer final {
public:
	typedef std::vector<Node::Ptr> Nodes;

private:
	Node::Ptr _ast = nullptr;

public:
	Organizer() {
	}
	~Organizer() {
	}

	const Node::Ptr &ast(void) const {
		return _ast;
	}

	bool process(const Nodes &nodes) {
		// Prepare.
		_ast = nullptr;

		// Organize the AST nodes.
		_ast = organize(nodes);

		// Finish.
		return !!_ast;
	}

private:
	static Node::Ptr organize(const Nodes &nodes) {
		// Prepare.
		Node::Ptr ast(new NodeProgram());

		// Put the AST nodes into a single tree structure.
		ast->add(nodes);

		// Finish.
		return ast;
	}
};

}

/* ===========================================================================} */

/*
** {===========================================================================
** Compiler
*/

namespace GBBASIC {

class Compiler final {
private:
	struct Options {
		GBBASIC::Options::Passes passes = GBBASIC::Options::Passes::FULL;
		GBBASIC::Options::Strategies::Compatibilities compatibility = GBBASIC::Options::Strategies::Compatibilities::CLASSIC | GBBASIC::Options::Strategies::Compatibilities::COLORED;
		int sramType = 0x03;
		bool cartridgeHasRtc = true;
		int bankSize = 0;
		int bank = 0;
		int startAddress = 0;
		int heapSize = 0;
		int stackSize = 0;
		bool caseInsensitive = true;
		bool declarationRequired = true;
		bool optimizeCode = true;
		bool optimizeAssets = true;

		Options() {
		}
	};

private:
	Options _options;
	Asm::Instructions _instructions = Asm::INSTRUCTIONS;
	Node::Context::Array _array;
	Node::Context::Data _data;
	SymbolTable _symbols;
	BuiltinTable _builtins;
	FunctionTable _functions;
	OperatorTable _operators;
	Node::MacroAliasTable::Stack _macroAliases;
	Node::MacroFunctionTable::Stack _macroFunctions;
	Node::MacroConstantTable::Stack _macroConstants;
	Node::MacroIdentifierAliasTable::Stack _macroIdentifierAliases;
	Node::MacroStackReferenceTable::Stack _macroStackReferences;
	AssetsBundle::Ptr _assets = nullptr;

	Bytes::Ptr _bytes = nullptr;

public:
	Compiler() {
	}
	~Compiler() {
	}

	Variant option(const std::string &key) const {
		if (key == "passes")
			return (Variant::Long)_options.passes;
		if (key == "compatibility")
			return (Variant::Long)_options.compatibility;
		if (key == "sram_type")
			return (Variant::Long)_options.sramType;
		if (key == "has_rtc")
			return (bool)_options.cartridgeHasRtc;
		if (key == "bank_size")
			return (Variant::Long)_options.bankSize;
		if (key == "bank")
			return (Variant::Long)_options.bank;
		if (key == "start_address")
			return (Variant::Long)_options.startAddress;
		if (key == "heap_size")
			return (Variant::Long)_options.heapSize;
		if (key == "stack_size")
			return (Variant::Long)_options.stackSize;
		if (key == "case_insensitive")
			return (bool)_options.caseInsensitive;
		if (key == "declaration_required")
			return (bool)_options.declarationRequired;
		if (key == "index_base")
			return (Variant::Long)_array.base;
		if (key == "optimize_code")
			return (bool)_options.optimizeCode;
		if (key == "optimize_assets")
			return (bool)_options.optimizeAssets;

		GBBASIC_ASSERT(false && "Unknown option.");

		return nullptr;
	}
	bool option(const std::string &key, const Variant &val) {
		if (key == "passes") {
			_options.passes = (GBBASIC::Options::Passes)(int)val;

			return true;
		}
		if (key == "compatibility") {
			_options.compatibility = (GBBASIC::Options::Strategies::Compatibilities)(int)val;

			return true;
		}
		if (key == "sram_type") {
			_options.sramType = (int)val;

			return true;
		}
		if (key == "has_rtc") {
			_options.cartridgeHasRtc = (bool)val;

			return true;
		}
		if (key == "bank_size") {
			_options.bankSize = (int)val;

			return true;
		}
		if (key == "bank") {
			_options.bank = (int)val;

			return true;
		}
		if (key == "start_address") {
			_options.startAddress = (int)val;

			return true;
		}
		if (key == "heap_size") {
			_options.heapSize = (int)val;

			return true;
		}
		if (key == "stack_size") {
			_options.stackSize = (int)val;

			return true;
		}
		if (key == "case_insensitive") {
			_options.caseInsensitive = (bool)val;

			return true;
		}
		if (key == "declaration_required") {
			_options.declarationRequired = (bool)val;

			return true;
		}
		if (key == "index_base") {
			_array.base = (int)val;

			return true;
		}
		if (key == "optimize_code") {
			_options.optimizeCode = (bool)val;

			return true;
		}
		if (key == "optimize_assets") {
			_options.optimizeAssets = (bool)val;

			return true;
		}

		GBBASIC_ASSERT(false && "Unknown option.");

		return false;
	}
	const Asm::Instructions &instructions(void) const {
		return _instructions;
	}
	Node::Context::Array &array(void) {
		return _array;
	}
	Node::Context::Data &data(void) {
		return _data;
	}
	SymbolTable &symbols(void) {
		return _symbols;
	}
	void symbols(const SymbolTable &tbl) {
		_symbols = tbl;
	}
	BuiltinTable &builtins(void) {
		return _builtins;
	}
	FunctionTable &functions(void) {
		return _functions;
	}
	OperatorTable &operators(void) {
		return _operators;
	}
	Node::MacroAliasTable::Stack &macroAliases(void) {
		return _macroAliases;
	}
	Node::MacroFunctionTable::Stack &macroFunctions(void) {
		return _macroFunctions;
	}
	Node::MacroConstantTable::Stack &macroConstants(void) {
		return _macroConstants;
	}
	Node::MacroIdentifierAliasTable::Stack &macroIdentifierAliases(void) {
		return _macroIdentifierAliases;
	}
	Node::MacroStackReferenceTable::Stack &macroStackReferences(void) {
		return _macroStackReferences;
	}

	const Bytes::Ptr &bytes(void) const {
		return _bytes;
	}

	bool process(const Node::Ptr &ast, AssetsBundle::Ptr assets, Pipeline::Ptr pipeline, RamLocation::Dictionary* allocations, int* compiledSize, Error::Handler onError) {
		// Prepare.
		_bytes = nullptr;
		if (!ast)
			return false;

		int errorCount = 0;
		Error::Handler gotError = [&] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
			if (!err.isWarning)
				++errorCount;
			onError(err, msg, loc);
		};

		_assets = assets;

		// Generate VM code from the AST.
		_bytes = generate(
			ast, _options,
			_instructions,
			_array, _data,
			_symbols,
			_builtins, _functions, _operators,
			_macroAliases,
			_macroFunctions,
			_macroConstants,
			_macroIdentifierAliases,
			_macroStackReferences,
			_assets,
			pipeline,
			allocations,
			compiledSize,
			gotError
		);

		// Finish.
		tidy(
			_builtins,
			_macroAliases,
			_macroFunctions,
			_macroConstants,
			_macroIdentifierAliases,
			_macroStackReferences
		);

		_assets = nullptr;

		return errorCount == 0;
	}

private:
	static Bytes::Ptr generate(
		const Node::Ptr &ast, const Options &options,
		const Asm::Instructions &instructions,
		const Node::Context::Array &array,
		const Node::Context::Data &data,
		const SymbolTable &symbols,
		const BuiltinTable &builtins, const FunctionTable &functions, const OperatorTable &operators,
		Node::MacroAliasTable::Stack &macroAliases,
		Node::MacroFunctionTable::Stack &macroFunctions,
		Node::MacroConstantTable::Stack &macroConstants,
		Node::MacroIdentifierAliasTable::Stack &macroIdentifierAliases,
		Node::MacroStackReferenceTable::Stack &macroStackReferences,
		AssetsBundle::Ptr assets,
		Pipeline::Ptr pipeline,
		RamLocation::Dictionary* allocations,
		int* compiledSize,
		Error::Handler onError
	) {
		// Prepare.
		Bytes::Ptr bytes(Bytes::create());

		// Setup the generation context.
		Node::Context::Stack context;
		context.push(Node::Context());
		context.top().compatibility                   =  options.compatibility;
		context.top().sramType                        =  options.sramType;
		context.top().cartridgeHasRtc                 =  options.cartridgeHasRtc;
		context.top().startBank                       =  options.bank;
		context.top().bankSize                        =  options.bankSize;
		context.top().startAddress                    =  options.startAddress;
		context.top().bank                            =  options.bank;
		context.top().heapSize                        =  options.heapSize;
		context.top().stackSize                       =  options.stackSize;
		context.top().caseInsensitive                 =  options.caseInsensitive;
		context.top().declaration.declarationRequired =  options.declarationRequired;
		context.top().expression.optimize             =  options.optimizeCode;
		context.top().instructions                    = &instructions;
		context.top().array                           = &array;
		context.top().data                            = &data;
		context.top().symbols                         = &symbols;
		context.top().builtins                        = &builtins;
		context.top().functions                       = &functions;
		context.top().operators                       = &operators;
		(void)                                           macroAliases;           // FEAT: MACRO.
		context.top().macroFunctions                  = &macroFunctions;         // FEAT: MACRO.
		(void)                                           macroConstants;         // FEAT: MACRO.
		(void)                                           macroIdentifierAliases; // FEAT: MACRO.
		(void)                                           macroStackReferences;   // FEAT: MACRO.
		context.top().assets                          =  assets;
		context.top().pipeline                        =  pipeline;

		if (options.passes <= GBBASIC::Options::Passes::GENERATE) {
			ast->generate(bytes, context, onError); // Generate code.
			*compiledSize = (int)bytes->count();
		} else {
			// DOC: ROM SCHEMA.
			// Generate ROM data, layout is in the order of:
			//   code-based and glyph
			//     `DATA` sequence
			//     compiled code
			//     glyph data
			//   asset-based
			//     assets data
			ast->generate(bytes, context, onError); // Generate code.
			*compiledSize = (int)bytes->count();
			{
				pipeline->romMaxSize(ROM_MAX_SIZE);
				pipeline->compatibility((unsigned)options.compatibility);
				pipeline->startBank(context.top().startBank);
				pipeline->bankSize(context.top().bankSize);
				pipeline->startAddress(context.top().startAddress);
				pipeline->bank(&context.top().bank);
				pipeline->addressCursor(&context.top().addressCursor);
				pipeline->bytes(bytes);
				pipeline->codeLocationHandler(
					[&context] (const std::string &where, int* bank, int* address, int* size) -> bool {
						Node::Context &ctx = context.top();

						if (where.empty())
							return false;

						int page = -1;
						Node::Destination dest(0);
						if (!Node::flatNumericOrLabeledDestinationString(context, where, page, &dest))
							return false;

						SourceLocation target;
						if (dest.isLeft()) {
							target = SourceLocation(page, dest.left().get()); // `#pg:lno`. By line number.
						} else {
							std::string key = dest.right().get();
							if (ctx.caseInsensitive)
								Text::toLowerCase(key);
							target = SourceLocation(page, key); // `#pg:lbl`. By label.
						}

						const RomLocation* romLocation = ctx.find(target);
						if (!romLocation)
							return false;

						if (bank)
							*bank = romLocation->bank;
						if (address)
							*address = ctx.startAddress + romLocation->address;
						if (size)
							*size = romLocation->size;

						return true;
					}
				);
				pipeline->pipe(assets, false, options.optimizeAssets); // Generate resources.
			}
			ast->post(bytes, context, onError); // Post process.
		}
		GBBASIC_ASSERT(context.size() == 1 && "Corrupt stack.");

		// Finish.
		*allocations = context.top().allocations();

		return bytes;
	}
	static void tidy(
		BuiltinTable &builtins,
		Node::MacroAliasTable::Stack &macroAliases,
		Node::MacroFunctionTable::Stack &macroFunctions,
		Node::MacroConstantTable::Stack &macroConstants,
		Node::MacroIdentifierAliasTable::Stack &macroIdentifierAliases,
		Node::MacroStackReferenceTable::Stack &macroStackReferences
	) {
		builtins.filter(
			[] (const std::string &, const BuiltinTable::Entry &entry) -> bool {
				return entry.type != BuiltinTable::Entry::Types::USER_DEFINED;
			}
		);
		macroAliases.clear();
		macroFunctions.clear();
		macroConstants.clear();
		macroIdentifierAliases.clear();
		macroStackReferences.clear();
	}
};

}

/* ===========================================================================} */

/*
** {===========================================================================
** Programmer
*/

namespace GBBASIC {

class Programmer final {
private:
	struct Options {
		GBBASIC::Options::Strategies::Compatibilities compatibility = GBBASIC::Options::Strategies::Compatibilities::CLASSIC | GBBASIC::Options::Strategies::Compatibilities::COLORED;
		bool trimUnusedBanks = false;
		int sramType = 0x03;
		bool cartridgeHasRtc = true;
		int romMaxSize = 0;
		int bankSize = 0;
		int bank = 0;
		int startAddress = 0;
		Bytes::Ptr icon = nullptr;
		Bytes::Ptr backgroundPalettes = nullptr;
		Bytes::Ptr spritePalettes = nullptr;
		std::string title;

		Options() {
		}
	};

private:
	Options _options;
	SymbolTable _symbols;

	Bytes::Ptr _bytes = nullptr;

public:
	Programmer() {
	}
	~Programmer() {
	}

	Variant option(const std::string &key) const {
		if (key == "compatibility")
			return (Variant::Long)_options.compatibility;
		if (key == "trim_unused_banks")
			return (bool)_options.trimUnusedBanks;
		if (key == "sram_type")
			return (Variant::Long)_options.sramType;
		if (key == "has_rtc")
			return (bool)_options.cartridgeHasRtc;
		if (key == "rom_max_size")
			return (Variant::Long)_options.romMaxSize;
		if (key == "bank_size")
			return (Variant::Long)_options.bankSize;
		if (key == "bank")
			return (Variant::Long)_options.bank;
		if (key == "start_address")
			return (Variant::Long)_options.startAddress;
		if (key == "icon")
			return (Object::Ptr)_options.icon;
		if (key == "background_palettes")
			return (Object::Ptr)_options.backgroundPalettes;
		if (key == "sprite_palettes")
			return (Object::Ptr)_options.spritePalettes;
		if (key == "title")
			return (std::string)_options.title;

		GBBASIC_ASSERT(false && "Unknown option.");

		return nullptr;
	}
	bool option(const std::string &key, const Variant &val) {
		if (key == "compatibility") {
			_options.compatibility = (GBBASIC::Options::Strategies::Compatibilities)(int)val;

			return true;
		}
		if (key == "trim_unused_banks") {
			_options.trimUnusedBanks = (bool)val;

			return true;
		}
		if (key == "sram_type") {
			_options.sramType = (int)val;

			return true;
		}
		if (key == "has_rtc") {
			_options.cartridgeHasRtc = (bool)val;

			return true;
		}
		if (key == "rom_max_size") {
			_options.romMaxSize = (int)val;

			return true;
		}
		if (key == "bank_size") {
			_options.bankSize = (int)val;

			return true;
		}
		if (key == "bank") {
			_options.bank = (int)val;

			return true;
		}
		if (key == "start_address") {
			_options.startAddress = (int)val;

			return true;
		}
		if (key == "icon") {
			Object::Ptr obj = (Object::Ptr)val;
			if (obj)
				_options.icon = Object::as<Bytes::Ptr>(obj);

			return true;
		}
		if (key == "background_palettes") {
			Object::Ptr obj = (Object::Ptr)val;
			if (obj)
				_options.backgroundPalettes = Object::as<Bytes::Ptr>(obj);

			return true;
		}
		if (key == "sprite_palettes") {
			Object::Ptr obj = (Object::Ptr)val;
			if (obj)
				_options.spritePalettes = Object::as<Bytes::Ptr>(obj);

			return true;
		}
		if (key == "title") {
			_options.title = (std::string)val;

			return true;
		}

		GBBASIC_ASSERT(false && "Unknown option.");

		return false;
	}
	SymbolTable &symbols(void) {
		return _symbols;
	}
	void symbols(const SymbolTable &tbl) {
		_symbols = tbl;
	}

	const Bytes::Ptr &bytes(void) const {
		return _bytes;
	}

	bool process(const Bytes::Ptr &rom, const Bytes::Ptr &compiled, Error::Handler onError) {
		// Prepare.
		_bytes = nullptr;
		if (!rom || !compiled)
			return false;

		int errorCount = 0;
		Error::Handler gotError = [&] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
			if (!err.isWarning)
				++errorCount;
			onError(err, msg, loc);
		};

		// Program the ROM with the specific bytes.
		_bytes = program(rom, compiled, _options, _symbols, gotError);

		// Finish.
		return errorCount == 0;
	}

private:
	static Bytes::Ptr program(const Bytes::Ptr &rom, const Bytes::Ptr &compiled, const Options &options, const SymbolTable &symbols, Error::Handler onError) {
		// Prepare.
		Bytes::Ptr bytes(Bytes::create());

		// Write the generated bytes to the ROM
		bytes->writeBytes(rom.get()); // Write the ROM.
		const int beginning = (options.bank - 1) * options.bankSize + options.startAddress;
		bytes->poke(beginning);
		const int wrote = bytes->writeBytes(compiled.get()); // Write the compiled bytecode.
		const int rest = options.bankSize - wrote % options.bankSize;
		bool resized = bytes->peek() > rom->count();
		if (resized && (int)bytes->count() >= options.romMaxSize) {
			const Error err("ROM overflow", false);
			onError(err, err.format(), TextLocation::INVALID());

			return bytes;
		}

		// Fill tail data with `COMPILER_INVALID_INSTRUCTION` to the rest of the current bank.
		bytes->writeBytes(COMPILER_INVALID_INSTRUCTION, rest);

		// Resize banks.
		int banks = Math::ceilIntegerTimesOf((int)compiled->count(), options.bankSize) + options.bank;
		int cartridgeRomSize = (int)std::ceil(std::log2(banks));

		banks = (int)Math::pow(2, cartridgeRomSize);
		--cartridgeRomSize;
		const int finalSize = banks * options.bankSize;

		bytes->poke(bytes->count());
		if ((int)bytes->count() < finalSize) {
			bytes->writeBytes(COMPILER_INVALID_INSTRUCTION, finalSize - (int)bytes->count());
		} else if ((int)bytes->count() > finalSize) {
			if (options.trimUnusedBanks) {
				bytes->resize((size_t)finalSize);
				resized |= true;
			}
		}

		// Get the compatibility information.
		const bool classic = (options.compatibility & GBBASIC::Options::Strategies::Compatibilities::CLASSIC) != GBBASIC::Options::Strategies::Compatibilities::NONE;
		const bool colored = (options.compatibility & GBBASIC::Options::Strategies::Compatibilities::COLORED) != GBBASIC::Options::Strategies::Compatibilities::NONE;
		const bool extension = (options.compatibility & GBBASIC::Options::Strategies::Compatibilities::EXTENSION) != GBBASIC::Options::Strategies::Compatibilities::NONE;

		// Fill the ROM constants.
		if (options.icon) {
			do {
				constexpr const size_t SIZE = (GBBASIC_ICON_WIDTH / GBBASIC_TILE_SIZE) * GBBASIC_ICON_HEIGHT * 2;
				if (options.icon->count() != SIZE) {
					const Error err("Invalid icon size", true);
					onError(err, err.format(), TextLocation::INVALID());

					break;
				}

				const RomLocation* romLocation = symbols.find(ICON_ENTRY_NAME);
				if (!romLocation) {
					const Error err("Invalid icon asset point", true);
					onError(err, err.format(), TextLocation::INVALID());

					break;
				}

				const int bank = romLocation->bank;
				const int address = romLocation->address;
				const int offset = (bank * options.bankSize) + (address - options.startAddress);
				Byte* ptr = bytes->pointer() + offset;
				memcpy(ptr, options.icon->pointer(), SIZE);
			} while (false);
		}

		do {
			const UInt8 extensionMode = extension ? TRUE : FALSE;

			constexpr const size_t SIZE = 1;
			const RomLocation* romLocation = symbols.find(EXTENSION_MODE_ENTRY_NAME);
			if (!romLocation) {
				const Error err("Invalid extension mode point", true);
				onError(err, err.format(), TextLocation::INVALID());

				break;
			}

			const int bank = romLocation->bank;
			const int address = romLocation->address;
			const int offset = (bank * options.bankSize) + (address - options.startAddress);
			Byte* ptr = bytes->pointer() + offset;
			memcpy(ptr, &extensionMode, SIZE);
		} while (false);

		if (options.backgroundPalettes) {
			do {
				constexpr const size_t SIZE = 4 * 8 * 2;
				if (options.backgroundPalettes->count() != SIZE) {
					const Error err("Invalid background palettes size", true);
					onError(err, err.format(), TextLocation::INVALID());

					break;
				}

				const RomLocation* romLocation = symbols.find(BACKGROUND_PALETTES_ENTRY_NAME);
				if (!romLocation) {
					const Error err("Invalid background palettes asset point", true);
					onError(err, err.format(), TextLocation::INVALID());

					break;
				}

				const int bank = romLocation->bank;
				const int address = romLocation->address;
				const int offset = (bank * options.bankSize) + (address - options.startAddress);
				Byte* ptr = bytes->pointer() + offset;
				memcpy(ptr, options.backgroundPalettes->pointer(), SIZE);
			} while (false);
		}

		if (options.spritePalettes) {
			do {
				constexpr const size_t SIZE = 4 * 8 * 2;
				if (options.spritePalettes->count() != SIZE) {
					const Error err("Invalid sprite palettes size", true);
					onError(err, err.format(), TextLocation::INVALID());

					break;
				}

				const RomLocation* romLocation = symbols.find(SPRITE_PALETTES_ENTRY_NAME);
				if (!romLocation) {
					const Error err("Invalid sprite palettes asset point", true);
					onError(err, err.format(), TextLocation::INVALID());

					break;
				}

				const int bank = romLocation->bank;
				const int address = romLocation->address;
				const int offset = (bank * options.bankSize) + (address - options.startAddress);
				Byte* ptr = bytes->pointer() + offset;
				memcpy(ptr, options.spritePalettes->pointer(), SIZE);
			} while (false);
		}

		do {
			UInt16 signature = 0x9ba5; // Initialize with a magic number.
			for (int i = 0; i < (int)options.title.length(); i += 2) {
				const char ch0 = options.title[i];
				const char ch1 = (i + 1) < (int)options.title.length() ? options.title[i + 1] : '\0';
				signature += ch0 | (ch1 << 8); // Hash signature with the program title.
			}

			constexpr const size_t SIZE = 2;
			const RomLocation* romLocation = symbols.find(PERSISTENCE_SIGNATURE_ENTRY_NAME);
			if (!romLocation) {
				const Error err("Invalid persistence signature point", true);
				onError(err, err.format(), TextLocation::INVALID());

				break;
			}

			const int bank = romLocation->bank;
			const int address = romLocation->address;
			const int offset = (bank * options.bankSize) + (address - options.startAddress);
			Byte* ptr = bytes->pointer() + offset;
			memcpy(ptr, &signature, SIZE);
		} while (false);

		// Fill and validate in the ROM header.
		RomInspector header;
		header.load(bytes);
		{
			// Set the game title.
			header.setTitle(options.title);

			// Set the compatibility.
			if (colored) {
				if (classic)
					header.setClassicAndColoredSupport(extension);
				else
					header.setColoredSupportOnly(extension);
			} else {
				header.setClassicSupportOnly(extension);
			}

			// DOC: CARTRIDGE SCHEMA.
			// Set the ROM size.
			// ROM size code:
			//   0x00 -  32KB (no ROM banking)
			//   0x01 -  64KB (  4 banks)
			//   0x02 - 128KB (  8 banks)
			//   0x03 - 256KB ( 16 banks)
			//   0x04 - 512KB ( 32 banks)
			//   0x05 -   1MB ( 64 banks), only 63 banks used by MBC1
			//   0x06 -   2MB (128 banks), only 125 banks used by MBC1
			//   0x07 -   4MB (256 banks)
			//   0x08 -   8MB (512 banks)
			//   0x52 - 1.1MB ( 72 banks)
			//   0x53 - 1.2MB ( 80 banks)
			//   0x54 - 1.5MB ( 96 banks)
			const bool cartridgeHasRtc = options.cartridgeHasRtc;
			if (cartridgeHasRtc && cartridgeRomSize > 0x06) {
				const Error err("ROM overflow with RTC enabled, consider shrinking the ROM or disabling the RTC feature", false);
				onError(err, err.format(), TextLocation::INVALID());

				return bytes;
			}
			if (resized) {
				const std::string romSizeStr = Text::toHex(cartridgeRomSize, 2, '0', true);
				header.setRomSizeCode(romSizeStr);
			}

			// DOC: CARTRIDGE SCHEMA.
			// Set the RAM size.
			// SRAM size code:
			//   0x00 -   0KB
			//   0x01 -   2KB
			//   0x02 -   8KB
			//   0x03 -  32KB ( 4 banks of 8KB each)
			//   0x04 - 128KB (16 banks of 8KB each)
			//   0x05 -  64KB ( 8 banks of 8KB each)
			const int sramType = Math::clamp(options.sramType, 0x00, 0x04);
			if (cartridgeHasRtc && sramType > 0x03) {
				const Error err("SRAM is too big with RTC enabled, consider shrinking the SRAM or disabling the RTC feature", false);
				onError(err, err.format(), TextLocation::INVALID());

				return bytes;
			}
			const std::string sramTypeStr = Text::toHex(sramType, 2, '0', true);
			header.setRamSizeCode(sramTypeStr);

			// DOC: CARTRIDGE SCHEMA.
			// Set the cartridge type:
			//   00 ROM                             01 MBC1                    02 MBC1 + RAM
			//   03 MBC1 + RAM + BATTERY            05 MBC2                    06 MBC2 + BATTERY
			//   08 ROM + RAM                       09 ROM + RAM + BATTERY     0B MMM01
			//   0C MMM01 + RAM                     0D MMM01 + RAM + BATTERY   0F MBC3 + TIMER + BATTERY
			//   10 MBC3 + TIMER + RAM + BATTERY    11 MBC3                    12 MBC3 + RAM
			//   13 MBC3 + RAM + BATTERY            15 MBC4                    16 MBC4 + RAM
			//   17 MBC4 + RAM + BATTERY            19 MBC5                    1A MBC5 + RAM
			//   1B MBC5 + RAM + BATTERY            1C MBC5 + RUMBLE           1D MBC5 + RUMBLE + RAM
			//   1E MBC5 + RUMBLE + RAM + BATTERY   FC POCKET CAMERA           FD Bandai TAMA5
			//   FE HuC3                            FF HuC1 + RAM + BATTERY
			if (cartridgeHasRtc) {
				header.setCartridgeTypeCode(
					sramType == 0x00 ?
						"0f" /* MBC3 + TIMER + BATTERY */ :
						"10" /* MBC3 + TIMER + RAM + BATTERY */
				);
			} else {
				header.setCartridgeTypeCode(
					sramType == 0x00 ?
						"19" /* MBC5 */ :
						"1b" /* MBC5 + RAM + BATTERY */
				);
			}

			// Set the correct header checksum.
			const std::string headerChecksum = header.getCorrectHeaderChecksum();
			header.setHeaderChecksum(headerChecksum);

			// Set the correct global checksum.
			const std::string globalChecksum = header.getCorrectGlobalChecksum();
			header.setGlobalChecksum(globalChecksum);
		}
		header.unload();

		// Finish.
		bytes->poke(0);

		return bytes;
	}
};

}

/* ===========================================================================} */

/*
** {===========================================================================
** Public functions
*/

namespace GBBASIC {

bool load(Program &program, Options &options) {
	// Prepare.
	const std::string &src              = options.input;
	const std::string &rom              = options.rom;
	const std::string &sym              = options.sym;
	const std::string &aliases          = options.aliases;
	const std::string &font             = options.font;
	const Options::PrintHandler onPrint = options.onPrint;
	const Options::ErrorHandler onError = options.onError;

	const bool hasAssets = program.assets != nullptr;
	if (hasAssets) {
		GBBASIC_ASSERT(src.empty() && "Invalid data.");
	} else {
		program.assets = AssetsBundle::Ptr(new AssetsBundle());
	}

	int errors = 0;

	onPrint("Reading...");

	// Load the fonts.
	auto onFontWarningOrError = [onError] (const char* msg, bool isWarning) -> void {
		(void)isWarning;

		onError(msg, true, -1, -1, -1);
	};
	do {
		// Prepare.
		if (hasAssets)
			break;

		if (font.empty())
			break;

		program.assets->fonts.clear();

		// Read the font configuration file.
		File::Ptr file(File::create());
		if (!file->open(font.c_str(), Stream::READ)) {
			onError("Cannot open the font config file.", true, -1, -1, -1);
			++errors;

			break;
		}
		std::string font_;
		if (!file->readString(font_)) {
			file->close();
			onError("Failed to read the font.", true, -1, -1, -1);
			++errors;

			break;
		}
		file->close();

		std::string dir;
		Path::split(font, nullptr, nullptr, &dir);
		FontAssets fonts;
		if (!fonts.fromString(font_, dir, false, onFontWarningOrError))
			break;

		for (int i = 0; i < fonts.count(); ++i) {
			const FontAssets::Entry* entry = fonts.get(i);
			if (!entry)
				continue;

			program.assets->fonts.add(*entry);
		}
		onPrint("Succeeded to load the font.");
	} while (false);

	// Load the symbols.
	do {
		// Prepare.
		std::string path = sym;
		if (path.empty()) {
			path = rom;
			if (Text::endsWith(path, ".gb", true))
				path = path.substr(0, path.length() - 3);
			else if (Text::endsWith(path, ".gbc", true))
				path = path.substr(0, path.length() - 4);
			path += ".sym";
			if (!Path::existsFile(path.c_str()))
				path.clear();
		}
		if (path.empty())
			break;
		if (!Path::existsFile(path.c_str()))
			break;

		// Read the symbol file.
		File::Ptr file(File::create());
		if (!file->open(path.c_str(), Stream::READ)) {
			onError("Cannot open the symbol file.", true, -1, -1, -1);
			++errors;

			break;
		}
		std::string symbols;
		if (!file->readString(symbols)) {
			file->close();
			onError("Failed to read the symbols.", true, -1, -1, -1);
			++errors;

			break;
		}
		file->close();

		program.symbols = symbols;
		onPrint("Succeeded to load the symbols.");
	} while (false);

	do {
		// Prepare.
		std::string path = aliases;
		if (path.empty()) {
			path = rom;
			if (Text::endsWith(path, ".gb", true))
				path = path.substr(0, path.length() - 3);
			else if (Text::endsWith(path, ".gbc", true))
				path = path.substr(0, path.length() - 4);
			path += ".aliases.json";
			if (!Path::existsFile(path.c_str()))
				path.clear();
		}
		if (path.empty())
			break;
		if (!Path::existsFile(path.c_str()))
			break;

		// Read the aliases file.
		File::Ptr file(File::create());
		if (!file->open(path.c_str(), Stream::READ)) {
			onError("Cannot open the aliases file.", true, -1, -1, -1);
			++errors;

			break;
		}
		std::string aliases;
		if (!file->readString(aliases)) {
			file->close();
			onError("Failed to read the aliases.", true, -1, -1, -1);
			++errors;

			break;
		}
		file->close();

		program.aliases = aliases;
		onPrint("Succeeded to load the aliases.");
	} while (false);

	// Load the source.
	do {
		// Prepare.
		if (hasAssets)
			break;

		// Read the source.
		File::Ptr file(File::create());
		if (!file->open(src.c_str(), Stream::READ)) {
			onError("Cannot open the source file.", false, -1, -1, -1);
			++errors;

			break;
		}
		std::string source;
		if (!file->readString(source)) {
			file->close();
			onError("Failed to read the source.", false, -1, -1, -1);
			++errors;

			break;
		}
		file->close();

		// Split the pages.
		const std::string sectionBegin = COMPILER_PROGRAM_BEGIN;
		const std::string sectionEnd = COMPILER_PROGRAM_END;
		const size_t beginIndex = Text::indexOf(source, sectionBegin);
		const size_t endIndex = Text::indexOf(source, sectionEnd, beginIndex + sectionBegin.length());
		if (beginIndex == std::string::npos && endIndex == std::string::npos) { // Is a plain source code file.
			program.isPlain = true;

			CodeAssets code;
			code.add(source);
			program.assets->code = code;
		} else { // Is a rich project file.
			// Prepare.
			std::string prog = Text::trim(source);
			int i = 0;
			int j = 0;

			auto retrieve = [&j] (const std::string &prog, const std::string &sectionBegin, const std::string &sectionEnd, std::string &section) -> bool {
				const size_t beginIndex = Text::indexOf(prog, sectionBegin);
				if (beginIndex == std::string::npos)
					return false;
				++j;
				const size_t endIndex = Text::indexOf(prog, sectionEnd, beginIndex + sectionBegin.length());
				if (endIndex == std::string::npos)
					return false;
				--j;

				section = prog.substr(beginIndex + sectionBegin.length(), endIndex - (beginIndex + sectionBegin.length()));

				return true;
			};

			program.isPlain = false;

			// Parse the title.
			do {
				std::string section;
				if (!retrieve(prog, COMPILER_INFO_BEGIN, COMPILER_INFO_END, section))
					break;

				section = Text::trim(section);

				rapidjson::Document doc;
				if (!Json::fromString(doc, section.c_str()))
					break;
				if (!Jpath::get(doc, section, "title"))
					break;
				options.title = section;
			} while (false);

			// Parse the font.
			do {
				std::string section;
				if (!retrieve(prog, COMPILER_FONT_BEGIN, COMPILER_FONT_END, section))
					break;

				section = Text::trimLeft(section);

				std::string dir;
				Path::split(src, nullptr, nullptr, &dir);
				FontAssets fonts;
				if (!fonts.fromString(section, dir, true, onFontWarningOrError))
					break;

				for (int i = 0; i < fonts.count(); ++i) {
					const FontAssets::Entry* entry = fonts.get(i);
					if (!entry)
						continue;

					program.assets->fonts.add(*entry);
				}
			} while (false);

			// Parse the code pages.
			CodeAssets code;
			for (EVER) {
				std::string section;
				if (!retrieve(prog, Text::format(COMPILER_CODE_BEGIN, Text::toString(i), 0), COMPILER_CODE_END, section))
					break;

				section = Text::trimLeft(section);

				code.add(section);
				++i;
			}
			program.assets->code = code;

			// Finish.
			if (j != 0) {
				onError("Unmatched section tag.", false, -1, -1, -1);
				++errors;

				break;
			}
		}

		onPrint("Succeeded to load the source.");
	} while (false);

	// Load the ROM.
	do {
		// Read the ROM.
		File::Ptr file(File::create());
		if (!file->open(rom.c_str(), Stream::READ)) {
			onError("Failed to open the kernel.", false, -1, -1, -1);
			++errors;

			break;
		}
		Bytes::Ptr rom_(Bytes::create());
		if (!file->readBytes(rom_.get())) {
			file->close();
			onError("Failed to read the kernel.", false, -1, -1, -1);
			++errors;

			break;
		}
		file->close();

		program.rom = rom_;
		onPrint("Succeeded to load the kernel.");
	} while (false);

	// Output the loading state.
	if (errors == 0) {
		onPrint("Ok.");
	} else {
		onPrint("Error!");
	}

	return errors == 0;
}

bool compile(Program &program, const Options &options) {
	// Prepare.
	const std::string &ast                                                     = options.ast;
	const Options::Passes passes                                               = options.passes;
	const Bytes::Ptr &icon                                                     = options.icon;
	const Bytes::Ptr &backgroundPalettes                                       = options.backgroundPalettes;
	const Bytes::Ptr &spritePalettes                                           = options.spritePalettes;
	const std::string &title                                                   = options.title;
	const Options::Strategies &strategies                                      = options.strategies;
	const Options::Strategies::Compatibilities compatibility                   = strategies.compatibility;
	const int sramType                                                         = Math::clamp(strategies.sramType, 0x00, 0x04);
	const bool cartridgeHasRtc                                                 = strategies.cartridgeHasRtc;
	const bool caseInsensitive                                                 = strategies.caseInsensitive;
	const bool completeLineNumber                                              = strategies.completeLineNumber;
	const bool declarationRequired                                             = strategies.declarationRequired;
	const int indexBase                                                        = Math::clamp(strategies.indexBase, 0, 1);
	const int bootstrapBank_                                                   = strategies.bootstrapBank;
	const int heapSize                                                         = Math::clamp(strategies.heapSize, 0, RAM_SIZE);
	const int stackSize                                                        = Math::clamp(strategies.stackSize, 0, RAM_SIZE);
	const bool failOnError                                                     = strategies.failOnError;
	const bool optimizeCode                                                    = strategies.optimizeCode;
	const bool optimizeAssets                                                  = strategies.optimizeAssets;
	const Options::Piping &piping                                              = options.piping;
	const Options::PrintHandler onPrint                                        = options.onPrint;
	const Options::ErrorHandler onError_                                       = options.onError;
	const ActorAssets::Entry::PlayerBehaviourCheckingHandler isPlayerBehaviour = options.isPlayerBehaviour;
	const Pipeline::PrintHandler onPipelinePrint                               = options.onPipelinePrint;
	const Pipeline::ErrorHandler onPipelineError                               = options.onPipelineError;

	program.compiled.effectiveSize = Pipeline::Size();

	int errors = 0;

	onPrint("Compiling...");

	// Parse the symbols.
	constexpr const int romMaxSize = ROM_MAX_SIZE;
	constexpr const int bankSize = BANK_SIZE;
	int bootstrapBank = bootstrapBank_;
	int bootstrapAddress = BOOTSTRAP_ENTRY_ADDRESS;

	SymbolTable symbols;
	do {
		// Prepare.
		if (program.symbols.empty())
			break;

		// Parse the symbols.
		if (!symbols.parseSymbols(program.symbols)) {
			onError_("Failed to parse the symbols.", true, -1, -1, -1);

			break;
		}

		// Parse the aliases.
		if (!symbols.parseAliases(program.aliases)) {
			onError_("Failed to parse the aliases.", true, -1, -1, -1);

			break;
		}

		// Get the entry address.
		const RomLocation* romLocation = symbols.find(BOOTSTRAP_ENTRY_NAME);
		if (romLocation) {
			bootstrapBank = romLocation->bank;
			bootstrapAddress = romLocation->address;
		}

		onPrint("Succeeded to parse the symbols.");
	} while (false);

	// Prepare the processors.
	Error::Handler onError = [onError_] (const Error &err, const std::string &msg, const TextLocation &loc) -> void {
		onError_(msg, err.isWarning, loc.page, loc.row, loc.column);
	};

	Parser parser;
	parser.option("compatibility", (Variant::Long)compatibility);
	parser.option("case_insensitive", caseInsensitive);
	parser.option("complete_line_number", completeLineNumber);
	parser.option("index_base", indexBase);
	parser.option("bank_size", bankSize);
	parser.option("fail_on_error", failOnError);

	Organizer organizer;

	Compiler compiler;
	compiler.option("passes", (Variant::Long)passes);
	compiler.option("compatibility", (Variant::Long)compatibility);
	compiler.option("sram_type", sramType);
	compiler.option("has_rtc", cartridgeHasRtc);
	compiler.option("bank_size", bankSize);
	compiler.option("bank", bootstrapBank);
	compiler.option("start_address", bootstrapAddress);
	compiler.option("heap_size", heapSize);
	compiler.option("stack_size", stackSize);
	compiler.option("case_insensitive", caseInsensitive);
	compiler.option("declaration_required", declarationRequired);
	compiler.option("index_base", indexBase);
	compiler.option("optimize_code", optimizeCode);
	compiler.option("optimize_assets", optimizeAssets);
	compiler.symbols(symbols);

	Programmer programmer;
	programmer.option("compatibility", (Variant::Long)compatibility);
	programmer.option("trim_unused_banks", true);
	programmer.option("sram_type", sramType);
	programmer.option("has_rtc", cartridgeHasRtc);
	programmer.option("rom_max_size", romMaxSize);
	programmer.option("bank_size", bankSize);
	programmer.option("bank", bootstrapBank);
	programmer.option("start_address", bootstrapAddress);
	programmer.option("icon", (Object::Ptr)icon);
	programmer.option("background_palettes", (Object::Ptr)backgroundPalettes);
	programmer.option("sprite_palettes", (Object::Ptr)spritePalettes);
	programmer.option("title", title);
	programmer.symbols(symbols);

	parser.initialize(compiler.builtins(), compiler.functions(), compiler.operators());
	parser.linesOfCode(0);

	Pipeline::Ptr pipeline(Pipeline::create(piping.useWorkQueue, piping.lessConsoleOutput));
	pipeline->open();
	pipeline->isPlayerBehaviour(isPlayerBehaviour);
	pipeline->onPrint(onPipelinePrint);
	pipeline->onError(onPipelineError);

	// Define builtin macros.
	const bool colored = (compatibility & GBBASIC::Options::Strategies::Compatibilities::COLORED) != GBBASIC::Options::Strategies::Compatibilities::NONE;
	const bool extension = (compatibility & GBBASIC::Options::Strategies::Compatibilities::EXTENSION) != GBBASIC::Options::Strategies::Compatibilities::NONE;
	const bool sram = sramType != 0x00;
	const bool rtc = cartridgeHasRtc;
	const Parser::Macros builtinMacros = {
		{ "IS_COLORED_CARTRIDGE", colored ? 1 : 0 },
		{ "IS_EXTENSION_CARTRIDGE", extension ? 1 : 0 },
		{ "CARTRIDGE_HAS_SRAM", sram ? 1 : 0 },
		{ "CARTRIDGE_HAS_RTC", rtc ? 1 : 0 }
	};

	// Parse, organize and compile the source code.
	int codeLength = 0;
	do {
		// Prepare.
		Organizer::Nodes asts;
		int parsingErrors = 0;

		// Parse.
		Macro::List macros;
		for (int i = 0; i < program.assets->code.count(); ++i) {
			std::string code;
			CodeAssets::Entry* entry = program.assets->code.get(i);
			entry->toString(code, nullptr);
			const bool ok = parser.process(
				code, i,
				compiler.array(), compiler.data(), compiler.builtins(), compiler.functions(), compiler.operators(),
				compiler.macroAliases(),
				compiler.macroFunctions(),
				compiler.macroConstants(),
				compiler.macroIdentifierAliases(),
				compiler.macroStackReferences(),
				macros,
				builtinMacros,
				onError
			);
			if (!ok) {
				onError_("Failed to parse the source code.", false, -1, -1, -1);
				++errors;
				++parsingErrors;

				break;
			}
			program.lineNumberWidth = parser.lineNumberWidth();
			asts.push_back(parser.ast());
			codeLength += (int)code.length();
		}
		program.compiled.macros = macros;

		if (parsingErrors == 0)
			onPrint("Succeeded to parse the source code.");
		else
			break;

		// Organize.
		if (!organizer.process(asts)) {
			onError_("Failed to organize the code pages.", false, -1, -1, -1);
			++errors;

			break;
		}

		INode::Ptr root = organizer.ast();
		if (ast != "none")
			program.ast = root->dump(1);
		program.root = root;
		onPrint("Succeeded to organize the code pages.");

		if (passes <= Options::Passes::PARSE)
			return errors == 0;

		// Output the AST.
		do {
			// Write the AST.
			if (ast != "none") {
				const std::string ast_ = program.ast;
				if (ast == "" || ast == "stdout" || ast == "con" || ast == "console") {
					onPrint(Text::format("AST:\n{0}", ast_));
				} else {
					File::Ptr file_(File::create());
					if (file_->open(ast.c_str(), Stream::WRITE)) {
						file_->writeString(ast_);
						file_->close();
					}
				}
			}
		} while (false);

		// Compile.
		RamLocation::Dictionary allocations;
		int compiledSize = 0;
		if (!compiler.process(organizer.ast(), program.assets, pipeline, &allocations, &compiledSize, onError)) {
			program.compiled.allocations = allocations;

			onError_("Failed to compile the source code.", false, -1, -1, -1);
			++errors;

			break;
		}
		const int fontSize = pipeline->effectiveSize().font();
		const int codeSize = compiledSize - fontSize; // Minus font size because it also counts in the `bytes`.
		program.compiled.allocations = allocations;
		program.compiled.effectiveSize.addCode(codeSize);
		program.compiled.effectiveSize += pipeline->effectiveSize();

		onPrint("Succeeded to compile the source code.");

		if (passes <= Options::Passes::GENERATE)
			return errors == 0;
	} while (false);

	// Program the ROM.
	do {
		// Prepare.
		if (errors)
			break; // Ignore this state.

		// Check the compiled result.
		if (!compiler.bytes())
			break;

		// Program the ROM.
		if (!programmer.process(program.rom, compiler.bytes(), onError)) {
			onError_("Failed to program the ROM.", false, -1, -1, -1);
			++errors;

			break;
		}

		program.compiled.bytes = programmer.bytes();
		onPrint("Succeeded to program the ROM.");
	} while (false);

	// Output the compiling state.
	if (errors == 0) {
		const std::string srcn = Text::toScaledBytes(codeLength);
		const std::string dstn = Text::toScaledBytes(program.compiled.effectiveSize.code());
		onPrint(Text::format("Compiled {0} ({1} loc) source code to {2} instructions.", { srcn, Text::toString(parser.linesOfCode()), dstn }));

		pipeline->prompt(program.assets);

		onPrint("Ok.");
	} else {
		onPrint("Error!");
	}

	// Finish.
	pipeline->close();
	pipeline = nullptr;

	return errors == 0;
}

bool link(Program &program, const Options &options) {
	// Prepare.
	const std::string &dst              = options.output;
	const Options::PrintHandler onPrint = options.onPrint;
	const Options::ErrorHandler onError = options.onError;

	if (options.passes <= Options::Passes::GENERATE) {
		onError("Ignore linking due to the parse-only option is on.", true, -1, -1, -1);

		return false;
	}

	int errors = 0;

	onPrint("Linking...");

	// Output the ROM.
	do {
		// Prepare.
		if (dst.empty())
			break;

		// Write the ROM.
		File::Ptr file(File::create());
		if (!file->open(dst.c_str(), Stream::WRITE)) {
			onError("Failed to open the ROM file.", false, -1, -1, -1);
			++errors;

			break;
		}
		if (!file->writeBytes(program.compiled.bytes.get())) {
			file->close();
			onError("Failed to write the ROM file.", false, -1, -1, -1);
			++errors;

			break;
		}
		file->close();
	} while (false);

	// Output the saving state.
	if (errors == 0) {
		const size_t romSize = program.compiled.bytes->count();
		const size_t banks = romSize / BANK_SIZE;
		std::string msg;
		msg += "Effective size " + Text::toScaledBytes(program.compiled.effectiveSize.total()) + ", ";
		msg += "ROM size " + Text::toScaledBytes(romSize) + ", ";
		if (banks <= 1)
			msg += Text::toString((unsigned)banks) + " bank;";
		else
			msg += Text::toString((unsigned)banks) + " banks;";
		msg += "\n";
		msg += "Breakdown:\n";
		msg += program.compiled.effectiveSize.toString(2);
		onPrint(msg);

		onPrint("Ok.");
	} else {
		onPrint("Error!");
	}

	return errors == 0;
}

void identifiers(IdentifierHandler handler) {
	if (!handler)
		return;

	BuiltinTable builtins;
	FunctionTable functions;
	OperatorTable operators;
	Parser parser;
	parser.initialize(builtins, functions, operators);
	const Parser::StatementDictionary &statements = parser.statements();
	const Text::Array &statementsWithReturned = parser.statementsWithReturned();

	builtins.foreach(
		[handler] (const std::string &key, const BuiltinTable::Entry &/* entry */) -> void {
			std::string lkey = key;
			Text::toLowerCase(lkey);
			if (lkey == key)
				handler(key, "builtin");
			else
				handler(key, "constant");
		}
	);
	functions.foreach(
		[handler] (const std::string &key, const FunctionTable::Entry &/* entry */) -> void {
			handler(key, "function");
		}
	);
	operators.foreach(
		[handler] (const std::string &key, const OperatorTable::Entry &/* entry */) -> void {
			handler(key, "operator");
		}
	);
	for (Parser::StatementDictionary::const_iterator it = statements.begin(); it != statements.end(); ++it) {
		handler(it->first, "statement");
	}
	for (Text::Array::const_iterator it = statementsWithReturned.begin(); it != statementsWithReturned.end(); ++it) {
		handler(*it, "statement_with_returned");
	}
}

}

/* ===========================================================================} */
